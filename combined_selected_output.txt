

/* ===== START: hypernova/client/index.html ===== */
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HyperNova OS Boot</title>
        <link rel="stylesheet" href="css/style.css" />
    </head>
    <body>
        <div id="login-screen">
            <canvas id="login-background-canvas"></canvas>

            <div id="login-vfx-container">
                <div class="scanline"></div>
            </div>
            <div class="login-form-container">
                <h2 class="glitch" data-text="SYSTEM ACCESS">SYSTEM ACCESS</h2>
                <form id="login-form">
                    <div>
                        <label for="username">PILOT ID:</label>
                        <input
                            type="text"
                            id="username"
                            name="username"
                            required
                            placeholder="Enter Callsign"
                        />
                    </div>
                    <div>
                        <label for="password">PASSCODE:</label>
                        <input
                            type="password"
                            id="password"
                            name="password"
                            required
                            placeholder="Enter Secure Key"
                        />
                    </div>
                    <button type="submit" class="cybr-btn">
                        Engage
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </button>
                </form>
                <p id="login-error" class="login-feedback"></p>
                <p id="login-message" class="login-feedback"></p>
                <div class="footer-text">HyperNova Secure Terminal v2.7.3</div>
            </div>
        </div>

        <div id="game-container" class="hidden">
            {/* This container will be made full-screen */ }
            <canvas id="gameCanvas"></canvas> {/* This canvas will be resized by
            JS */ }
            <div id="ui"></div>
            {/* UI remains an overlay */}
        </div>

        <audio id="login-music" loop>
            <source
                src="assets/audio/upbeat-space-theme.mp3"
                type="audio/mpeg"
            />
            Your browser does not support the audio element.
        </audio>

        <script src="/socket.io/socket.io.js"></script>
        <script type="module" src="js/main.js"></script>
    </body>
</html>

/* ===== END: hypernova/client/index.html ===== */


/* ===== START: hypernova/client/css/style.css ===== */
/* Existing styles from your file */
body {
  margin: 0;
  background-color: #000; /* Fallback for body */
  color: #00FF00; 
  font-family: 'Courier New', Courier, monospace; 
  overflow: hidden; /* Critical for full-screen */
}

#game-container {
    position: fixed; /* Take up full viewport */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000; /* Background of the container if canvas doesn't fill it */
}

#gameCanvas {
  display: block;
  /* background: #000; */ /* Background will be drawn by renderer now */
  /* Width and height will be set by JavaScript */
  position: absolute;
  top: 0;
  left: 0;
}

#ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10; /* Ensure UI is above game canvas */
}
.panel {
  position: absolute;
  background: rgba(0, 20, 30, 0.85); /* Darker, more thematic panel */
  border: 1px solid rgba(0, 200, 255, 0.5); /* Cyan border */
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
  padding: 15px;
  max-width: 520px; /* Slightly wider for more text */
  pointer-events: auto;
  color: #99FFFF; /* Lighter cyan text for panels */
  font-family: inherit; 
  border-radius: 5px;
}

button { 
  background: rgba(0, 100, 150, 0.6);
  color: #66FFFF;
  border: 1px solid #00AACC;
  padding: 8px 15px;
  margin: 5px;
  pointer-events: auto;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 1px;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}
button:hover {
    background: rgba(0, 150, 200, 0.8);
    box-shadow: 0 0 8px rgba(0, 200, 255, 0.5);
}


::selection {
  background: #0f0;
  color: #000;
}
.trade-item-selected {
  background-color: rgba(0, 100, 100, 0.3); /* More thematic selection */
  border-left: 2px solid #00f2ea;
}
.menu-item {
  padding: 4px 2px; /* More spacing */
}
.menu-item div {
  padding: 2px 0;
}
body.no-scroll {
  overflow: hidden;
}

/* ===== HYPER COOL SCI-FI LOGIN SCREEN STYLES ===== */

#login-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', Courier, monospace; 
    overflow: hidden; 
    background-color: #000000; 
    color: #00FF00; 
}

#login-background-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; 
}

#login-vfx-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; 
    z-index: 1; 
}

.scanline {
    width: 100%;
    height: 100px; 
    position: absolute;
    top: -100px; 
    left: 0;
    background: linear-gradient(
        to bottom,
        rgba(20, 100, 200, 0), 
        rgba(50, 150, 255, 0.08) 40%, 
        rgba(50, 150, 255, 0.12) 50%,
        rgba(50, 150, 255, 0.08) 60%,
        rgba(20, 100, 200, 0) 
    );
    animation: scan 7s linear infinite;
    opacity: 0.6;
}

@keyframes scan {
    0% { top: -100px; }
    100% { top: 100%; }
}

.login-form-container {
    position: relative; 
    z-index: 2; 
    background: rgba(5, 15, 30, 0.85); 
    padding: 30px 40px;
    border-radius: 8px;
    border: 1px solid rgba(0, 255, 255, 0.3); 
    box-shadow: 0 0 25px rgba(0, 200, 255, 0.3), 
                inset 0 0 15px rgba(0, 150, 200, 0.2);
    text-align: center;
    width: 380px; 
    animation: fadeInForm 1s ease-out forwards;
}

@keyframes fadeInForm {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

#login-screen h2 { 
    font-size: 2em;
    color: #66FFFF; 
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 30px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    padding-bottom: 15px;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}

.glitch {
    position: relative;
    color: #66FFFF;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}
.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: inherit; 
    overflow: hidden;
}
.glitch::before {
    left: 2px;
    text-shadow: -1px 0 red;
    animation: glitch-anim-1 2s infinite linear alternate-reverse;
}
.glitch::after {
    left: -2px;
    text-shadow: -1px 0 blue, 2px 2px yellow;
    animation: glitch-anim-2 2s infinite linear alternate-reverse;
}

@keyframes glitch-anim-1 {
    0% { clip: rect(35px, 9999px, 92px, 0); }
    25% { clip: rect(32px, 9999px, 1px, 0); }
    50% { clip: rect(45px, 9999px, 36px, 0); }
    75% { clip: rect(11px, 9999px, 5px, 0); }
    100% { clip: rect(62px, 9999px, 77px, 0); }
}
@keyframes glitch-anim-2 {
    0% { clip: rect(70px, 9999px, 10px, 0); }
    25% { clip: rect(3px, 9999px, 48px, 0); }
    50% { clip: rect(90px, 9999px, 50px, 0); }
    75% { clip: rect(22px, 9999px, 79px, 0); }
    100% { clip: rect(5px, 9999px, 60px, 0); }
}


#login-form div {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column; 
    align-items: flex-start; 
}

#login-form label {
    display: block; 
    width: auto; 
    margin-right: 0;
    margin-bottom: 8px; 
    color: #00AACC; 
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: left;
}

#login-form input[type="text"],
#login-form input[type="password"] {
    background-color: rgba(0, 50, 70, 0.5); 
    border: 1px solid #007799; 
    color: #99FFFF; 
    padding: 12px 15px;
    font-family: inherit;
    border-radius: 4px;
    width: calc(100% - 30px); 
    box-shadow: inset 0 0 8px rgba(0, 100, 150, 0.3);
    transition: border-color 0.3s, box-shadow 0.3s;
    caret-color: #66FFFF; 
}

#login-form input[type="text"]::placeholder,
#login-form input[type="password"]::placeholder {
    color: #007799;
    opacity: 0.7;
}

#login-form input[type="text"]:focus,
#login-form input[type="password"]:focus {
    outline: none;
    border-color: #66FFFF; 
    box-shadow: 0 0 10px rgba(102, 255, 255, 0.5), 
                inset 0 0 10px rgba(102, 255, 255, 0.3);
}

/* ===== NEW FANCY SCI-FI ENGAGE BUTTON ===== */
.cybr-btn {
    --btn-color-primary: #00f2ea; /* Bright Teal/Cyan */
    --btn-color-secondary: #7DF9FF; /* Electric Blue / Lighter Cyan */
    --btn-glow-color: rgba(0, 242, 234, 0.5);
    --btn-bg-color: rgba(10, 30, 50, 0.6); /* Slightly transparent dark blue */
    --btn-border-size: 2px;

    position: relative;
    padding: 12px 30px;
    margin-top: 25px; 
    font-family: 'Courier New', Courier, monospace; 
    font-size: 1.1em;
    font-weight: bold;
    color: var(--btn-color-primary);
    background-color: var(--btn-bg-color);
    border: var(--btn-border-size) solid var(--btn-color-primary);
    border-radius: 5px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    cursor: pointer;
    outline: none;
    overflow: hidden; 
    transition: color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    z-index: 1; 
}

.cybr-btn::before,
.cybr-btn::after {
    content: '';
    position: absolute;
    width: 0;
    height: var(--btn-border-size);
    background-color: var(--btn-color-secondary);
    transition: width 0.4s ease-out;
    z-index: -1; 
}

.cybr-btn::before { 
    top: 0;
    left: 50%; 
    transform: translateX(-50%);
}

.cybr-btn::after { 
    bottom: 0;
    right: 50%; 
    transform: translateX(50%);
}

.cybr-btn:hover::before,
.cybr-btn:hover::after {
    width: 105%; 
}

.cybr-btn span[aria-hidden="true"] {
    display: block;
    position: absolute;
    width: var(--btn-border-size);
    height: 0%;
    background-color: var(--btn-color-secondary);
    opacity: 0;
    transition: height 0.4s ease-out 0.2s, opacity 0.3s ease-out 0.2s; 
}

.cybr-btn span[aria-hidden="true"]:first-of-type {
    top: 50%;
    left: 0;
    transform: translateY(-50%);
}

.cybr-btn span[aria-hidden="true"]:nth-of-type(2) {
    bottom: 50%; 
    right: 0;
    transform: translateY(50%);
}

.cybr-btn:hover span[aria-hidden="true"] {
    height: 105%; 
    opacity: 1;
}

.cybr-btn:hover {
    color: #ffffff; 
    background-color: rgba(0, 242, 234, 0.15); 
    border-color: var(--btn-color-secondary);
    box-shadow: 0 0 15px var(--btn-glow-color), 0 0 25px var(--btn-glow-color);
}

.cybr-btn:active {
    color: var(--btn-color-primary);
    background-color: rgba(0, 242, 234, 0.25);
    box-shadow: 0 0 5px var(--btn-glow-color), inset 0 0 10px var(--btn-glow-color);
    transform: translateY(1px); 
}
/* ===== END OF NEW BUTTON STYLES ===== */


#login-error, #login-message {
    margin-top: 20px;
    min-height: 1.2em;
    font-size: 0.9em;
    letter-spacing: 0.5px;
}
#login-error {
    color: #FF6666; 
    text-shadow: 0 0 5px #FF6666;
}
#login-message {
    color: #66FF99; 
    text-shadow: 0 0 5px #66FF99;
}
.login-feedback { 
    opacity: 0;
    transition: opacity 0.5s;
}
.login-feedback:not(:empty) { 
    opacity: 1;
}


.footer-text {
    margin-top: 30px;
    font-size: 0.75em;
    color: rgba(0, 255, 255, 0.4); 
    letter-spacing: 1px;
}


.hidden {
    display: none !important;
}

/* Universe Map Specific (if ever HTML based, good to have a placeholder) */
.universe-map-container { }
.system-entry { }
/* ===== END: hypernova/client/css/style.css ===== */


/* ===== START: hypernova/client/js/client_config.js ===== */
// client/js/client_config.js
export const BASE_THRUST = 0.1;
export const BASE_ROTATION_SPEED = 0.07;
export const DAMPING = 0.99;
export const PROJECTILE_LIFESPAN_MS = 400; // ms
export const DOCKING_DISTANCE_SQUARED = 400; // (20px)^2
export const MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED = 22500; // (150px)^2 - adjust as needed
export const HYPERJUMP_CHARGE_TIME_MS = 3000; // 3 seconds
export const HYPERJUMP_DENIED_MESSAGE_DURATION_MS = 3000; // 3 seconds

/* ===== END: hypernova/client/js/client_config.js ===== */


/* ===== START: hypernova/client/js/game_state.js ===== */
// hypernova/client/js/game_state.js
export const gameState = {
    currentUser: null,
    socket: null,
    myId: null,
    allShips: {},
    get myShip() {
        return this.allShips[this.myId];
    },
    projectiles: [],
    loadedImages: {}, 
    imagePathsToLoad: [],

    // Camera/Viewport for full-screen rendering
    camera: {
        x: 0,
        y: 0,
        width: 800, // Will be updated to screen size
        height: 600, // Will be updated to screen size
        zoom: 1.0, // Future use for zooming
        // Target for smooth camera movement (optional, more complex)
        // targetX: 0,
        // targetY: 0,
        // lerpFactor: 0.1 
    },

    clientGameData: {
        systems: [], // Will be populated with data that includes backgroundFile
        tradeGoods: [],
        weapons: {},
        shipTypes: [],
        MISSION_TYPES: {},
    },
    clientPlanetEconomies: [],

    docked: false,
    dockedAtDetails: null,
    isMenuOpen: false,
    activeSubMenu: null,

    selectedTradeIndex: 0,
    selectedWeaponKey: null,
    selectedShipIndex: 0,
    selectedMissionIndex: 0,
    availableMissionsForCurrentPlanet: [],

    weaponCycleIdx: 0,
    controls: {
        rotatingLeft: false,
        rotatingRight: false,
        accelerating: false,
        decelerating: false,
    },

    isChargingHyperjump: false,
    hyperjumpChargeStartTime: null,
    hyperjumpDeniedMessage: null,
    hyperjumpDeniedMessageTimeoutId: null,

    updateShipData(id, data) {
        if (!this.allShips[id]) {
            this.allShips[id] = {};
        }
        Object.assign(this.allShips[id], data);
        if (this.allShips[id]) {
            this.defaultShipProps(this.allShips[id]);
        }
    },

    defaultShipProps(ship) {
        if (!ship) return;

        const currentShipTypeData =
            this.clientGameData.shipTypes &&
            ship.type !== undefined &&
            ship.type !== null
                ? this.clientGameData.shipTypes[ship.type]
                : null;

        if (ship.system === undefined) ship.system = 0;
        if (ship.dockedAtPlanetIdentifier === undefined) ship.dockedAtPlanetIdentifier = null;

        if (currentShipTypeData) {
            if (ship.maxHealth === undefined) ship.maxHealth = currentShipTypeData.maxHealth || 100;
            if (ship.health === undefined || ship.health > ship.maxHealth) ship.health = ship.maxHealth;
            if (ship.maxCargo === undefined) ship.maxCargo = currentShipTypeData.maxCargo || 10;
        } else {
            if (ship.maxHealth === undefined) ship.maxHealth = 100;
            if (ship.health === undefined) ship.health = 100;
            if (ship.maxCargo === undefined) ship.maxCargo = 10;
        }

        if (ship.credits === undefined) ship.credits = 0;

        if (this.clientGameData.tradeGoods && this.clientGameData.tradeGoods.length > 0) {
            if (!ship.cargo || ship.cargo.length !== this.clientGameData.tradeGoods.length) {
                ship.cargo = new Array(this.clientGameData.tradeGoods.length).fill(0);
            }
        } else if (!ship.cargo) {
            ship.cargo = [];
        }

        if (!ship.weapons) ship.weapons = [];
        if (!ship.activeWeapon && ship.weapons.length > 0) ship.activeWeapon = ship.weapons[0];
        if (!ship.activeMissions) ship.activeMissions = [];
    },
};
/* ===== END: hypernova/client/js/game_state.js ===== */


/* ===== START: hypernova/client/js/input_handler.js ===== */
// client/js/input_handler.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";
import { UIManager } from "./ui_manager.js";
import {
    BASE_THRUST,
    BASE_ROTATION_SPEED,
    DAMPING,
    DOCKING_DISTANCE_SQUARED,
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED,
    HYPERJUMP_DENIED_MESSAGE_DURATION_MS,
} from "./client_config.js";

// `wrap` function is primarily for angles now.
// World position wrapping needs to be handled by server or based on world boundaries.
function wrap(value, max) {
    return ((value % max) + max) % max;
}

export function initInputListeners(canvas) {
    // canvas is gameCanvas
    window.addEventListener("keydown", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        const keyLower = e.key.toLowerCase();
        const gameSpecificKeys = [
            "arrowup",
            "arrowdown",
            "arrowleft",
            "arrowright",
            " ",
            "d",
            "h",
            "q",
            "e",
            "t",
            "y",
            "o",
            "m",
            "u",
            "b",
            "s",
            "a",
            "escape",
        ];

        if (gameSpecificKeys.includes(keyLower)) {
            e.preventDefault();
        }

        if (gameState.hyperjumpDeniedMessage && keyLower !== "h") {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            return;
        }

        if (!gameState.docked) {
            if (e.code === "Space" && !gameState.isChargingHyperjump)
                Network.fireWeapon();
            switch (keyLower) {
                case "arrowup":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.accelerating = true;
                    break;
                case "arrowdown":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.decelerating = true;
                    break;
                case "arrowleft":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.rotatingLeft = true;
                    break;
                case "arrowright":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.rotatingRight = true;
                    break;
                case "d":
                    if (!gameState.isChargingHyperjump) tryDockAction();
                    break;
                case "h":
                    hyperJumpAction();
                    break;
                case "q":
                    if (!gameState.isChargingHyperjump) cycleWeaponAction(-1);
                    break;
                case "e":
                    if (!gameState.isChargingHyperjump) cycleWeaponAction(1);
                    break;
            }
        } else {
            handleMenuKeyDown(keyLower);
        }
    });

    window.addEventListener("keyup", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        if (
            !gameState.myShip ||
            gameState.myShip.destroyed ||
            gameState.docked
        ) {
            gameState.controls.accelerating = false;
            gameState.controls.decelerating = false;
            gameState.controls.rotatingLeft = false;
            gameState.controls.rotatingRight = false;
            return;
        }
        const keyLower = e.key.toLowerCase();
        switch (keyLower) {
            case "arrowup":
                gameState.controls.accelerating = false;
                break;
            case "arrowdown":
                gameState.controls.decelerating = false;
                break;
            case "arrowleft":
                gameState.controls.rotatingLeft = false;
                break;
            case "arrowright":
                gameState.controls.rotatingRight = false;
                break;
        }
    });
}

function tryDockAction() {
    if (
        !gameState.myShip ||
        !gameState.clientGameData.systems[gameState.myShip.system]
    )
        return;
    const planetsInCurrentSystem =
        gameState.clientGameData.systems[gameState.myShip.system].planets;
    let nearestDistSq = Infinity,
        nearestPlanetIndex = -1;

    planetsInCurrentSystem.forEach((p, index) => {
        const planetScale = p.planetImageScale || 1.0;
        // Adjust docking distance based on planet scale, make it more generous
        const effectiveDockingDistanceSq =
            DOCKING_DISTANCE_SQUARED * Math.pow(planetScale, 2) * 2.5;

        const d2 =
            (gameState.myShip.x - p.x) ** 2 + (gameState.myShip.y - p.y) ** 2;
        if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearestPlanetIndex = index;
        }
    });
    const planetForDocking = planetsInCurrentSystem[nearestPlanetIndex];
    const effectiveDockingDistanceSq =
        DOCKING_DISTANCE_SQUARED *
        Math.pow(planetForDocking?.planetImageScale || 1.0, 2) *
        2.5;

    if (
        nearestPlanetIndex !== -1 &&
        nearestDistSq < effectiveDockingDistanceSq
    ) {
        Network.requestDock(gameState.myShip.system, nearestPlanetIndex);
    }
}

function hyperJumpAction() {
    // ... (hyperJumpAction from previous version, canvas argument removed as it's not directly used for world logic) ...
    if (
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.clientGameData.systems.length === 0 ||
        gameState.docked
    ) {
        return;
    }
    if (gameState.isChargingHyperjump) {
        console.log("Hyperjump already charging.");
        return;
    }
    if (gameState.hyperjumpDeniedMessage) {
        clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessage = null;
        gameState.hyperjumpDeniedMessageTimeoutId = null;
    }
    const currentSystemData =
        gameState.clientGameData.systems[gameState.myShip.system];
    if (currentSystemData && currentSystemData.planets) {
        for (const planet of currentSystemData.planets) {
            const distSq =
                (gameState.myShip.x - planet.x) ** 2 +
                (gameState.myShip.y - planet.y) ** 2;
            // Make min distance scale with planet, or use a larger fixed value for full screen
            const minJumpDistSq =
                MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED *
                Math.pow(planet.planetImageScale || 1.0, 2) *
                1.5;
            if (distSq < minJumpDistSq) {
                gameState.hyperjumpDeniedMessage =
                    "Too close to a celestial body to engage hyperdrive.";
                if (gameState.hyperjumpDeniedMessageTimeoutId)
                    clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
                gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                    gameState.hyperjumpDeniedMessage = null;
                    gameState.hyperjumpDeniedMessageTimeoutId = null;
                }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
                return;
            }
        }
    }
    console.log("Attempting to request hyperjump from server.");
    Network.requestHyperjump(); // Server will handle destination selection logic now
}

function cycleWeaponAction(direction) {
    // ... (cycleWeaponAction from previous version is fine) ...
    if (
        !gameState.myShip ||
        !gameState.myShip.weapons ||
        gameState.myShip.weapons.length === 0
    )
        return;
    gameState.weaponCycleIdx =
        (gameState.weaponCycleIdx +
            direction +
            gameState.myShip.weapons.length) %
        gameState.myShip.weapons.length;
    const weaponName = gameState.myShip.weapons[gameState.weaponCycleIdx];
    Network.equipWeapon(weaponName);
}

function handleMenuKeyDown(keyLower) {
    // ... (handleMenuKeyDown from previous version is fine) ...
    if (!gameState.docked || !gameState.myShip) {
        gameState.activeSubMenu = null;
        return;
    }
    if (!gameState.activeSubMenu) {
        switch (keyLower) {
            case "t":
                gameState.activeSubMenu = "trade";
                gameState.selectedTradeIndex = 0;
                UIManager.renderTradeMenu();
                break;
            case "y":
                gameState.activeSubMenu = "shipyard";
                gameState.selectedShipIndex = 0;
                UIManager.renderShipyardMenu();
                break;
            case "o":
                gameState.activeSubMenu = "outfitter";
                const weaponKeysList = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (
                    !gameState.selectedWeaponKey ||
                    !weaponKeysList.includes(gameState.selectedWeaponKey)
                ) {
                    gameState.selectedWeaponKey = weaponKeysList[0] || null;
                }
                UIManager.renderOutfitterMenu();
                break;
            case "m":
                gameState.activeSubMenu = "missions";
                gameState.selectedMissionIndex = 0;
                gameState.availableMissionsForCurrentPlanet = [];
                UIManager.renderMissionsMenu();
                if (gameState.dockedAtDetails) {
                    Network.requestMissions(
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                break;
            case "u":
                Network.undock();
                break;
        }
    } else {
        if (keyLower === "escape") {
            gameState.activeSubMenu = null;
            UIManager.renderMainMenu();
            return;
        }
        switch (gameState.activeSubMenu) {
            case "trade":
                const numTradeGoods =
                    gameState.clientGameData.tradeGoods.length;
                if (keyLower === "arrowup")
                    gameState.selectedTradeIndex = Math.max(
                        0,
                        gameState.selectedTradeIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedTradeIndex = Math.min(
                        numTradeGoods - 1,
                        gameState.selectedTradeIndex + 1,
                    );
                else if (keyLower === "b" && numTradeGoods > 0)
                    Network.buyGood(gameState.selectedTradeIndex);
                else if (keyLower === "s" && numTradeGoods > 0)
                    Network.sellGood(gameState.selectedTradeIndex);
                UIManager.renderTradeMenu();
                break;
            case "outfitter":
                const weaponKeys = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (weaponKeys.length > 0) {
                    let currentWKeyIndex = weaponKeys.indexOf(
                        gameState.selectedWeaponKey,
                    );
                    if (currentWKeyIndex === -1 && weaponKeys.length > 0)
                        currentWKeyIndex = 0;
                    if (keyLower === "arrowup")
                        currentWKeyIndex = Math.max(0, currentWKeyIndex - 1);
                    else if (keyLower === "arrowdown")
                        currentWKeyIndex = Math.min(
                            weaponKeys.length - 1,
                            currentWKeyIndex + 1,
                        );
                    gameState.selectedWeaponKey = weaponKeys[currentWKeyIndex];
                }
                if (keyLower === "b" && gameState.selectedWeaponKey)
                    Network.equipWeapon(gameState.selectedWeaponKey);
                UIManager.renderOutfitterMenu();
                break;
            case "shipyard":
                const numShipTypes = gameState.clientGameData.shipTypes.length;
                if (keyLower === "arrowup")
                    gameState.selectedShipIndex = Math.max(
                        0,
                        gameState.selectedShipIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedShipIndex = Math.min(
                        numShipTypes - 1,
                        gameState.selectedShipIndex + 1,
                    );
                else if (keyLower === "b" && numShipTypes > 0)
                    Network.buyShip(gameState.selectedShipIndex);
                UIManager.renderShipyardMenu();
                break;
            case "missions":
                const numMissions =
                    gameState.availableMissionsForCurrentPlanet.length;
                if (keyLower === "arrowup")
                    gameState.selectedMissionIndex = Math.max(
                        0,
                        gameState.selectedMissionIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedMissionIndex = Math.min(
                        numMissions - 1,
                        gameState.selectedMissionIndex + 1,
                    );
                else if (
                    keyLower === "a" &&
                    numMissions > 0 &&
                    gameState.availableMissionsForCurrentPlanet[
                        gameState.selectedMissionIndex
                    ]
                ) {
                    const missionToAccept =
                        gameState.availableMissionsForCurrentPlanet[
                            gameState.selectedMissionIndex
                        ];
                    Network.acceptMission(
                        missionToAccept.id,
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                UIManager.renderMissionsMenu();
                break;
        }
    }
}

export function processInputs() {
    // Removed canvas argument, will use gameState.camera or world bounds
    if (!gameState.myShip || gameState.myShip.destroyed || gameState.docked) {
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            gameState.isChargingHyperjump &&
            !gameState.docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            // Player position is not wrapped on client; server is authoritative.
            // If local world bounds were defined, wrapping would happen here against those.
            Network.sendControls();
        }
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        return;
    }

    const myShip = gameState.myShip;
    if (
        !myShip ||
        myShip.type === undefined ||
        myShip.type === null ||
        !gameState.clientGameData.shipTypes ||
        myShip.type >= gameState.clientGameData.shipTypes.length ||
        !gameState.clientGameData.shipTypes[myShip.type]
    ) {
        return;
    }
    const shipDef = gameState.clientGameData.shipTypes[myShip.type];

    const thrust = BASE_THRUST * shipDef.speedMult;
    const rotSpd = BASE_ROTATION_SPEED * shipDef.rotMult;
    const revThrust = thrust * shipDef.revMult;

    if (gameState.controls.rotatingLeft) myShip.angle -= rotSpd;
    if (gameState.controls.rotatingRight) myShip.angle += rotSpd;
    myShip.angle = wrap(myShip.angle, 2 * Math.PI); // Angles always wrap

    if (gameState.controls.accelerating) {
        myShip.vx += thrust * Math.cos(myShip.angle);
        myShip.vy += thrust * Math.sin(myShip.angle);
    }
    if (gameState.controls.decelerating) {
        myShip.vx -= revThrust * Math.cos(myShip.angle);
        myShip.vy -= revThrust * Math.sin(myShip.angle);
    }

    myShip.vx *= DAMPING;
    myShip.vy *= DAMPING;

    myShip.x += myShip.vx;
    myShip.y += myShip.vy;

    // Player position wrapping to screen edges is REMOVED.
    // The server will handle world boundaries if any.
    // The camera keeps the player in view.
    // myShip.x = wrap(myShip.x, gameState.camera.width); // No longer wrapping to camera/screen
    // myShip.y = wrap(myShip.y, gameState.camera.height); // No longer wrapping to camera/screen

    Network.sendControls();
}

/* ===== END: hypernova/client/js/input_handler.js ===== */


/* ===== START: hypernova/client/js/main.js ===== */
// hypernova/client/js/main.js

console.log("main.js script started");

import { gameState } from "./game_state.js";
window.gameState = gameState;

import { initNetwork } from "./network.js";
import { Renderer } from "./renderer.js";
import { initInputListeners, processInputs } from "./input_handler.js";
import { UIManager } from "./ui_manager.js";

// --- DYNAMIC LOGIN BACKGROUND & MUSIC (from previous update) ---
let loginBgCanvas, loginBgCtx;
let stars = [];
let shootingStars = [];
let loginAnimationId = null;

// const STAR_COLORS = ["#FFFFFF", "#FFFFE0", "#ADD8E6", "#FFDAB9"]; // Not used if stars are white
// const SHOOTING_STAR_COLOR = "rgba(220, 220, 255, 0.8)"; // Defined in ShootingStar class draw

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}
class Star {
    constructor(x, y, radius, opacity) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.opacity = opacity;
        this.maxOpacity = opacity;
        this.minOpacity = Math.max(0.1, opacity - 0.5);
        this.opacitySpeed =
            getRandom(0.005, 0.015) * (Math.random() > 0.5 ? 1 : -1);
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.fill();
    }
    update() {
        this.opacity += this.opacitySpeed;
        if (this.opacity > this.maxOpacity || this.opacity < this.minOpacity) {
            this.opacitySpeed *= -1;
            this.opacity = Math.max(
                this.minOpacity,
                Math.min(this.maxOpacity, this.opacity),
            );
        }
    }
}
class ShootingStar {
    constructor() {
        this.reset();
    }
    reset() {
        this.active = true;
        this.x = Math.random() * loginBgCanvas.width;
        this.y = 0;
        this.length = getRandom(150, 300);
        this.angle = getRandom(Math.PI * 0.35, Math.PI * 0.65);
        this.speed = getRandom(300, 500);
        this.opacity = 1;
        this.life = 1;
        const side = Math.random();
        if (side < 0.4) {
            this.x = Math.random() * loginBgCanvas.width;
            this.y = -this.length;
            this.angle = getRandom(Math.PI * 0.4, Math.PI * 0.6);
        } else if (side < 0.7) {
            this.x = -this.length;
            this.y = Math.random() * loginBgCanvas.height * 0.7;
            this.angle = getRandom(Math.PI * 0.15, Math.PI * 0.35);
        } else {
            this.x = loginBgCanvas.width + this.length;
            this.y = Math.random() * loginBgCanvas.height * 0.7;
            this.angle = getRandom(Math.PI * 0.65, Math.PI * 0.85);
        }
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
    }
    update(deltaTime) {
        if (!this.active) return;
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life -= 0.5 * deltaTime;
        if (this.life <= 0) {
            this.active = false;
        }
    }
    draw(ctx) {
        if (!this.active) return;
        const tailX = this.x - Math.cos(this.angle) * this.length;
        const tailY = this.y - Math.sin(this.angle) * this.length;
        const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
        gradient.addColorStop(
            0,
            `rgba(220, 220, 255, ${this.opacity * this.life})`,
        );
        gradient.addColorStop(
            0.3,
            `rgba(200, 200, 255, ${this.opacity * this.life * 0.5})`,
        );
        gradient.addColorStop(1, `rgba(150, 150, 220, 0)`);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tailX, tailY);
        ctx.strokeStyle = gradient;
        ctx.lineWidth = getRandom(1.5, 3);
        ctx.stroke();
    }
}
function createStars() {
    stars = [];
    const numStars = Math.floor(
        (loginBgCanvas.width * loginBgCanvas.height) / 6000,
    );
    for (let i = 0; i < numStars; i++) {
        const x = Math.random() * loginBgCanvas.width;
        const y = Math.random() * loginBgCanvas.height;
        const radius = getRandom(0.2, 1.2);
        const opacity = getRandom(0.2, 0.8);
        stars.push(new Star(x, y, radius, opacity));
    }
}
function animateLoginBackground() {
    loginAnimationId = requestAnimationFrame(animateLoginBackground);
    loginBgCtx.fillStyle = "#00000A";
    loginBgCtx.fillRect(0, 0, loginBgCanvas.width, loginBgCanvas.height);
    stars.forEach((star) => {
        star.update();
        star.draw(loginBgCtx);
    });
    if (Math.random() < 0.015) {
        let newShootingStar = shootingStars.find((s) => !s.active);
        if (newShootingStar) {
            newShootingStar.reset();
        } else if (shootingStars.length < 10) {
            shootingStars.push(new ShootingStar());
        }
    }
    const now = performance.now();
    const deltaTime = (now - (animateLoginBackground.lastTime || now)) / 1000;
    animateLoginBackground.lastTime = now;
    shootingStars.forEach((ss) => {
        ss.update(deltaTime);
        ss.draw(loginBgCtx);
    });
}
function setupLoginMusic() {
    const music = document.getElementById("login-music");
    if (music) {
        music.volume = 0.3;
        music.play().catch((error) => {
            console.warn(
                "Login music autoplay was prevented by the browser:",
                error.message,
            );
            const playMusicOnClick = () => {
                music
                    .play()
                    .catch((e) =>
                        console.warn(
                            "Still couldn't play music after interaction:",
                            e.message,
                        ),
                    );
                document.body.removeEventListener("click", playMusicOnClick);
                document.body.removeEventListener("keydown", playMusicOnClick);
            };
            document.body.addEventListener("click", playMusicOnClick, {
                once: true,
            });
            document.body.addEventListener("keydown", playMusicOnClick, {
                once: true,
            });
        });
    } else {
        console.warn("Login music audio element not found.");
    }
}
function stopLoginScreenVisualsAndMusic() {
    if (loginAnimationId) {
        cancelAnimationFrame(loginAnimationId);
        loginAnimationId = null;
    }
    const music = document.getElementById("login-music");
    if (music) {
        music.pause();
        music.currentTime = 0;
    }
    window.removeEventListener("resize", handleLoginResize);
}
function handleLoginResize() {
    if (loginBgCanvas) {
        loginBgCanvas.width = window.innerWidth;
        loginBgCanvas.height = window.innerHeight;
        createStars();
    }
}
function initLoginScreenVisuals() {
    loginBgCanvas = document.getElementById("login-background-canvas");
    if (!loginBgCanvas) {
        console.error("Login background canvas not found!");
        return;
    }
    loginBgCtx = loginBgCanvas.getContext("2d");
    handleLoginResize();
    animateLoginBackground.lastTime = performance.now();
    animateLoginBackground();
    setupLoginMusic();
    window.addEventListener("resize", handleLoginResize);
}
// --- END DYNAMIC LOGIN BACKGROUND & MUSIC ---

// --- FULLSCREEN GAMEPLAY SETUP ---
function setupGameCanvasFullscreen() {
    const canvas = document.getElementById("gameCanvas");
    if (!canvas) {
        console.error("Game canvas not found for fullscreen setup!");
        return;
    }
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gameState.camera.width = canvas.width; // Update camera state
        gameState.camera.height = canvas.height;

        if (Renderer.isInitialized()) {
            Renderer.updateViewPort(canvas.width, canvas.height);
        }
        console.log(`Game canvas resized to: ${canvas.width}x${canvas.height}`);
    }
    window.addEventListener("resize", resizeCanvas, false);
    resizeCanvas(); // Initial resize
}
// --- END FULLSCREEN GAMEPLAY SETUP ---

async function loadImages(imagePaths) {
    console.log("main.js/loadImages function called with paths:", imagePaths);
    const imagePromises = imagePaths.map((path) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const filename = path.substring(path.lastIndexOf("/") + 1);
                gameState.loadedImages[filename] = img;
                resolve(img);
            };
            img.onerror = (err) => {
                console.error(`Failed to load image: ${path}`, err);
                reject(new Error(`Failed to load image: ${path}`));
            };
            img.src = path;
        });
    });

    try {
        await Promise.all(imagePromises);
        console.log(
            "main.js/loadImages: All images to be loaded have been processed.",
        );
    } catch (error) {
        console.error(
            "main.js/loadImages: Error during image loading process:",
            error,
        );
    }
}

async function handleLoginSubmit(username, password) {
    console.log(`main.js/handleLoginSubmit called for user: ${username}`);
    const loginErrorEl = document.getElementById("login-error");
    const loginMessageEl = document.getElementById("login-message");
    loginErrorEl.textContent = "";
    loginMessageEl.textContent = "";

    try {
        const response = await fetch("/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password }),
        });
        const result = await response.json();
        console.log("main.js/handleLoginSubmit: Login API response:", result);

        if (response.ok && result.success) {
            loginMessageEl.textContent = result.message || "Success!";
            gameState.currentUser = { username: result.username };

            stopLoginScreenVisualsAndMusic();

            document.getElementById("login-screen").classList.add("hidden");
            const gameContainer = document.getElementById("game-container");
            gameContainer.classList.remove("hidden");

            setupGameCanvasFullscreen(); // <<<<<<< SETUP FULLSCREEN GAME CANVAS HERE

            initNetwork(async () => {
                console.log(
                    "main.js/onReadyCallback (from initNetwork): START.",
                );

                // Collect all image paths including system backgrounds
                const systemBackgroundPaths = gameState.clientGameData.systems
                    .filter((sys) => sys.backgroundFile) // Make sure backgroundFile exists
                    .map(
                        (sys) =>
                            `assets/images/backgrounds/${sys.backgroundFile}`,
                    );

                const allImagePaths = [
                    ...new Set([
                        ...gameState.imagePathsToLoad,
                        ...systemBackgroundPaths,
                    ]),
                ];
                // gameState.imagePathsToLoad = allImagePaths; // Update master list if needed elsewhere

                if (allImagePaths.length > 0) {
                    await loadImages(allImagePaths);
                    console.log(
                        "main.js/onReadyCallback: Image loading process complete for all images.",
                    );
                } else {
                    console.log("main.js/onReadyCallback: No images to load.");
                }

                await loadProgress();

                if (gameState.myId && !gameState.myShip) {
                    gameState.allShips[gameState.myId] =
                        gameState.allShips[gameState.myId] || {};
                    gameState.defaultShipProps(gameState.myShip);
                } else if (
                    gameState.myId &&
                    gameState.myShip &&
                    (gameState.myShip.type === undefined ||
                        gameState.myShip.type === null)
                ) {
                    gameState.defaultShipProps(gameState.myShip);
                }

                const canvas = document.getElementById("gameCanvas");
                if (canvas) canvas.focus();

                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            });
        } else {
            loginErrorEl.textContent =
                result.message || "Login/Registration failed.";
        }
    } catch (error) {
        console.error(
            "main.js/handleLoginSubmit: Login request fetch failed:",
            error,
        );
        loginErrorEl.textContent = "Login request error. Check console.";
    }
}

async function loadProgress() {
    console.log("main.js/loadProgress: Function called.");
    if (!gameState.currentUser || !gameState.currentUser.username) {
        console.log(
            "main.js/loadProgress: No current user or username, returning.",
        );
        return;
    }
    try {
        const response = await fetch(
            `/load-progress?username=${gameState.currentUser.username}`,
        );
        if (response.ok) {
            const progress = await response.json();
            if (progress && progress.shipData) {
                if (gameState.myId) {
                    if (!gameState.allShips[gameState.myId]) {
                        gameState.allShips[gameState.myId] = {};
                    }
                    gameState.updateShipData(gameState.myId, progress.shipData);
                    const syncData = {
                        credits: progress.shipData.credits,
                        cargo: progress.shipData.cargo,
                        weapons: progress.shipData.weapons,
                        activeWeapon: progress.shipData.activeWeapon,
                        health: progress.shipData.health,
                        type: progress.shipData.type,
                        activeMissions: progress.shipData.activeMissions || [],
                    };
                    if (progress.dockedAtDetails) {
                        gameState.docked = true;
                        gameState.dockedAtDetails = progress.dockedAtDetails;
                        syncData.dockedAtDetails = gameState.dockedAtDetails;
                    } else {
                        gameState.docked = false;
                        gameState.dockedAtDetails = null;
                        syncData.dockedAtDetails = null;
                        syncData.x = progress.shipData.x;
                        syncData.y = progress.shipData.y;
                        syncData.angle = progress.shipData.angle;
                        syncData.vx = progress.shipData.vx;
                        syncData.vy = progress.shipData.vy;
                        syncData.system = progress.shipData.system;
                    }
                    if (gameState.socket) {
                        gameState.socket.emit(
                            "clientLoadedDockedState",
                            syncData,
                        );
                    }
                } else {
                    gameState.pendingProgressToApply = progress;
                }
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
            }
        } else {
            gameState.docked = false;
            gameState.dockedAtDetails = null;
        }
    } catch (error) {
        console.error(
            "main.js/loadProgress: Error during fetch/processing in loadProgress:",
            error,
        );
        gameState.docked = false;
        gameState.dockedAtDetails = null;
    }
}

document.addEventListener("DOMContentLoaded", () => {
    console.log("main.js/DOMContentLoaded event fired");

    const loginScreenElement = document.getElementById("login-screen");
    if (
        loginScreenElement &&
        !loginScreenElement.classList.contains("hidden")
    ) {
        initLoginScreenVisuals();
    }

    const canvas = document.getElementById("gameCanvas");
    const uiContainer = document.getElementById("ui");
    const gameContainer = document.getElementById("game-container");

    if (!canvas || !uiContainer || !gameContainer) {
        console.error(
            "main.js/DOMContentLoaded: Required HTML elements not found!",
        );
        return;
    }
    if (canvas) {
        if (!canvas.hasAttribute("tabindex")) {
            canvas.setAttribute("tabindex", "0");
        }
    }

    Renderer.init(canvas);
    UIManager.init(uiContainer);
    initInputListeners(canvas);

    const loginForm = document.getElementById("login-form");
    if (loginForm) {
        loginForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            const usernameInput = document.getElementById("username");
            const passwordInput = document.getElementById("password");
            if (usernameInput && passwordInput) {
                await handleLoginSubmit(
                    usernameInput.value,
                    passwordInput.value,
                );
            }
        });
    }
});

let gameLoopFrameCount = 0;
let lastTime = 0;

function gameLoop(timestamp) {
    gameLoopFrameCount++;
    lastTime = timestamp;

    // const canvas = document.getElementById("gameCanvas"); // Not needed here directly

    if (gameState.currentUser && gameState.myId && gameState.myShip) {
        // Update camera to follow player
        if (gameState.myShip) {
            // Simple direct centering
            gameState.camera.x =
                gameState.myShip.x - gameState.camera.width / 2;
            gameState.camera.y =
                gameState.myShip.y - gameState.camera.height / 2;

            // Optional: Smooth camera movement (lerp)
            // const targetX = gameState.myShip.x - gameState.camera.width / 2;
            // const targetY = gameState.myShip.y - gameState.camera.height / 2;
            // gameState.camera.x += (targetX - gameState.camera.x) * gameState.camera.lerpFactor;
            // gameState.camera.y += (targetY - gameState.camera.y) * gameState.camera.lerpFactor;
        }

        if (!gameState.docked) {
            processInputs(); // Canvas argument no longer needed as it refers to gameState.camera
        }
        Renderer.draw();
    }
    requestAnimationFrame(gameLoop);
}

/* ===== END: hypernova/client/js/main.js ===== */


/* ===== START: hypernova/client/js/network.js ===== */
// hypernova/client/js/network.js
import { gameState } from "./game_state.js";
import { UIManager } from "./ui_manager.js";
import { HYPERJUMP_DENIED_MESSAGE_DURATION_MS } from "./client_config.js";

// NEW: Function to save progress to the server
export async function saveProgress() {
    // Make it async
    if (!gameState.socket || !gameState.myShip || !gameState.currentUser) {
        console.warn(
            "saveProgress: Cannot save - No socket, ship, or user data.",
        );
        console.warn(
            `saveProgress details: socket: ${!!gameState.socket}, myShip: ${!!gameState.myShip}, currentUser: ${!!gameState.currentUser}`,
        );
        return;
    }

    // Add a specific log here
    console.log(
        `saveProgress: Preparing data. Current gameState.docked: ${gameState.docked}, dockedAtDetails being saved: ${JSON.stringify(gameState.docked ? gameState.dockedAtDetails : null)}`,
    );

    // Prepare the data to be saved
    const progressData = {
        username: gameState.currentUser.username,
        shipData: {
            x: gameState.myShip.x,
            y: gameState.myShip.y,
            angle: gameState.myShip.angle,
            vx: gameState.myShip.vx,
            vy: gameState.myShip.vy,
            type: gameState.myShip.type, // This is likely an index
            credits: gameState.myShip.credits,
            cargo: gameState.myShip.cargo, // Array of numbers
            maxCargo: gameState.myShip.maxCargo,
            health: gameState.myShip.health,
            maxHealth: gameState.myShip.maxHealth,
            weapons: gameState.myShip.weapons, // Array of weapon names/IDs
            activeWeapon: gameState.myShip.activeWeapon, // Name/ID of active weapon
            system: gameState.myShip.system, // Current system index
            activeMissions: gameState.myShip.activeMissions, // Array of mission objects/IDs
            // dockedAtPlanetIdentifier is handled by saving `dockedAtDetails` if docked
        },
        dockedAtDetails: gameState.docked ? gameState.dockedAtDetails : null,
    };

    try {
        const response = await fetch("/save-progress", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(progressData),
        });
        const result = await response.json();
        if (response.ok && result.success) {
            console.log("saveProgress: Progress saved successfully to server.");
        } else {
            console.error(
                "saveProgress: Failed to save progress to server:",
                result.message || "Server error",
            );
        }
    } catch (error) {
        console.error(
            "saveProgress: Error during fetch to save progress:",
            error,
        );
    }
}

export function initNetwork(onReadyCallback) {
    const socket = io();
    gameState.socket = socket;

    socket.on("init", (data) => {
        console.log(
            "network.js/init: Received init data:",
            JSON.stringify(data),
        ); // Log full init data
        if (!data || !data.id || !data.gameData) {
            console.error(
                "network.js/init: Incomplete init data received from server.",
            );
            return;
        }
        gameState.myId = data.id;
        console.log("network.js/init: Set gameState.myId to:", gameState.myId);

        // Populate clientGameData from server (user's existing logic)
        gameState.clientGameData.systems = data.gameData.systems || [];
        gameState.clientGameData.tradeGoods = data.gameData.tradeGoods || [];
        gameState.clientGameData.weapons = data.gameData.weapons || {};
        gameState.clientGameData.shipTypes = data.gameData.shipTypes || [];
        gameState.clientGameData.MISSION_TYPES =
            data.gameData.MISSION_TYPES || {};
        gameState.clientPlanetEconomies = data.gameData.economies || [];

        // Collect image paths to load (user's existing logic)
        const uniqueImageFiles = new Set();
        if (gameState.clientGameData.systems) {
            gameState.clientGameData.systems.forEach((system) => {
                if (system.planets) {
                    system.planets.forEach((planet) => {
                        if (planet.imageFile) {
                            uniqueImageFiles.add(
                                `assets/images/${planet.imageFile}`,
                            );
                        }
                    });
                }
            });
        }
        if (gameState.clientGameData.shipTypes) {
            gameState.clientGameData.shipTypes.forEach((shipType) => {
                if (shipType.imageFile) {
                    uniqueImageFiles.add(`assets/images/${shipType.imageFile}`);
                }
            });
        }
        gameState.imagePathsToLoad = Array.from(uniqueImageFiles);
        // console.log("network.js/init: Image paths to load:", gameState.imagePathsToLoad);

        if (data.ships) {
            for (const shipId in data.ships) {
                console.log(
                    "network.js/init: Processing ship from server init data for shipId:",
                    shipId,
                );
                gameState.updateShipData(shipId, data.ships[shipId]); // updateShipData calls defaultShipProps
            }
        }
        console.log(
            "network.js/init: After processing server ships. Current myShip:",
            JSON.stringify(gameState.myShip),
            "Current gameState.docked:",
            gameState.docked,
        );

        if (gameState.pendingProgressToApply && gameState.myId) {
            console.log(
                "network.js/init: Applying pendingProgressToApply. Current gameState.docked BEFORE apply:",
                gameState.docked,
                "Pending progress:",
                JSON.stringify(gameState.pendingProgressToApply),
            );
            const pendingProgress = gameState.pendingProgressToApply;

            gameState.updateShipData(
                // This will call defaultShipProps
                gameState.myId,
                pendingProgress.shipData,
            );
            console.log(
                "network.js/init (pending): After updateShipData. myShip:",
                JSON.stringify(gameState.myShip),
            );

            if (
                gameState.myShip && // Ensure myShip exists after updateShipData
                pendingProgress.shipData.system !== undefined
            ) {
                gameState.myShip.system = pendingProgress.shipData.system;
                console.log(
                    "network.js/init (pending): Set gameState.myShip.system to",
                    gameState.myShip.system,
                );
            }

            if (pendingProgress.dockedAtDetails) {
                gameState.docked = true;
                gameState.dockedAtDetails = pendingProgress.dockedAtDetails;
                console.log(
                    "network.js/init (pending): SETTING gameState.docked = true, details:",
                    JSON.stringify(gameState.dockedAtDetails),
                );
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
                console.log(
                    "network.js/init (pending): SETTING gameState.docked = false (no dockedAtDetails in pending progress)",
                );
            }
            console.log(
                "network.js/init: Applied pendingProgressToApply. gameState.docked is now:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
            delete gameState.pendingProgressToApply;
        } else if (gameState.myShip) {
            // This branch means: myId is set, myShip exists (likely from server's data.ships), and there was NO pendingProgressToApply.
            // defaultShipProps would have been called via updateShipData when data.ships was processed.
            console.log(
                "network.js/init: (No pending progress, myShip exists). gameState.docked:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
        } else if (gameState.myId) {
            // This branch means: myId is set, but myShip was NOT in data.ships and NO pendingProgressToApply.
            // This implies a new ship situation or a ship not yet created on the server but client knows its ID.
            console.log(
                "network.js/init: (No pending progress, myShip DID NOT exist). Creating and applying defaults for myId:",
                gameState.myId,
                "Current gameState.docked:",
                gameState.docked,
            );
            gameState.allShips[gameState.myId] = {}; // Create the ship object.
            gameState.defaultShipProps(gameState.myShip); // Apply default properties.
            console.log(
                "network.js/init: (New ship scenario) Created and applied defaults. gameState.docked:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
        }

        console.log(
            "network.js/init: Client initialization sequence in 'init' handler complete. Final My ship:",
            JSON.stringify(gameState.myShip),
            "Final gameState.docked:",
            gameState.docked,
        );
        if (onReadyCallback) {
            console.log("network.js/init: Calling onReadyCallback.");
            onReadyCallback();
        }
    });

    socket.on("state", (updatedShipDataMap) => {
        // console.log("network.js/state: Received state update:", updatedShipDataMap);
        for (const id in updatedShipDataMap) {
            const update = updatedShipDataMap[id];
            // If this state update includes hyperjump state changes from server, reflect them
            if (id === gameState.myId) {
                if (
                    update.hyperjumpState === "idle" &&
                    gameState.isChargingHyperjump
                ) {
                    // Server says we are idle, but client thought it was charging (e.g. cancellation)
                    gameState.isChargingHyperjump = false;
                    gameState.hyperjumpChargeStartTime = null;
                }
                // Potentially other hyperjump state fields if server sends them in general state updates
            }
            gameState.updateShipData(id, update);
        }
        if (
            gameState.myShip &&
            gameState.myShip.dockedAtPlanetIdentifier === null &&
            gameState.docked
        ) {
            console.log(
                "network.js/state: Server state indicates ship is not docked, but client gameState.docked was true. Cleaning up UI.",
            );
            UIManager.undockCleanup();
        }
    });

    socket.on("playerJoined", (data) => {
        console.log("network.js/playerJoined:", data.id);
        gameState.updateShipData(data.id, data.ship);
    });

    socket.on("playerLeft", (id) => {
        console.log("network.js/playerLeft:", id);
        delete gameState.allShips[id];
    });

    socket.on("projectile", (data) => {
        data.time = Date.now();
        gameState.projectiles.push(data);
    });

    socket.on("dockConfirmed", (data) => {
        console.log(
            "network.js/dockConfirmed: Received data:",
            JSON.stringify(data),
        );
        gameState.docked = true;
        if (gameState.myShip) {
            gameState.myShip.dockedAtPlanetIdentifier = {
                systemIndex: data.systemIndex,
                planetIndex: data.planetIndex,
            };
            // Server is authoritative for position upon docking
            gameState.myShip.x = data.playerX;
            gameState.myShip.y = data.playerY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
        }
        gameState.dockedAtDetails = { ...data };
        console.log(
            "network.js/dockConfirmed: Set gameState.docked = true. dockedAtDetails:",
            JSON.stringify(gameState.dockedAtDetails),
            "myShip.dockedAtPlanetIdentifier:",
            gameState.myShip
                ? JSON.stringify(gameState.myShip.dockedAtPlanetIdentifier)
                : "N/A",
        );
        UIManager.openDockMenu();
        console.log("network.js/dockConfirmed: Calling saveProgress().");
        saveProgress();
    });

    socket.on("undockConfirmed", () => {
        console.log(
            "network.js/undockConfirmed: Received from server. Current gameState.docked BEFORE UIManager.undockCleanup:",
            gameState.docked,
        );
        UIManager.undockCleanup();
        console.log(
            "network.js/undockConfirmed: AFTER UIManager.undockCleanup. gameState.docked:",
            gameState.docked,
        );
    });

    socket.on("tradeError", ({ message }) => {
        console.error("network.js/tradeError:", message);
        alert(`Trade Error: ${message}`);
    });
    socket.on("actionFailed", ({ message }) => {
        console.warn("network.js/actionFailed:", message);
        alert(`Action Failed: ${message}`);
    });
    socket.on("actionSuccess", ({ message }) => {
        console.log("network.js/actionSuccess:", message);
    });

    socket.on("tradeSuccess", (data) => {
        // ... (existing tradeSuccess logic) ...
    });
    socket.on("updatePlanetEconomies", (updatedSystemsEconomies) => {
        // ... (existing updatePlanetEconomies logic) ...
    });
    socket.on("planetEconomyUpdate", (data) => {
        // ... (existing planetEconomyUpdate logic) ...
    });
    socket.on("availableMissionsList", (data) => {
        // ... (existing availableMissionsList logic) ...
    });
    socket.on("missionAccepted", (data) => {
        // ... (existing missionAccepted logic) ...
    });
    socket.on("missionUpdate", (data) => {
        // ... (existing missionUpdate logic) ...
    });

    // Hyperjump related handlers
    socket.on("hyperjumpChargeStarted", ({ chargeTime }) => {
        console.log("Network: Hyperjump charge started by server.");
        gameState.isChargingHyperjump = true;
        gameState.hyperjumpChargeStartTime = Date.now();
        // Client will use its own HYPERJUMP_CHARGE_TIME_MS for progress bar,
        // but server's chargeTime could be used if they differ.
    });

    socket.on("hyperjumpDenied", ({ message }) => {
        console.warn("Network: Hyperjump denied by server:", message);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        gameState.hyperjumpDeniedMessage = message;
        if (gameState.hyperjumpDeniedMessageTimeoutId) {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        }
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
    });

    socket.on("hyperjumpCancelled", ({ message }) => {
        console.log("Network: Hyperjump cancelled by server:", message);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        if (message) {
            gameState.hyperjumpDeniedMessage = message; // Re-use denied message display
            if (gameState.hyperjumpDeniedMessageTimeoutId) {
                clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            }
            gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                gameState.hyperjumpDeniedMessage = null;
                gameState.hyperjumpDeniedMessageTimeoutId = null;
            }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        }
    });

    socket.on("hyperjumpComplete", (data) => {
        console.log("Network: Hyperjump complete. New state:", data);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;

        if (gameState.myShip) {
            gameState.myShip.system = data.newSystem;
            gameState.myShip.x = data.newX;
            gameState.myShip.y = data.newY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
            gameState.myShip.angle =
                data.newAngle !== undefined ? data.newAngle : 0;
            gameState.myShip.dockedAtPlanetIdentifier = null;
        }
        gameState.docked = false;
        UIManager.undockCleanup();
        // Client is now in the new system, position set by server.
        // The regular 'state' update from server will also reflect this for other players.
    });
}

export function sendControls() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        (gameState.myShip && gameState.myShip.destroyed)
    ) {
        return;
    }
    // Data sent in 'control' reflects current client state, including drift during hyperjump charge.
    // Server will decide how to use this data if player is charging.
    gameState.socket.emit("control", {
        x: gameState.myShip.x,
        y: gameState.myShip.y,
        angle: gameState.myShip.angle,
        vx: gameState.myShip.vx,
        vy: gameState.myShip.vy,
        system: gameState.myShip.system, // Keep sending current system; server manages actual jump
    });
}

export function fireWeapon() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        !gameState.myShip.activeWeapon ||
        gameState.docked ||
        gameState.isChargingHyperjump // Prevent firing if charging
    ) {
        console.warn(
            "fireWeapon: Pre-condition failed (e.g., charging hyperjump).",
        );
        return;
    }
    console.log("fireWeapon: Emitting 'fire'.");
    gameState.socket.emit("fire");
}

export function equipWeapon(weaponName) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        // Prevent equipping if charging
        if (gameState.isChargingHyperjump)
            console.warn("equipWeapon: Cannot equip while charging hyperjump.");
        return;
    }
    console.log(`equipWeapon called with: ${weaponName}.`);
    gameState.socket.emit("equipWeapon", { weapon: weaponName });
}

export function requestDock(systemIndex, planetIndex) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        // Prevent docking if charging
        if (gameState.isChargingHyperjump)
            console.warn("requestDock: Cannot dock while charging hyperjump.");
        return;
    }
    console.log(
        `requestDock called for system ${systemIndex}, planet ${planetIndex}.`,
    );
    gameState.socket.emit("dock", { systemIndex, planetIndex });
}

export function undock() {
    // Undocking while charging hyperjump should not be possible as player should not be docked.
    // If somehow state is inconsistent, this is a regular undock request.
    if (!gameState.socket || !gameState.docked) {
        console.warn(
            `undock: Pre-condition failed. Socket: ${!!gameState.socket}, gameState.docked: ${gameState.docked}.`,
        );
        return;
    }
    console.log("undock: Emitting 'undock' to server.");
    gameState.socket.emit("undock");
    saveProgress();
}

export function buyGood(goodIndex) {
    // ... (existing buyGood, no direct hyperjump interaction needed as it requires docking) ...
}
export function sellGood(goodIndex) {
    // ... (existing sellGood) ...
}
export function buyShip(shipTypeIndex) {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.isChargingHyperjump
    ) {
        // Prevent buying ship if charging
        if (gameState.isChargingHyperjump)
            console.warn("buyShip: Cannot buy ship while charging hyperjump.");
        return;
    }
    // ... rest of buyShip logic ...
}

export function requestMissions(systemIndex, planetIndex) {
    // ... (existing requestMissions) ...
}
export function acceptMission(missionId, systemIndex, planetIndex) {
    // ... (existing acceptMission) ...
}

// New function for hyperjump request
export function requestHyperjump() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.docked ||
        gameState.isChargingHyperjump
    ) {
        let reason = "Pre-condition failed";
        if (gameState.docked) reason = "docked";
        if (gameState.isChargingHyperjump) reason = "already charging";
        if (gameState.myShip?.destroyed) reason = "ship destroyed";
        console.warn(`requestHyperjump: Cannot request. Reason: ${reason}`);
        return;
    }
    console.log("network.js: Emitting 'requestHyperjump'.");
    gameState.socket.emit("requestHyperjump");
}

// Optional: if client-side cancellation is desired
export function cancelHyperjumpRequest() {
    if (!gameState.socket || !gameState.isChargingHyperjump) return;
    console.log("network.js: Emitting 'cancelHyperjump'.");
    gameState.socket.emit("cancelHyperjump");
    // Client optimistically stops visual charging, server confirms actual cancellation.
    // gameState.isChargingHyperjump = false; // Let server message handle this state change fully
    // gameState.hyperjumpChargeStartTime = null;
}

/* ===== END: hypernova/client/js/network.js ===== */


/* ===== START: hypernova/client/js/renderer.js ===== */
// hypernova/client/js/renderer.js
import { gameState } from "./game_state.js";
import {
    PROJECTILE_LIFESPAN_MS,
    DOCKING_DISTANCE_SQUARED,
    HYPERJUMP_CHARGE_TIME_MS,
} from "./client_config.js";

let ctx = null;
let canvas = null;
let initialized = false;

// Parallax background properties
const PARALLAX_LAYERS = [
    {
        speed: 0.05,
        stars: [],
        starDensity: 0.000015,
        minStarSize: 0.2,
        maxStarSize: 0.7,
        opacity: 0.4,
    }, // Deepest, slowest
    {
        speed: 0.15,
        stars: [],
        starDensity: 0.00003,
        minStarSize: 0.4,
        maxStarSize: 1.0,
        opacity: 0.6,
    },
    {
        speed: 0.35,
        stars: [],
        starDensity: 0.00005,
        minStarSize: 0.6,
        maxStarSize: 1.5,
        opacity: 0.8,
    },
];
let lastCameraX = 0;
let lastCameraY = 0;

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}

function generateParallaxStars() {
    if (!canvas) return; // Ensure canvas is available
    PARALLAX_LAYERS.forEach((layer) => {
        layer.stars = [];
        const numStars = Math.floor(
            canvas.width * canvas.height * layer.starDensity,
        );
        for (let i = 0; i < numStars; i++) {
            layer.stars.push({
                // Store initial positions relative to a large world, not just screen
                // For simplicity here, still using canvas width/height but imagine this as a section of a larger field
                x: Math.random() * canvas.width * 3 - canvas.width, // Spread stars over a wider initial area
                y: Math.random() * canvas.height * 3 - canvas.height,
                radius: getRandom(layer.minStarSize, layer.maxStarSize),
                opacity: getRandom(layer.opacity * 0.5, layer.opacity),
            });
        }
    });
}

export const Renderer = {
    init(canvasElement) {
        canvas = canvasElement;
        ctx = canvas.getContext("2d");
        // Fullscreen setup is handled in main.js, which also updates gameState.camera.width/height
        gameState.camera.width = canvas.width;
        gameState.camera.height = canvas.height;
        generateParallaxStars();
        lastCameraX = gameState.camera.x;
        lastCameraY = gameState.camera.y;
        initialized = true;
        console.log(
            "Renderer initialized with canvas:",
            canvas.width,
            "x",
            canvas.height,
        );
    },

    isInitialized() {
        return initialized;
    },

    updateViewPort(width, height) {
        if (canvas) {
            // canvas.width and height are already set by main.js's resizeCanvas
        }
        // gameState.camera.width and height are also set by main.js's resizeCanvas
        generateParallaxStars();
        console.log(
            "Renderer viewport updated via main.js:",
            width,
            "x",
            height,
        );
    },

    drawSystemBackground() {
        if (!gameState.myShip || gameState.myShip.system === undefined) {
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        const systemData =
            gameState.clientGameData.systems[gameState.myShip.system];
        if (systemData && systemData.backgroundFile) {
            const bgImg = gameState.loadedImages[systemData.backgroundFile];
            if (bgImg) {
                const camX = gameState.camera.x;
                const camY = gameState.camera.y;
                const parallaxFactor = 0.1; // Slowest layer for main background image

                const imgWidth = bgImg.width;
                const imgHeight = bgImg.height;

                // Calculate the starting tile based on camera position
                // This ensures we only draw visible tiles + one extra for smooth scrolling
                const startX =
                    Math.floor((camX * parallaxFactor) / imgWidth) * imgWidth;
                const startY =
                    Math.floor((camY * parallaxFactor) / imgHeight) * imgHeight;

                ctx.save();
                // Translate context by the inverse of the parallax-affected camera position
                ctx.translate(
                    -(camX * parallaxFactor),
                    -(camY * parallaxFactor),
                );

                for (
                    let x = startX - imgWidth;
                    x <
                    startX + canvas.width / (1 - parallaxFactor) + imgWidth * 2;
                    x += imgWidth
                ) {
                    for (
                        let y = startY - imgHeight;
                        y <
                        startY +
                            canvas.height / (1 - parallaxFactor) +
                            imgHeight * 2;
                        y += imgHeight
                    ) {
                        ctx.drawImage(bgImg, x, y, imgWidth, imgHeight);
                    }
                }
                ctx.restore();
            } else {
                ctx.fillStyle = systemData.fallbackColor || "#010205";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        this.drawParallaxStars();
    },

    drawParallaxStars() {
        const camX = gameState.camera.x;
        const camY = gameState.camera.y;

        PARALLAX_LAYERS.forEach((layer) => {
            ctx.beginPath(); // Start a new path for each layer for performance
            layer.stars.forEach((star) => {
                // Calculate star's apparent position on screen
                // The star's own (x,y) are its "world" coordinates for that layer
                // We offset by camera movement scaled by parallax speed
                const screenX = (star.x - camX * layer.speed) % canvas.width;
                const screenY = (star.y - camY * layer.speed) % canvas.height;

                // Adjust for negative modulo results to keep it within canvas bounds
                const finalX = screenX < 0 ? screenX + canvas.width : screenX;
                const finalY = screenY < 0 ? screenY + canvas.height : screenY;

                ctx.moveTo(finalX + star.radius, finalY); // moveTo before arc for batching
                ctx.arc(finalX, finalY, star.radius, 0, Math.PI * 2);
            });
            ctx.fillStyle = `rgba(255, 255, 240, layer.opacity)`; // Use layer's base opacity
            ctx.fill();
        });
    },

    draw() {
        if (!ctx || !initialized) return;
        if (!gameState.myShip) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }

        this.drawSystemBackground();

        ctx.save();
        ctx.translate(-gameState.camera.x, -gameState.camera.y);

        if (gameState.myShip.system !== undefined) {
            const currentSystemData =
                gameState.clientGameData.systems[gameState.myShip.system];
            if (currentSystemData && currentSystemData.planets) {
                currentSystemData.planets.forEach((p) => this.drawPlanet(p));
            }

            const now = Date.now();
            gameState.projectiles = gameState.projectiles.filter(
                (p) => now - (p.time || 0) < PROJECTILE_LIFESPAN_MS,
            );
            gameState.projectiles.forEach((p) => this.drawProjectile(p));

            for (const id in gameState.allShips) {
                const ship = gameState.allShips[id];
                if (!ship || ship.system !== gameState.myShip.system) continue;
                this.drawShip(ship);

                if (
                    id !== gameState.myId &&
                    !ship.destroyed &&
                    ship.type !== undefined
                ) {
                    const shipDef =
                        gameState.clientGameData.shipTypes[ship.type];
                    const shipRenderScale = shipDef.scale || 1.0;
                    const labelOffset =
                        shipDef && shipDef.imgHeight
                            ? (shipDef.imgHeight / 2) * shipRenderScale + 10
                            : 25;
                    ctx.fillStyle = ship.color || "#0f0";
                    ctx.font = "12px monospace";
                    ctx.textAlign = "center";
                    const displayName = ship.username || id.substring(0, 6); // Prefer username
                    ctx.fillText(displayName, ship.x, ship.y - labelOffset);
                    ctx.textAlign = "left";
                }
            }
        }
        ctx.restore();
        this.drawHUD();
    },

    drawPlanet(planet) {
        const img = gameState.loadedImages[planet.imageFile];
        // Define a base render size for planets, then scale it.
        // This base size should correspond to how large a 1.0 scale planet image is intended to be.
        const BASE_PLANET_RENDER_SIZE = 128; // e.g., if your planet_hires.png are designed for this size at scale 1
        const scale = planet.planetImageScale || 1.0;
        const renderSize = BASE_PLANET_RENDER_SIZE * scale;

        if (img) {
            ctx.save();
            ctx.drawImage(
                img,
                planet.x - renderSize / 2,
                planet.y - renderSize / 2,
                renderSize,
                renderSize,
            );

            ctx.globalCompositeOperation = "lighter";
            const glowRadius = renderSize * 0.65;
            const gradient = ctx.createRadialGradient(
                planet.x,
                planet.y,
                renderSize * 0.48,
                planet.x,
                planet.y,
                glowRadius,
            );
            gradient.addColorStop(0, `rgba(120, 170, 255, 0.25)`);
            gradient.addColorStop(0.7, `rgba(120, 170, 255, 0.1)`);
            gradient.addColorStop(1, `rgba(120, 170, 255, 0)`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = "source-over";

            ctx.restore();
        } else {
            ctx.fillStyle = planet.fallbackColor || "#335577"; // Darker blue/grey fallback
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, renderSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = "#E0E8FF"; // Light, slightly bluish white for planet names
        ctx.font = `${Math.max(10, 12 * scale)}px monospace`; // Ensure font not too small
        ctx.textAlign = "center";
        ctx.shadowColor = "black"; // Text shadow for readability
        ctx.shadowBlur = 2;
        ctx.fillText(
            planet.name,
            planet.x,
            planet.y + renderSize / 2 + Math.max(12, 15 * scale),
        );
        ctx.shadowBlur = 0; // Reset shadow
        ctx.textAlign = "left";
    },

    drawShip(ship) {
        /* ... (drawShip from previous, ensure scale is used if defined) ... */
        if (ship.destroyed || ship.type === undefined) return;
        const shipTypeDefinition =
            gameState.clientGameData.shipTypes[ship.type];
        if (!shipTypeDefinition) return;

        const img = gameState.loadedImages[shipTypeDefinition.imageFile];
        const shipScale = shipTypeDefinition.scale || 1.0;

        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        if (img) {
            const w = (shipTypeDefinition.imgWidth || img.width) * shipScale;
            const h = (shipTypeDefinition.imgHeight || img.height) * shipScale;
            ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
            ctx.fillStyle = ship.color || "#0f0";
            ctx.beginPath();
            ctx.moveTo(15 * shipScale, 0);
            ctx.lineTo(-10 * shipScale, 8 * shipScale);
            ctx.lineTo(-10 * shipScale, -8 * shipScale);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    },

    drawProjectile(p) {
        /* ... (drawProjectile from previous with glow) ... */
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(p.range / 4, 0);
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 5;
        ctx.stroke();
        ctx.restore();
    },

    drawHUD() {
        /* ... (HUD drawing from previous) ... */
        ctx.font = "14px monospace";
        ctx.fillStyle = "#00FF00";

        if (
            gameState.hyperjumpDeniedMessage &&
            !gameState.isChargingHyperjump
        ) {
            ctx.fillStyle = "red";
            ctx.font = "16px monospace";
            const messageWidth = ctx.measureText(
                gameState.hyperjumpDeniedMessage,
            ).width;
            ctx.fillText(
                gameState.hyperjumpDeniedMessage,
                canvas.width / 2 - messageWidth / 2,
                canvas.height - 60,
            );
            ctx.fillStyle = "#00FF00";
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            ctx.fillStyle = "red";
            ctx.font = "24px monospace";
            const msg = "SHIP DESTROYED - AWAITING RESPAWN";
            ctx.textAlign = "center";
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = "left";
            return;
        }

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return;

        let cargoCount =
            myShip.cargo && myShip.cargo.length > 0
                ? myShip.cargo.reduce((s, v) => s + v, 0)
                : 0;

        const hudPadding = 15;
        ctx.textAlign = "left";
        ctx.fillText(
            `Pilot: ${gameState.currentUser.username}`,
            hudPadding,
            hudPadding + 14,
        );
        ctx.fillText(
            `Credits: $${myShip.credits}`,
            hudPadding,
            hudPadding + 32,
        );
        ctx.fillText(
            `Health: ${myShip.health || 0}/${myShip.maxHealth || 0}`,
            hudPadding,
            hudPadding + 50,
        );
        ctx.fillText(
            `Cargo: ${cargoCount}/${currentShipDef.maxCargo}`,
            hudPadding,
            hudPadding + 68,
        );

        const systemName =
            gameState.clientGameData.systems[myShip.system]?.name ||
            "Unknown System";
        ctx.fillText(`System: ${systemName}`, hudPadding, hudPadding + 86);

        if (myShip.activeWeapon) {
            const weaponDisplayName =
                gameState.clientGameData.weapons[myShip.activeWeapon]?.name ||
                myShip.activeWeapon;
            ctx.fillText(
                `Weapon: ${weaponDisplayName}`,
                hudPadding,
                hudPadding + 104,
            );
        }

        let hudNextY = hudPadding + 138;
        if (myShip.activeMissions && myShip.activeMissions.length > 0) {
            ctx.fillText("Active Missions:", hudPadding, hudNextY);
            hudNextY += 18;
            myShip.activeMissions.slice(0, 3).forEach((mission) => {
                let missionText =
                    mission.title.length > 40
                        ? mission.title.substring(0, 37) + "..."
                        : mission.title;
                if (
                    mission.type ===
                    gameState.clientGameData.MISSION_TYPES.BOUNTY
                ) {
                    missionText += ` (${mission.targetsDestroyed || 0}/${mission.targetsRequired})`;
                }
                const timeRemainingMin = Math.max(
                    0,
                    Math.round((mission.timeLimit - Date.now()) / 60000),
                );
                missionText += ` (${timeRemainingMin}m)`;
                ctx.fillText(`- ${missionText}`, hudPadding + 5, hudNextY);
                hudNextY += 18;
            });
        }

        if (
            gameState.isChargingHyperjump &&
            gameState.hyperjumpChargeStartTime
        ) {
            const chargeProgress = Math.min(
                1,
                (Date.now() - gameState.hyperjumpChargeStartTime) /
                    HYPERJUMP_CHARGE_TIME_MS,
            );
            ctx.fillStyle = "#0af";
            ctx.font = "18px monospace";
            const chargeText = `Hyperdrive Charging: ${Math.round(chargeProgress * 100)}%`;
            const textWidth = ctx.measureText(chargeText).width;
            ctx.textAlign = "center";
            ctx.fillText(chargeText, canvas.width / 2, canvas.height - 80);
            const barWidth = 250;
            const barHeight = 15;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height - 60;
            ctx.strokeStyle = "#0af";
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.fillRect(
                barX + 2,
                barY + 2,
                (barWidth - 4) * chargeProgress,
                barHeight - 4,
            );
            ctx.fillStyle = "#00FF00";
            ctx.lineWidth = 1;
            ctx.textAlign = "left";
        }

        if (
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            const planets =
                gameState.clientGameData.systems[myShip.system]?.planets;
            let canDock = false,
                dockPlanetName = "";
            if (planets) {
                planets.forEach((p) => {
                    const interactionRadiusSq =
                        DOCKING_DISTANCE_SQUARED *
                        Math.pow(p.planetImageScale || 1.0, 2) *
                        2;
                    if (
                        (myShip.x - p.x) ** 2 + (myShip.y - p.y) ** 2 <
                        interactionRadiusSq
                    ) {
                        canDock = true;
                        dockPlanetName = p.name;
                    }
                });
            }
            if (canDock) {
                ctx.font = "16px monospace";
                const dockMsg = `Press 'D' to dock at ${dockPlanetName}`;
                ctx.textAlign = "center";
                ctx.fillText(dockMsg, canvas.width / 2, canvas.height - 30);
                ctx.textAlign = "left";
            }
        }
    },
};

/* ===== END: hypernova/client/js/renderer.js ===== */


/* ===== START: hypernova/client/js/ui_manager.js ===== */
// client/js/ui_manager.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js"; // To send actions like buy/sell/undock

let uiContainer = null;
let dockMenuElement = null;

export const UIManager = {
    init(containerElement) {
        uiContainer = containerElement;
    },

    isMenuOpen() {
        return gameState.isMenuOpen;
    },

    openDockMenu() {
        if (dockMenuElement) this.closeDockMenu(); // Should not happen, but safeguard

        gameState.isMenuOpen = true;
        gameState.activeSubMenu = null; // Start at main dock menu
        document.body.classList.add("no-scroll");

        dockMenuElement = document.createElement("div");
        dockMenuElement.className = "panel";
        dockMenuElement.style.top = "50%";
        dockMenuElement.style.left = "50%";
        dockMenuElement.style.transform = "translate(-50%,-50%)";

        this.renderMainMenu();
        uiContainer.appendChild(dockMenuElement);
    },

    closeDockMenu() {
        if (dockMenuElement && dockMenuElement.parentNode === uiContainer) {
            uiContainer.removeChild(dockMenuElement);
        }
        dockMenuElement = null;
        gameState.isMenuOpen = false;
        gameState.activeSubMenu = null;
        gameState.selectedTradeIndex = 0;
        gameState.selectedWeaponKey = null;
        gameState.selectedShipIndex = 0;
        gameState.selectedMissionIndex = 0;
        document.body.classList.remove("no-scroll");
    },

    // Called by network.js when server confirms undock or player jumps
    undockCleanup() {
        gameState.docked = false;
        gameState.dockedAtDetails = null;
        this.closeDockMenu();
        // myShip.dockedAtPlanetIdentifier is set by server state update
    },

    renderMainMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return; // Ship def not loaded

        const cargoCount = myShip.cargo.reduce((s, v) => s + v, 0);

        dockMenuElement.innerHTML = `
          <div class="menu-item"><b>Docked at ${gameState.dockedAtDetails.planetName} (${gameState.dockedAtDetails.systemName})</b></div>
          <div class="menu-item">Credits: $${myShip.credits}</div>
          <div class="menu-item">Cargo: ${cargoCount}/${currentShipDef.maxCargo}</div>
          <div class="menu-item">---</div>
          <div class="menu-item">T - Trade</div>
          <div class="menu-item">Y - Shipyard</div>
          <div class="menu-item">O - Outfitter</div>
          <div class="menu-item">M - Missions</div>
          <div class="menu-item">U - Undock</div>
          <div class="menu-item" style="margin-top: 10px; font-size: 0.9em;">(Use Arrow Keys, Enter/Specific Keys, Esc)</div>
        `;
    },

    renderTradeMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;
        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return;

        const cargoCount = myShip.cargo.reduce((s, v) => s + v, 0);
        let html = `<div class="menu-item"><b>Trade at ${gameState.dockedAtDetails.planetName}</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits} Cargo: ${cargoCount}/${currentShipDef.maxCargo}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Good&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Qty&nbsp;&nbsp;&nbsp;Buy&nbsp;&nbsp;&nbsp;&nbsp;Sell&nbsp;&nbsp;&nbsp;Stock</u></div>`;

        // Use dockedAtDetails for prices/stock, as it's updated on tradeSuccess directly
        const planetEco = gameState.dockedAtDetails;

        if (
            !planetEco ||
            !planetEco.buyPrices ||
            !planetEco.sellPrices ||
            !planetEco.stock
        ) {
            html += "<div>Loading prices...</div>";
        } else {
            gameState.clientGameData.tradeGoods.forEach((g, i) => {
                const buyP =
                    planetEco.buyPrices[g.name] !== undefined
                        ? planetEco.buyPrices[g.name]
                        : "N/A";
                const sellP =
                    planetEco.sellPrices[g.name] !== undefined
                        ? planetEco.sellPrices[g.name]
                        : "N/A";
                const stockVal =
                    planetEco.stock[g.name] !== undefined
                        ? planetEco.stock[g.name]
                        : 0;
                const selectedClass =
                    i === gameState.selectedTradeIndex
                        ? "trade-item-selected"
                        : "";

                html +=
                    `<div class="menu-item ${selectedClass}">${g.name.padEnd(12, " ")} ${myShip.cargo[i].toString().padStart(3, " ")} ` +
                    `$${buyP.toString().padStart(4, " ")} $${sellP.toString().padStart(4, " ")} ${stockVal.toString().padStart(5, " ")}</div>`;
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy. S: Sell. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderOutfitterMenu() {
        if (
            !dockMenuElement ||
            !gameState.myShip ||
            !gameState.clientGameData.weapons
        )
            return;
        const myShip = gameState.myShip;
        let html = `<div class="menu-item"><b>Outfitter</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Weapon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price&nbsp;&nbsp;&nbsp;Dmg&nbsp;&nbsp;Owned</u></div>`;

        if (Object.keys(gameState.clientGameData.weapons).length === 0) {
            html +=
                "<div class='menu-item'>(No weapons available for purchase)</div>";
        } else {
            // Ensure selectedWeaponKey is valid
            const weaponKeys = Object.keys(gameState.clientGameData.weapons);
            if (
                !gameState.selectedWeaponKey ||
                !weaponKeys.includes(gameState.selectedWeaponKey)
            ) {
                gameState.selectedWeaponKey = weaponKeys[0] || null;
            }

            Object.entries(gameState.clientGameData.weapons).forEach(
                ([wKey, wDef]) => {
                    const owned =
                        myShip.weapons && myShip.weapons.includes(wKey)
                            ? "*"
                            : " ";
                    const selectedClass =
                        wKey === gameState.selectedWeaponKey
                            ? "trade-item-selected"
                            : "";
                    html += `<div class="menu-item ${selectedClass}">${wKey.padEnd(12, " ")} $${wDef.price.toString().padEnd(5, " ")} ${wDef.damage.toString().padEnd(3, " ")} ${owned}</div>`;
                },
            );
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy/Equip. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderShipyardMenu() {
        if (!dockMenuElement || !gameState.myShip) return;
        const myShip = gameState.myShip;
        let html = `<div class="menu-item"><b>Shipyard</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Ship&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price&nbsp;&nbsp;&nbsp;Cargo&nbsp;&nbsp;Current</u></div>`;

        if (gameState.clientGameData.shipTypes.length === 0) {
            html += "<div class='menu-item'>(No ships available)</div>";
        } else {
            gameState.clientGameData.shipTypes.forEach((s, i) => {
                const cur = myShip.type === i ? "*" : " ";
                const selectedClass =
                    i === gameState.selectedShipIndex
                        ? "trade-item-selected"
                        : "";
                html +=
                    `<div class="menu-item ${selectedClass}">${s.name.padEnd(12, " ")} $${s.price.toString().padEnd(5, " ")} ` +
                    `${s.maxCargo.toString().padEnd(3, " ")} ${cur}</div>`;
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderMissionsMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;
        let html = `<div class="menu-item"><b>Missions at ${gameState.dockedAtDetails.planetName}</b></div>`;
        html += `<div class="menu-item">Credits: $${gameState.myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reward</u></div>`;

        if (gameState.availableMissionsForCurrentPlanet.length === 0) {
            html +=
                "<div class='menu-item'>(No missions currently available)</div>";
        } else {
            // Ensure selectedMissionIndex is valid
            if (
                gameState.selectedMissionIndex >=
                gameState.availableMissionsForCurrentPlanet.length
            ) {
                gameState.selectedMissionIndex = Math.max(
                    0,
                    gameState.availableMissionsForCurrentPlanet.length - 1,
                );
            }

            gameState.availableMissionsForCurrentPlanet.forEach((m, i) => {
                const selectedClass =
                    i === gameState.selectedMissionIndex
                        ? "trade-item-selected"
                        : "";
                let titleDisplay =
                    m.title.length > 45
                        ? m.title.substring(0, 42) + "..."
                        : m.title;
                html += `<div class="menu-item ${selectedClass}">${titleDisplay.padEnd(45, " ")} $${m.rewardCredits.toString().padStart(6, " ")}</div>`;

                if (i === gameState.selectedMissionIndex) {
                    // Display details for selected mission
                    html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; ${m.description}</div>`;
                    const timeLeftMs = m.timeLimit - Date.now();
                    const timeLeftMin = Math.max(
                        0,
                        Math.round(timeLeftMs / 60000),
                    );
                    html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Time Limit: ${timeLeftMin} min. Penalty: $${m.penaltyCredits}</div>`;
                    if (
                        m.type ===
                        gameState.clientGameData.MISSION_TYPES.CARGO_DELIVERY
                    ) {
                        html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Deliver: ${m.cargoQuantity} ${m.cargoGoodName}</div>`;
                    } else if (
                        m.type === gameState.clientGameData.MISSION_TYPES.BOUNTY
                    ) {
                        const targetSysName =
                            gameState.clientGameData.systems[
                                m.targetSystemIndex
                            ]?.name || "Unknown System";
                        html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Target: ${m.targetsRequired} ${m.targetShipName}(s) in ${targetSysName}</div>`;
                    }
                }
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. A: Accept. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },
};

/* ===== END: hypernova/client/js/ui_manager.js ===== */


/* ===== START: hypernova/server/server.js ===== */
// hypernova/server/server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const path = require("path");
const fs = require("fs").promises; // Use promises for async file operations
const bodyParser = require("body-parser"); // To parse JSON request bodies

const gameConfig = require("./config/game_config");
const DataLoader = require("./utils/data_loader");

const PlayerManager = require("./modules/player_manager");
const WorldManager = require("./modules/world_manager");
const EconomyManager = require("./modules/economy_manager");
const MissionManager = require("./modules/mission_manager");
const CombatManager = require("./modules/combat_manager");

const app = express();
const serverHttp = http.createServer(app);
const io = new Server(serverHttp, {
    cors: {
        origin: "*", // Be more restrictive in production
        methods: ["GET", "POST"],
    },
});

app.use(bodyParser.json()); // Middleware to parse JSON request bodies
app.use(express.static(path.join(__dirname, "../client")));

app.get("/socket.io/socket.io.js", (req, res) => {
    res.sendFile(
        path.join(
            __dirname,
            "../../node_modules/socket.io/client-dist/socket.io.js",
        ),
    );
});

const USERS_DIR = path.join(__dirname, "data/users");

async function ensureUsersDir() {
    try {
        await fs.mkdir(USERS_DIR, { recursive: true });
        console.log("Users directory ensured:", USERS_DIR);
    } catch (error) {
        console.error("Failed to create users directory:", error);
    }
}
ensureUsersDir(); // Call this to ensure directory exists on server startup

// --- Authentication and User Data ---
async function findUser(username) {
    const filePath = path.join(USERS_DIR, `${username}.json`);
    try {
        const data = await fs.readFile(filePath, "utf-8");
        return JSON.parse(data);
    } catch (error) {
        if (error.code === "ENOENT") return null; // User file not found
        console.error(`Error reading user file for ${username}:`, error);
        throw error; // Re-throw other errors
    }
}

async function createUser(username, password) {
    // WARNING: Storing plain text passwords is a major security risk!
    // Use bcrypt.hashSync(password, saltRounds) in a real app.
    const userFilePath = path.join(USERS_DIR, `${username}.json`);
    const userData = {
        username,
        password /* In a real app, store HASHED password */,
    };
    try {
        await fs.writeFile(userFilePath, JSON.stringify(userData, null, 2));
        console.log(`User ${username} created.`);
        return userData;
    } catch (err) {
        console.error(`Error creating user ${username}:`, err);
        return null; // Indicate failure
    }
}

app.post("/login", async (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) {
        return res.status(400).json({
            success: false,
            message: "Username and password are required.",
        });
    }

    try {
        let user = await findUser(username);
        if (!user) {
            // Simplified: Auto-register if user not found
            console.log(`User ${username} not found. Registering...`);
            user = await createUser(username, password);
            if (!user) {
                return res.status(500).json({
                    success: false,
                    message: "Failed to register user.",
                });
            }
            // Security note: Do not send password back, even in registration success
            return res.json({
                success: true,
                username: user.username,
                message: "Registration successful. Logged in.",
            });
        }

        // WARNING: Plain text password comparison. Insecure!
        // In a real app: const match = await bcrypt.compare(password, user.hashedPassword);
        if (user.password !== password) {
            return res
                .status(401)
                .json({ success: false, message: "Invalid password." });
        }
        // Security note: Do not send password back
        res.json({
            success: true,
            username: user.username,
            message: "Login successful",
        });
    } catch (error) {
        console.error("Login error:", error);
        res.status(500).json({
            success: false,
            message: "Server error during login.",
        });
    }
});

// --- Progress Saving and Loading ---
app.post("/save-progress", async (req, res) => {
    // In a real app, authenticate user here (e.g., check session token from request headers)
    const { username, shipData, dockedAtDetails } = req.body;
    if (!username) {
        // This check is more for direct API calls; if called by logged-in client, username should be reliable
        // Or, better, get username from authenticated session/token on server-side
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }
    if (!shipData) {
        // Basic validation
        return res.status(400).json({
            success: false,
            message: "Ship data required for saving progress.",
        });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    const progress = {
        username,
        lastSaved: new Date().toISOString(),
        shipData,
        dockedAtDetails, // Can be null if not docked
    };

    try {
        await fs.writeFile(progressFilePath, JSON.stringify(progress, null, 2));
        res.json({ success: true, message: "Progress saved." });
    } catch (error) {
        console.error(`Error saving progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error saving progress.",
        });
    }
});

app.get("/load-progress", async (req, res) => {
    // In a real app, authenticate user here
    const { username } = req.query;
    if (!username) {
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    try {
        const data = await fs.readFile(progressFilePath, "utf-8");
        res.json(JSON.parse(data)); // Send the progress data back
    } catch (error) {
        if (error.code === "ENOENT") {
            // It's not an error if a user has no saved progress yet
            return res.status(200).json(null); // Send null or an empty object, client should handle this
        }
        console.error(`Error loading progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error loading progress.",
        });
    }
});

async function startServer() {
    const staticData = await DataLoader.loadAllData();
    gameConfig.staticWeaponsData = staticData.weapons;

    // Instantiate WorldManager first as PlayerManager will need it
    const worldManager = new WorldManager(
        io,
        staticData.systemsBase,
        staticData.tradeGoods,
        gameConfig,
    );

    // Pass the worldManager instance to PlayerManager
    const playerManager = new PlayerManager(
        io,
        staticData.shipTypes,
        staticData.tradeGoods,
        gameConfig,
        worldManager, // <<< MODIFICATION HERE: Pass worldManager instance
    );

    // Other managers can now receive playerManager and worldManager as needed
    const economyManager = new EconomyManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const missionManager = new MissionManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const combatManager = new CombatManager(
        io,
        playerManager,
        missionManager,
        staticData.weapons,
        gameConfig,
    );

    // Initialize worldManager AFTER all managers it might use internally during initialization are created
    // (though in this case, it mainly uses economyManager and missionManager passed to it)
    worldManager.initialize(economyManager, missionManager);

    setInterval(
        () => economyManager.updateAllPlanetEconomies(),
        gameConfig.ECONOMY_UPDATE_INTERVAL_MS,
    );
    setInterval(
        () => missionManager.populateAllPlanetMissions(), // This probably needs this.systems from worldManager
        gameConfig.MISSION_GENERATION_INTERVAL_MS,
    );
    setInterval(
        () => playerManager.checkAllPlayerMissionTimeouts(missionManager),
        gameConfig.PLAYER_MISSION_CHECK_INTERVAL_MS,
    );

    io.on("connection", (socket) => {
        const initialWorldData = {
            systems: worldManager.getSystemsForClient(),
            economies: worldManager.getEconomiesForClient(),
        };
        // PlayerManager's handleConnection now has access to worldManager via `this.worldManager`
        playerManager.handleConnection(socket, initialWorldData);

        economyManager.registerSocketHandlers(socket);
        missionManager.registerSocketHandlers(socket);
        combatManager.registerSocketHandlers(socket);
        // WorldManager registers its own handlers for 'dock' and 'undock' etc.
        worldManager.registerSocketHandlers(socket, playerManager);

        socket.on("disconnect", () => {
            playerManager.handleDisconnect(socket);
        });
    });

    serverHttp.listen(gameConfig.PORT, () =>
        console.log(
            `Server structured and listening on port ${gameConfig.PORT}`,
        ),
    );
}

startServer().catch((error) => {
    console.error("Failed to start server:", error);
    process.exit(1); // Exit if server fails to start
});

/* ===== END: hypernova/server/server.js ===== */


/* ===== START: hypernova/server/config/game_config.js ===== */
module.exports = {
    PORT: 3000,
    MISSION_TYPES: {
        CARGO_DELIVERY: "CARGO_DELIVERY",
        BOUNTY: "BOUNTY",
    },
    MAX_MISSIONS_PER_PLANET: 3,
    MISSION_GENERATION_INTERVAL_MS: 2 * 60 * 1000, // 2 minutes
    MISSION_TIME_LIMIT_BASE_MS: 5 * 60 * 1000, // 5 minutes
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS: 1 * 60 * 1000, // 1 minute

    ECONOMY_UPDATE_INTERVAL_MS: 1 * 60 * 1000, // 1 minute
    PLAYER_MISSION_CHECK_INTERVAL_MS: 30 * 1000, // 30 seconds

    INITIAL_STOCK_BASE: 1000,
    STOCK_PRODUCED_MULTIPLIER: 2.0,
    STOCK_CONSUMED_MULTIPLIER: 0.5,
    PRICE_SUPPLY_FACTOR_LOW: 0.7,
    PRICE_DEMAND_FACTOR_HIGH: 1.4,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER: 0.5,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER: 2.5,
    PLANET_PROFIT_MARGIN: 0.05,

    DEFAULT_PLAYER_CREDITS: 1000,
    DEFAULT_PLAYER_SHIP_TYPE_INDEX: 0, // Scout
    PLAYER_SPAWN_X: 400,
    PLAYER_SPAWN_Y: 300,

    // Hyperjump configuration
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED: 22500, // (150px)^2
    HYPERJUMP_CHARGE_TIME_MS: 3000, // 3 seconds
    // MAP_WIDTH: 800, // Example, if needed for arrival points
    // MAP_HEIGHT: 600, // Example
};

/* ===== END: hypernova/server/config/game_config.js ===== */


/* ===== START: hypernova/server/data/ship_types.json ===== */
[
    {
        "name": "Scout",
        "price": 0,
        "speedMult": 1.1,
        "rotMult": 1.5,
        "revMult": 2.5,
        "maxCargo": 10,
        "maxHealth": 100,
        "imageFile": "scout_ship.png",
        "imgWidth": 32,
        "imgHeight": 32
    },
    {
        "name": "Trader",
        "price": 2000,
        "speedMult": 1.0,
        "rotMult": 1.0,
        "revMult": 2.0,
        "maxCargo": 30,
        "maxHealth": 100
    },
    {
        "name": "Freighter",
        "price": 5000,
        "speedMult": 0.7,
        "rotMult": 0.7,
        "revMult": 1.5,
        "maxCargo": 60,
        "maxHealth": 100
    },
    {
        "name": "Interceptor",
        "price": 1500,
        "speedMult": 1.8,
        "rotMult": 1.8,
        "revMult": 2.2,
        "maxCargo": 5,
        "maxHealth": 120
    },
    {
        "name": "Heavy Freighter",
        "price": 10000,
        "speedMult": 0.5,
        "rotMult": 0.5,
        "revMult": 1.0,
        "maxCargo": 100,
        "maxHealth": 150
    }
]

/* ===== END: hypernova/server/data/ship_types.json ===== */


/* ===== START: hypernova/server/data/systems_init.json ===== */
[
    {
        "name": "Greek",
        "planets": [
            {
                "name": "Alpha",
                "x": 200,
                "y": 150,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            },
            {
                "name": "Delta",
                "x": 500,
                "y": 320,
                "produces": ["Ore"],
                "consumes": ["Medicine"]
            }
        ]
    },
    {
        "name": "Roman",
        "planets": [
            {
                "name": "Sol",
                "x": 140,
                "y": 120,
                "produces": ["Medicine", "Electronics"],
                "consumes": ["Food", "Ore"]
            },
            {
                "name": "Mars",
                "x": 620,
                "y": 420,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Nordic",
        "planets": [
            {
                "name": "Beta",
                "x": 380,
                "y": 480,
                "produces": ["Food", "Ore"],
                "consumes": ["Electronics", "Medicine"]
            }
        ]
    },
    {
        "name": "Egyptian",
        "planets": [
            {
                "name": "Nile",
                "x": 100,
                "y": 500,
                "produces": ["Food"],
                "consumes": ["Medicine", "Ore"]
            },
            {
                "name": "Giza",
                "x": 400,
                "y": 550,
                "produces": ["Ore"],
                "consumes": ["Electronics", "Food"]
            }
        ]
    },
    {
        "name": "Celtic",
        "planets": [
            {
                "name": "Tara",
                "x": 700,
                "y": 100,
                "produces": ["Medicine", "Food"],
                "consumes": ["Ore"]
            },
            {
                "name": "Avalon",
                "x": 650,
                "y": 300,
                "produces": ["Electronics"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    }
]

/* ===== END: hypernova/server/data/systems_init.json ===== */


/* ===== START: hypernova/server/data/trade_goods.json ===== */
[
    { "name": "Food", "basePrice": 10, "mass": 1 },
    { "name": "Ore", "basePrice": 50, "mass": 1 },
    { "name": "Medicine", "basePrice": 100, "mass": 1 },
    { "name": "Electronics", "basePrice": 200, "mass": 1 }
]

/* ===== END: hypernova/server/data/trade_goods.json ===== */


/* ===== START: hypernova/server/data/weapons.json ===== */
{
    "Laser": {
        "name": "Laser",
        "price": 500,
        "damage": 10,
        "range": 140,
        "rpm": 300,
        "color": "#f00",
        "beam": 0.3
    },
    "Plasma": {
        "name": "Plasma",
        "price": 1500,
        "damage": 25,
        "range": 200,
        "rpm": 180,
        "color": "#0ff",
        "beam": 0.3
    },
    "Railgun": {
        "name": "Railgun",
        "price": 3000,
        "damage": 40,
        "range": 280,
        "rpm": 120,
        "color": "#ff0",
        "beam": 0.2
    },
    "FusionGun": {
        "name": "FusionGun",
        "price": 8000,
        "damage": 70,
        "range": 350,
        "rpm": 60,
        "color": "#f0f",
        "beam": 0.15
    }
}


/* ===== END: hypernova/server/data/weapons.json ===== */


/* ===== START: hypernova/server/modules/combat_manager.js ===== */
// server/modules/combat_manager.js
class CombatManager {
    constructor(io, playerManager, missionManager, weaponsData, gameConfig) {
        this.io = io;
        this.playerManager = playerManager;
        this.missionManager = missionManager;
        this.weaponsData = weaponsData;
        this.gameConfig = gameConfig;
    }

    registerSocketHandlers(socket) {
        socket.on("fire", () => {
            const attacker = this.playerManager.getPlayer(socket.id);
            if (
                !attacker ||
                !attacker.activeWeapon ||
                attacker.destroyed ||
                attacker.dockedAtPlanetIdentifier ||
                attacker.hyperjumpState === "charging"
            ) {
                if (attacker && attacker.hyperjumpState === "charging") {
                    socket.emit("actionFailed", {
                        message:
                            "Cannot fire weapons while hyperdrive is charging.",
                    });
                }
                return;
            }

            const weaponStats = this.weaponsData[attacker.activeWeapon];
            if (!weaponStats) return;

            const fwdX = Math.cos(attacker.angle);
            const fwdY = Math.sin(attacker.angle);
            const cosHalfBeam = Math.cos(weaponStats.beam * 0.5);

            const allPlayers = this.playerManager.getAllPlayers();

            for (const targetId in allPlayers) {
                if (targetId === socket.id) continue;

                const target = allPlayers[targetId];
                if (
                    !target ||
                    target.system !== attacker.system ||
                    target.destroyed ||
                    target.dockedAtPlanetIdentifier
                )
                    continue;

                const dx = target.x - attacker.x;
                const dy = target.y - attacker.y;
                const dist = Math.hypot(dx, dy);

                if (dist === 0 || dist > weaponStats.range) continue;

                const dirToTargetX = dx / dist;
                const dirToTargetY = dy / dist;
                const dotProduct = fwdX * dirToTargetX + fwdY * dirToTargetY;

                if (dotProduct < cosHalfBeam) continue;

                target.health -= weaponStats.damage;
                let targetDestroyedThisShot = false;

                if (target.health > 0 && target.hyperjumpState === "charging") {
                    this.playerManager.handlePlayerHitDuringHyperjumpCharge(
                        target.id,
                    );
                }

                if (target.health <= 0) {
                    target.health = 0;
                    target.destroyed = true;
                    targetDestroyedThisShot = true;

                    if (
                        target.hyperjumpState === "charging" &&
                        target.hyperjumpChargeTimeoutId
                    ) {
                        clearTimeout(target.hyperjumpChargeTimeoutId);
                        target.hyperjumpChargeTimeoutId = null;
                        target.hyperjumpState = "idle";
                        console.log(
                            `Hyperjump charge for destroyed player ${target.id} cleared.`,
                        );
                    }
                    console.log(
                        `Player ${target.id} destroyed by ${attacker.id}`,
                    );
                }

                this.playerManager.updatePlayerState(target.id, {
                    // Changed to updatePlayerState for broader sync
                    health: target.health,
                    destroyed: target.destroyed,
                    hyperjumpState: target.hyperjumpState, // ensure hyperjump state is also synced if changed
                });

                if (targetDestroyedThisShot) {
                    this.missionManager.handleTargetDestroyed(attacker, target);
                }
                break;
            }

            // Emit projectile to all players in the attacker's system
            const systemPlayers = Object.values(allPlayers).filter(
                (p) => p.system === attacker.system,
            );
            systemPlayers.forEach((p) => {
                this.io.to(p.id).emit("projectile", {
                    x: attacker.x,
                    y: attacker.y,
                    angle: attacker.angle,
                    color: weaponStats.color,
                    range: weaponStats.range,
                    shooterId: attacker.id,
                });
            });
        });
    }
}

module.exports = CombatManager;

/* ===== END: hypernova/server/modules/combat_manager.js ===== */


/* ===== START: hypernova/server/modules/economy_manager.js ===== */
// server/modules/economy_manager.js
const {
    INITIAL_STOCK_BASE,
    STOCK_PRODUCED_MULTIPLIER,
    STOCK_CONSUMED_MULTIPLIER,
    PRICE_SUPPLY_FACTOR_LOW,
    PRICE_DEMAND_FACTOR_HIGH,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER,
    PLANET_PROFIT_MARGIN,
} = require("../config/game_config");

class EconomyManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager; // To get/update planet data
        this.playerManager = playerManager; // To update player credits/cargo
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
    }

    getTradeGoodByName(goodName) {
        return this.tradeGoods.find((g) => g.name === goodName);
    }

    calculatePricesForGoodOnPlanet(planet, goodName) {
        const good = this.getTradeGoodByName(goodName);
        if (!good) return;

        let baseValuation = good.basePrice;
        if (planet.produces.includes(goodName))
            baseValuation *= PRICE_SUPPLY_FACTOR_LOW;
        else if (planet.consumes.includes(goodName))
            baseValuation *= PRICE_DEMAND_FACTOR_HIGH;

        let targetStock = INITIAL_STOCK_BASE;
        if (planet.produces.includes(goodName))
            targetStock *= STOCK_PRODUCED_MULTIPLIER;
        if (planet.consumes.includes(goodName))
            targetStock *= STOCK_CONSUMED_MULTIPLIER;
        targetStock = Math.max(1, targetStock);

        let stockEffectMultiplier = 1.0;
        if (planet.stock[goodName] > 0) {
            stockEffectMultiplier = targetStock / planet.stock[goodName];
        } else {
            stockEffectMultiplier = PRICE_STOCK_MAX_EFFECT_MULTIPLIER * 2; // High price if no stock
        }
        stockEffectMultiplier = Math.max(
            PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
            Math.min(PRICE_STOCK_MAX_EFFECT_MULTIPLIER, stockEffectMultiplier),
        );

        const planetInternalValue = Math.round(
            baseValuation * stockEffectMultiplier,
        );
        planet.buyPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 + PLANET_PROFIT_MARGIN)),
        );
        planet.sellPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 - PLANET_PROFIT_MARGIN)),
        );

        if (planet.buyPrices[goodName] <= planet.sellPrices[goodName]) {
            planet.buyPrices[goodName] = planet.sellPrices[goodName] + 1;
        }
        if (planet.sellPrices[goodName] <= 0) planet.sellPrices[goodName] = 1;
    }

    initializeAllPlanetEconomies(systems) {
        // `systems` is the live array from WorldManager
        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let initialStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        initialStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        initialStock *= STOCK_CONSUMED_MULTIPLIER;
                    planet.stock[good.name] = Math.floor(
                        Math.max(10, initialStock),
                    );
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });
        console.log("Planet economies initialized by EconomyManager.");
    }

    updateAllPlanetEconomies() {
        // Called by interval in server.js
        const systems = this.worldManager.systems; // Get live systems data
        if (!systems || systems.length === 0) return;

        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let targetStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        targetStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        targetStock *= STOCK_CONSUMED_MULTIPLIER;
                    targetStock = Math.max(1, targetStock);

                    const currentStock = planet.stock[good.name] || 0;
                    const diff = targetStock - currentStock;
                    let change = Math.round(diff * 0.02); // Slow adjustment
                    if (change === 0 && diff !== 0) change = diff > 0 ? 1 : -1;

                    planet.stock[good.name] = currentStock + change;
                    planet.stock[good.name] = Math.max(
                        0,
                        Math.min(planet.stock[good.name], targetStock * 5),
                    ); // Cap stock
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });

        this.io.emit(
            "updatePlanetEconomies",
            this.worldManager.getEconomiesForClient(),
        );
        // console.log("Planet economies updated and broadcasted.");
    }

    notifyPlanetEconomyUpdate(systemIndex, planetIndex) {
        const planet = this.worldManager.getPlanet(systemIndex, planetIndex);
        if (planet) {
            this.io.emit("planetEconomyUpdate", {
                systemIndex,
                planetIndex,
                name: planet.name, // Though client might not use name here
                buyPrices: planet.buyPrices,
                sellPrices: planet.sellPrices,
                stock: planet.stock,
            });
        }
    }

    registerSocketHandlers(socket) {
        socket.on(
            "buyGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.buyPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not sold here.",
                    });
                const totalCost = pricePerUnit * quantity;

                const currentCargoMass = player.cargo.reduce(
                    (sum, val, idx) => sum + this.tradeGoods[idx].mass * val,
                    0,
                );
                const newGoodMass = goodInfo.mass * quantity;

                if (player.credits < totalCost)
                    return socket.emit("tradeError", {
                        message: "Not enough credits.",
                    });
                if (currentCargoMass + newGoodMass > player.maxCargo)
                    return socket.emit("tradeError", {
                        message: "Not enough cargo space.",
                    });
                if (
                    !planet.stock[goodName] ||
                    planet.stock[goodName] < quantity
                )
                    return socket.emit("tradeError", {
                        message: "Planet out of stock.",
                    });

                player.credits -= totalCost;
                player.cargo[goodIdx] += quantity;
                planet.stock[goodName] -= quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        // For immediate UI update on client
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );

        socket.on(
            "sellGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }
                if (player.cargo[goodIdx] < quantity)
                    return socket.emit("tradeError", {
                        message: "Not enough goods to sell.",
                    });

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.sellPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not bought here.",
                    });

                const totalGain = pricePerUnit * quantity;

                player.credits += totalGain;
                player.cargo[goodIdx] -= quantity;
                planet.stock[goodName] += quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );
    }
}

module.exports = EconomyManager;

/* ===== END: hypernova/server/modules/economy_manager.js ===== */


/* ===== START: hypernova/server/modules/mission_manager.js ===== */
// server/modules/mission_manager.js
const { generateMissionId, getSystemDistance } = require("../utils/helpers");
const {
    MISSION_TYPES,
    MAX_MISSIONS_PER_PLANET,
    MISSION_TIME_LIMIT_BASE_MS,
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS,
} = require("../config/game_config");

class MissionManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager;
        this.playerManager = playerManager;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig; // For other mission params if any
    }

    generateCargoDeliveryMission(
        originSystemIndex,
        originPlanetIndex,
        systems,
    ) {
        const numSystems = systems.length;
        if (
            numSystems === 0 ||
            (numSystems === 1 && systems[0].planets.length < 2)
        )
            return null;

        let destSystemIndex, destPlanetIndex;
        let attempts = 0;
        const originSystem = systems[originSystemIndex];
        const originPlanet = originSystem.planets[originPlanetIndex];

        do {
            destSystemIndex = Math.floor(Math.random() * numSystems);
            const destSystem = systems[destSystemIndex];
            if (!destSystem || destSystem.planets.length === 0) {
                attempts++;
                continue;
            }
            destPlanetIndex = Math.floor(
                Math.random() * destSystem.planets.length,
            );
            attempts++;
        } while (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex &&
            numSystems > 1 &&
            systems[destSystemIndex].planets.length > 1 && // only try again if there are other options
            attempts < 20
        );

        // If still same after attempts (e.g. only one planet in one system, or two planets total)
        if (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex
        )
            return null;

        const goodIndex = Math.floor(Math.random() * this.tradeGoods.length);
        const goodToDeliver = this.tradeGoods[goodIndex];
        const quantity = Math.floor(Math.random() * 5) + 2; // 2 to 6 units

        const distance = getSystemDistance(
            originSystemIndex,
            destSystemIndex,
            numSystems,
        );
        const rewardCredits =
            goodToDeliver.basePrice * quantity * 1.5 + distance * 150 + 100;
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const destPlanet = systems[destSystemIndex].planets[destPlanetIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.CARGO_DELIVERY,
            title: `Deliver ${quantity} ${goodToDeliver.name} to ${destPlanet.name} (${systems[destSystemIndex].name})`,
            description: `Transport ${quantity} units of ${goodToDeliver.name} from ${originPlanet.name} (${originSystem.name}) to ${destPlanet.name} (${systems[destSystemIndex].name}).`,
            originSystemIndex,
            originPlanetIndex,
            destinationSystemIndex: destSystemIndex,
            destinationPlanetIndex: destPlanetIndex,
            cargoGoodName: goodToDeliver.name,
            cargoQuantity: quantity,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.3),
            timeLimit: timeLimit,
            status: "AVAILABLE", // Initial status
        };
    }

    generateBountyMission(originSystemIndex, originPlanetIndex, systems) {
        const numSystems = systems.length;
        if (numSystems === 0) return null;
        let targetSystemIndex;

        if (numSystems > 1) {
            do {
                targetSystemIndex = Math.floor(Math.random() * numSystems);
            } while (targetSystemIndex === originSystemIndex && numSystems > 1); // Ensure different system if possible
        } else {
            targetSystemIndex = originSystemIndex;
        }

        const numTargets = Math.floor(Math.random() * 2) + 1; // 1 to 2 pirates
        const distance = getSystemDistance(
            originSystemIndex,
            targetSystemIndex,
            numSystems,
        );
        const rewardCredits = numTargets * 500 + distance * 100; // Base reward + distance bonus
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const originPlanet =
            systems[originSystemIndex].planets[originPlanetIndex];
        const originSystem = systems[originSystemIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.BOUNTY,
            title: `Bounty: ${numTargets} Pirate${numTargets > 1 ? "s" : ""} in ${systems[targetSystemIndex].name}`,
            description: `Hostile elements reported in ${systems[targetSystemIndex].name} system. Originated near ${originPlanet.name} (${originSystem.name}). Eliminate ${numTargets} of them.`,
            originSystemIndex,
            originPlanetIndex,
            targetSystemIndex: targetSystemIndex,
            targetShipName: "Pirate", // Generic for now
            targetsRequired: numTargets,
            targetsDestroyed: 0,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.2),
            timeLimit: timeLimit,
            status: "AVAILABLE",
        };
    }

    populateAllPlanetMissions() {
        // Called by interval
        const systems = this.worldManager.systems;
        if (!systems) return;

        systems.forEach((system, sysIdx) => {
            system.planets.forEach((planet, pIdx) => {
                // Filter out expired or already taken missions (though 'taken' is handled on accept)
                planet.availableMissions = planet.availableMissions.filter(
                    (m) => m.status === "AVAILABLE" && m.timeLimit > Date.now(),
                );

                while (
                    planet.availableMissions.length < MAX_MISSIONS_PER_PLANET
                ) {
                    let newMission = null;
                    const missionTypeRoll = Math.random();
                    if (missionTypeRoll < 0.7) {
                        // 70% chance for cargo
                        newMission = this.generateCargoDeliveryMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    } else {
                        newMission = this.generateBountyMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    }
                    if (newMission) {
                        planet.availableMissions.push(newMission);
                    } else {
                        break; // Stop if no mission could be generated (e.g., single planet system for cargo)
                    }
                }
            });
        });
        // console.log("Planet missions populated.");
    }

    checkPlayerMissionTimeouts(player) {
        // player object directly modified
        let missionsChanged = false;
        const completedOrFailed = [];

        player.activeMissions.forEach((mission) => {
            if (
                mission.status === "ACCEPTED" &&
                Date.now() > mission.timeLimit
            ) {
                mission.status = "FAILED_TIME";
                player.credits -= mission.penaltyCredits;
                player.credits = Math.max(0, player.credits);
                missionsChanged = true;
                completedOrFailed.push({
                    missionId: mission.id,
                    status: mission.status,
                    reason: "Time expired.",
                    penalty: mission.penaltyCredits,
                });
            }
        });

        if (missionsChanged) {
            player.activeMissions = player.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
        }
        return { changed: missionsChanged, completedOrFailed };
    }

    checkCargoMissionCompletionOnDock(player, systemIndex, planetIndex) {
        let cargoChanged = false;
        let creditsChanged = false;
        let missionsChanged = false;

        if (player.activeMissions) {
            const remainingMissions = [];
            player.activeMissions.forEach((mission) => {
                if (
                    mission.type === MISSION_TYPES.CARGO_DELIVERY &&
                    mission.status === "ACCEPTED" &&
                    mission.destinationSystemIndex === systemIndex &&
                    mission.destinationPlanetIndex === planetIndex
                ) {
                    const goodIdx = this.tradeGoods.findIndex(
                        (g) => g.name === mission.cargoGoodName,
                    );
                    if (
                        goodIdx !== -1 &&
                        player.cargo[goodIdx] >= mission.cargoQuantity
                    ) {
                        player.cargo[goodIdx] -= mission.cargoQuantity;
                        player.credits += mission.rewardCredits;
                        mission.status = "COMPLETED"; // Mark for removal / notification
                        cargoChanged = true;
                        creditsChanged = true;
                        missionsChanged = true;

                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "COMPLETED",
                            reward: mission.rewardCredits,
                            message: `Delivered ${mission.cargoQuantity} ${mission.cargoGoodName}.`,
                        });
                    } else {
                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "INFO",
                            message: `Need ${mission.cargoQuantity} ${mission.cargoGoodName} to complete. You have ${player.cargo[goodIdx] || 0}.`,
                        });
                        remainingMissions.push(mission); // Keep mission
                    }
                } else {
                    remainingMissions.push(mission); // Keep other missions
                }
            });
            if (missionsChanged) player.activeMissions = remainingMissions;
        }
        return { cargoChanged, creditsChanged, missionsChanged };
    }

    // Called by CombatManager when a target is destroyed
    handleTargetDestroyed(attackerPlayer, destroyedTargetPlayer) {
        let missionsUpdated = false;
        const completedBountiesForNotification = [];
        const attacker = this.playerManager.getPlayer(attackerPlayer.id); // Get live player object
        if (!attacker || !attacker.activeMissions) return;

        attacker.activeMissions.forEach((mission) => {
            if (
                mission.type === MISSION_TYPES.BOUNTY &&
                mission.status === "ACCEPTED" &&
                mission.targetSystemIndex === attacker.system
            ) {
                // Check if in correct system

                // For now, any player kill in the target system counts for "Pirate" bounty
                // Later, you might check `destroyedTargetPlayer.type` or if it's an NPC
                mission.targetsDestroyed = (mission.targetsDestroyed || 0) + 1;
                missionsUpdated = true;

                if (mission.targetsDestroyed >= mission.targetsRequired) {
                    mission.status = "COMPLETED";
                    attacker.credits += mission.rewardCredits;
                    completedBountiesForNotification.push({
                        missionId: mission.id,
                        status: "COMPLETED",
                        reward: mission.rewardCredits,
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                        message: "Bounty completed!",
                    });
                } else {
                    // Send progress update
                    this.io.to(attacker.id).emit("missionUpdate", {
                        missionId: mission.id,
                        status: "ACCEPTED", // Still accepted, just progress
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                    });
                }
            }
        });

        if (missionsUpdated) {
            completedBountiesForNotification.forEach((update) =>
                this.io.to(attacker.id).emit("missionUpdate", update),
            );

            const oldMissionCount = attacker.activeMissions.length;
            attacker.activeMissions = attacker.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
            const newMissionCount = attacker.activeMissions.length;

            const playerUpdates = { credits: attacker.credits };
            if (oldMissionCount !== newMissionCount) {
                playerUpdates.activeMissions = attacker.activeMissions;
            }
            this.playerManager.updatePlayerState(attacker.id, playerUpdates);
        }
    }

    registerSocketHandlers(socket) {
        socket.on("requestMissions", ({ systemIndex, planetIndex }) => {
            const player = this.playerManager.getPlayer(socket.id);
            const planet = this.worldManager.getPlanet(
                systemIndex,
                planetIndex,
            );

            if (!player || !planet) {
                return socket.emit("actionFailed", {
                    message: "Invalid location for missions.",
                });
            }

            const availableMissions = planet.availableMissions.filter(
                (m) =>
                    m.timeLimit > Date.now() && // Not expired
                    (!player.activeMissions ||
                        !player.activeMissions.find((pm) => pm.id === m.id)), // Not already active for player
            );
            socket.emit("availableMissionsList", {
                systemIndex,
                planetIndex,
                missions: availableMissions,
            });
        });

        socket.on(
            "acceptMission",
            ({ missionId, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );

                if (!player || !planet) {
                    return socket.emit("actionFailed", {
                        message: "Cannot accept mission from this location.",
                    });
                }

                const missionIndex = planet.availableMissions.findIndex(
                    (m) => m.id === missionId,
                );
                if (missionIndex === -1) {
                    return socket.emit("actionFailed", {
                        message: "Mission not available or already taken.",
                    });
                }

                const missionToAccept = planet.availableMissions[missionIndex];

                if (missionToAccept.timeLimit < Date.now()) {
                    planet.availableMissions.splice(missionIndex, 1); // Remove expired
                    return socket.emit("actionFailed", {
                        message: "Mission has expired.",
                    });
                }
                if (player.activeMissions.length >= 5) {
                    // Max active missions limit
                    return socket.emit("actionFailed", {
                        message: "Too many active missions.",
                    });
                }

                missionToAccept.status = "ACCEPTED";
                if (
                    !missionToAccept.targetsDestroyed &&
                    missionToAccept.type === MISSION_TYPES.BOUNTY
                ) {
                    missionToAccept.targetsDestroyed = 0; // Ensure bounty missions start with 0 destroyed
                }
                player.activeMissions.push({ ...missionToAccept }); // Add a copy to player
                planet.availableMissions.splice(missionIndex, 1); // Remove from planet's available list

                socket.emit("missionAccepted", { mission: missionToAccept });
                this.playerManager.updatePlayerState(socket.id, {
                    activeMissions: player.activeMissions,
                });
            },
        );
    }
}

module.exports = MissionManager;

/* ===== END: hypernova/server/modules/mission_manager.js ===== */


/* ===== START: hypernova/server/modules/player_manager.js ===== */
// hypernova/server/modules/player_manager.js
const { MISSION_TYPES } = require("../config/game_config");
// const gameConfig = require("../config/game_config"); // No, gameConfig is passed in constructor

class PlayerManager {
    constructor(
        io,
        shipTypes,
        tradeGoods,
        gameConfigInstance,
        worldManagerInstance,
    ) {
        this.io = io;
        this.shipTypes = shipTypes;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfigInstance;
        this.players = {};
        this.worldManager = worldManagerInstance;
    }

    handleConnection(socket, initialWorldData = {}) {
        const defaultShipType =
            this.shipTypes[this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX] ||
            this.shipTypes[0];
        this.players[socket.id] = {
            id: socket.id,
            x: this.gameConfig.PLAYER_SPAWN_X || 400,
            y: this.gameConfig.PLAYER_SPAWN_Y || 300,
            angle: 0,
            vx: 0,
            vy: 0,
            type: this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX,
            credits: this.gameConfig.DEFAULT_PLAYER_CREDITS,
            cargo: new Array(this.tradeGoods.length).fill(0),
            maxCargo: defaultShipType.maxCargo,
            health: defaultShipType.maxHealth || 100,
            maxHealth: defaultShipType.maxHealth || 100,
            weapons: [],
            activeMissions: [],
            activeWeapon: null,
            lastShot: 0,
            system: 0,
            dockedAtPlanetIdentifier: null,
            destroyed: false,
            color:
                "#" +
                Math.floor(Math.random() * 0xffffff)
                    .toString(16)
                    .padStart(6, "0"),
            hyperjumpState: "idle",
            hyperjumpChargeTimeoutId: null,
        };

        console.log(
            `Player ${socket.id} connected. Initial ship: ${defaultShipType.name}. Initial credits: ${this.players[socket.id].credits}`,
        );

        socket.emit("init", {
            id: socket.id,
            ships: this.players,
            gameData: {
                ...initialWorldData,
                tradeGoods: this.tradeGoods,
                weapons: this.gameConfig.staticWeaponsData,
                shipTypes: this.shipTypes,
                MISSION_TYPES: this.gameConfig.MISSION_TYPES,
            },
        });

        socket.broadcast.emit("playerJoined", {
            id: socket.id,
            ship: this.players[socket.id],
        });

        this.registerSocketHandlers(socket);

        socket.on("clientLoadedDockedState", (receivedSyncData) => {
            console.log(
                `PlayerManager: Received 'clientLoadedDockedState' from ${socket.id} with data:`,
                JSON.stringify(receivedSyncData),
            );
            const player = this.players[socket.id];

            if (player && receivedSyncData) {
                if (receivedSyncData.credits !== undefined)
                    player.credits = receivedSyncData.credits;
                if (receivedSyncData.cargo !== undefined)
                    player.cargo = receivedSyncData.cargo;
                if (receivedSyncData.weapons !== undefined)
                    player.weapons = receivedSyncData.weapons;
                if (receivedSyncData.activeWeapon !== undefined)
                    player.activeWeapon = receivedSyncData.activeWeapon;
                if (receivedSyncData.health !== undefined)
                    player.health = receivedSyncData.health;
                if (receivedSyncData.activeMissions !== undefined)
                    player.activeMissions = receivedSyncData.activeMissions;

                if (receivedSyncData.type !== undefined) {
                    player.type = receivedSyncData.type;
                    const shipTypeDef = this.shipTypes[player.type];
                    if (shipTypeDef) {
                        player.maxCargo = shipTypeDef.maxCargo;
                        player.maxHealth = shipTypeDef.maxHealth;
                        if (player.health > player.maxHealth) {
                            player.health = player.maxHealth;
                        }
                    } else {
                        console.warn(
                            `PlayerManager: Unknown ship type ${receivedSyncData.type} for player ${socket.id}.`,
                        );
                    }
                }

                player.hyperjumpState = "idle"; // Ensure idle on load
                if (player.hyperjumpChargeTimeoutId) {
                    clearTimeout(player.hyperjumpChargeTimeoutId);
                    player.hyperjumpChargeTimeoutId = null;
                }

                if (
                    receivedSyncData.dockedAtDetails &&
                    receivedSyncData.dockedAtDetails.systemIndex !==
                        undefined &&
                    receivedSyncData.dockedAtDetails.planetIndex !== undefined
                ) {
                    player.dockedAtPlanetIdentifier = {
                        systemIndex:
                            receivedSyncData.dockedAtDetails.systemIndex,
                        planetIndex:
                            receivedSyncData.dockedAtDetails.planetIndex,
                    };
                    player.system =
                        receivedSyncData.dockedAtDetails.systemIndex;

                    if (
                        this.worldManager &&
                        typeof this.worldManager.getPlanet === "function"
                    ) {
                        const planet = this.worldManager.getPlanet(
                            player.dockedAtPlanetIdentifier.systemIndex,
                            player.dockedAtPlanetIdentifier.planetIndex,
                        );
                        if (planet) {
                            player.x = planet.x;
                            player.y = planet.y;
                        }
                    }
                    player.vx = 0;
                    player.vy = 0;

                    if (
                        this.worldManager &&
                        typeof this.worldManager.playerDockedAtPlanet ===
                            "function"
                    ) {
                        this.worldManager.playerDockedAtPlanet(
                            player,
                            player.dockedAtPlanetIdentifier.systemIndex,
                            player.dockedAtPlanetIdentifier.planetIndex,
                        );
                    }
                    console.log(
                        `PlayerManager: Synced server state for ${socket.id} to be DOCKED at system ${player.system}, planet ${player.dockedAtPlanetIdentifier.planetIndex}.`,
                    );
                } else {
                    player.dockedAtPlanetIdentifier = null;
                    if (receivedSyncData.x !== undefined)
                        player.x = receivedSyncData.x;
                    if (receivedSyncData.y !== undefined)
                        player.y = receivedSyncData.y;
                    if (receivedSyncData.angle !== undefined)
                        player.angle = receivedSyncData.angle;
                    if (receivedSyncData.vx !== undefined)
                        player.vx = receivedSyncData.vx;
                    if (receivedSyncData.vy !== undefined)
                        player.vy = receivedSyncData.vy;
                    if (receivedSyncData.system !== undefined)
                        player.system = receivedSyncData.system;
                    console.log(
                        `PlayerManager: Synced server state for ${socket.id} to be UNDOCKED in system ${player.system}.`,
                    );
                }

                const comprehensiveUpdate = {
                    x: player.x,
                    y: player.y,
                    vx: player.vx,
                    vy: player.vy,
                    angle: player.angle,
                    system: player.system,
                    dockedAtPlanetIdentifier: player.dockedAtPlanetIdentifier,
                    credits: player.credits,
                    cargo: player.cargo,
                    weapons: player.weapons,
                    activeWeapon: player.activeWeapon,
                    health: player.health,
                    maxHealth: player.maxHealth,
                    type: player.type,
                    maxCargo: player.maxCargo,
                    activeMissions: player.activeMissions,
                    hyperjumpState: player.hyperjumpState, // ensure client knows it's idle
                };
                this.updatePlayerState(socket.id, comprehensiveUpdate);
                console.log(
                    `PlayerManager: Server state for ${socket.id} fully updated and broadcasted after client load.`,
                );
            } else {
                console.warn(
                    `PlayerManager: Invalid data for 'clientLoadedDockedState' from ${socket.id}.`,
                );
            }
        });
    }

    handleDisconnect(socket) {
        const player = this.getPlayer(socket.id);
        if (player) {
            if (
                player.dockedAtPlanetIdentifier &&
                this.worldManager &&
                typeof this.worldManager.playerUndockedFromPlanet === "function"
            ) {
                this.worldManager.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
            if (player.hyperjumpChargeTimeoutId) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
                player.hyperjumpState = "idle";
                console.log(
                    `Player ${socket.id} disconnected, hyperjump charge cancelled.`,
                );
            }
        }
        console.log(`Player ${socket.id} disconnected.`);
        delete this.players[socket.id];
        this.io.emit("playerLeft", socket.id);
    }

    getPlayer(playerId) {
        return this.players[playerId];
    }

    updatePlayerState(playerId, updates) {
        if (this.players[playerId]) {
            Object.assign(this.players[playerId], updates);
            this.io.emit("state", { [playerId]: this.players[playerId] });
        }
    }

    broadcastPlayerState(playerId, specificUpdates) {
        if (this.players[playerId]) {
            const updateToSend = {};
            // Only copy known properties from specificUpdates to prevent unintended large objects
            const allowedKeys = [
                "x",
                "y",
                "vx",
                "vy",
                "angle",
                "system",
                "dockedAtPlanetIdentifier",
                "credits",
                "cargo",
                "health",
                "maxHealth",
                "type",
                "maxCargo",
                "weapons",
                "activeWeapon",
                "activeMissions",
                "destroyed",
                "hyperjumpState",
            ];
            for (const key of allowedKeys) {
                if (specificUpdates.hasOwnProperty(key)) {
                    updateToSend[key] = specificUpdates[key];
                }
            }
            if (Object.keys(updateToSend).length > 0) {
                this.io.emit("state", { [playerId]: updateToSend });
            } else if (!specificUpdates) {
                // if specificUpdates is null/undefined, send whole player object
                this.io.emit("state", { [playerId]: this.players[playerId] });
            }
        }
    }

    registerSocketHandlers(socket) {
        socket.on("control", (data) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.dockedAtPlanetIdentifier) return;

            // Client-side logic prevents new thrust/rotation if charging.
            // Server updates position based on client's drift.
            player.x = data.x;
            player.y = data.y;
            player.vx = data.vx;
            player.vy = data.vy;
            if (player.hyperjumpState !== "charging") {
                // Only update angle if not charging
                player.angle = data.angle;
            }
            // System changes are handled by hyperjump logic only
            // if (data.system !== undefined && player.system !== data.system) { player.system = data.system; }

            const minimalUpdate = {
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                angle: player.angle,
                // system: player.system, // System is not sent in minimal update unless changed by hyperjump
            };
            socket.broadcast.emit("state", { [socket.id]: minimalUpdate });
        });

        socket.on("requestHyperjump", () => {
            const player = this.getPlayer(socket.id);
            if (!player || player.destroyed) return;

            if (player.dockedAtPlanetIdentifier) {
                return socket.emit("hyperjumpDenied", {
                    message: "Cannot engage hyperdrive while docked.",
                });
            }
            if (player.hyperjumpState !== "idle") {
                return socket.emit("hyperjumpDenied", {
                    message: "Hyperdrive already engaged or cooling down.",
                });
            }

            const currentSystemData = this.worldManager.getSystem(
                player.system,
            );
            if (currentSystemData && currentSystemData.planets) {
                for (const planet of currentSystemData.planets) {
                    const distSq =
                        (player.x - planet.x) ** 2 + (player.y - planet.y) ** 2;
                    if (
                        distSq <
                        this.gameConfig
                            .MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED
                    ) {
                        return socket.emit("hyperjumpDenied", {
                            message: "Too close to a celestial body.",
                        });
                    }
                }
            }

            player.hyperjumpState = "charging";
            // Also update player state for other clients to know this player is charging
            this.updatePlayerState(socket.id, { hyperjumpState: "charging" });
            socket.emit("hyperjumpChargeStarted", {
                chargeTime: this.gameConfig.HYPERJUMP_CHARGE_TIME_MS,
            });
            console.log(`Player ${socket.id} starting hyperjump charge.`);

            player.hyperjumpChargeTimeoutId = setTimeout(() => {
                if (player.hyperjumpState !== "charging" || player.destroyed) {
                    // Check destroyed status too
                    player.hyperjumpChargeTimeoutId = null;
                    if (
                        player.hyperjumpState === "charging" &&
                        !player.destroyed
                    )
                        player.hyperjumpState = "idle"; // Reset if not destroyed but cancelled
                    this.updatePlayerState(socket.id, {
                        hyperjumpState: player.hyperjumpState,
                    });
                    return;
                }

                player.hyperjumpState = "idle";
                player.hyperjumpChargeTimeoutId = null;

                const oldSystem = player.system;
                player.system =
                    (player.system + 1) % this.worldManager.systems.length;

                let newX,
                    newY,
                    newAngle = 0;
                const targetSystemData = this.worldManager.getSystem(
                    player.system,
                );
                if (targetSystemData && targetSystemData.planets.length > 0) {
                    const arrivalPlanet = targetSystemData.planets[0];
                    newX = arrivalPlanet.x - 250;
                    newY = arrivalPlanet.y;
                    newAngle = 0;
                } else {
                    newX = 100;
                    newY = this.gameConfig.PLAYER_SPAWN_Y || 300;
                    newAngle = 0;
                }

                player.x = newX;
                player.y = newY;
                player.vx = 0;
                player.vy = 0;
                player.angle = newAngle;
                player.dockedAtPlanetIdentifier = null;

                console.log(
                    `Player ${socket.id} hyperjump complete. Old system: ${oldSystem}, New system: ${player.system}.`,
                );

                socket.emit("hyperjumpComplete", {
                    newSystem: player.system,
                    newX: player.x,
                    newY: player.y,
                    newAngle: player.angle,
                });

                this.updatePlayerState(socket.id, {
                    system: player.system,
                    x: player.x,
                    y: player.y,
                    vx: player.vx,
                    vy: player.vy,
                    angle: player.angle,
                    dockedAtPlanetIdentifier: null,
                    hyperjumpState: "idle",
                });
            }, this.gameConfig.HYPERJUMP_CHARGE_TIME_MS);
        });

        socket.on("cancelHyperjump", () => {
            const player = this.getPlayer(socket.id);
            if (
                player &&
                player.hyperjumpState === "charging" &&
                player.hyperjumpChargeTimeoutId
            ) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
                player.hyperjumpState = "idle";
                this.updatePlayerState(socket.id, { hyperjumpState: "idle" });
                socket.emit("hyperjumpCancelled", {
                    message: "Hyperjump cancelled by player.",
                });
                console.log(`Player ${socket.id} cancelled hyperjump charge.`);
            }
        });

        socket.on("equipWeapon", ({ weapon: weaponName }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message:
                        "Cannot modify equipment while hyperdrive is active.",
                });
            }
            const weaponData = this.gameConfig.staticWeaponsData[weaponName];
            if (!weaponData)
                return socket.emit("actionFailed", {
                    message: "Invalid weapon.",
                });

            if (!player.weapons.includes(weaponName)) {
                if (player.credits >= weaponData.price) {
                    player.credits -= weaponData.price;
                    player.weapons.push(weaponName);
                    player.activeWeapon = weaponName;
                    this.updatePlayerState(socket.id, {
                        credits: player.credits,
                        weapons: player.weapons,
                        activeWeapon: player.activeWeapon,
                    });
                    socket.emit("actionSuccess", {
                        message: `Purchased and equipped ${weaponName}.`,
                    });
                } else {
                    return socket.emit("actionFailed", {
                        message: "Not enough credits.",
                    });
                }
            } else {
                player.activeWeapon = weaponName;
                this.updatePlayerState(socket.id, {
                    activeWeapon: player.activeWeapon,
                });
                socket.emit("actionSuccess", {
                    message: `Equipped ${weaponName}.`,
                });
            }
        });

        socket.on("buyShip", ({ shipTypeIndex }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot buy ship while hyperdrive is active.",
                });
            }
            if (shipTypeIndex < 0 || shipTypeIndex >= this.shipTypes.length) {
                return socket.emit("actionFailed", {
                    message: "Invalid ship type.",
                });
            }
            const newShipType = this.shipTypes[shipTypeIndex];
            if (player.credits < newShipType.price) {
                return socket.emit("actionFailed", {
                    message: "Not enough credits.",
                });
            }
            player.credits -= newShipType.price;
            player.type = shipTypeIndex;
            player.maxCargo = newShipType.maxCargo;
            player.cargo = new Array(this.tradeGoods.length).fill(0);
            player.maxHealth = newShipType.maxHealth || 100;
            player.health = player.maxHealth;
            this.updatePlayerState(socket.id, {
                credits: player.credits,
                type: player.type,
                maxCargo: player.maxCargo,
                cargo: player.cargo,
                maxHealth: player.maxHealth,
                health: player.health,
            });
            socket.emit("actionSuccess", {
                message: `Successfully purchased ${newShipType.name}.`,
            });
        });
    }

    checkAllPlayerMissionTimeouts(missionManager) {
        Object.values(this.players).forEach((player) => {
            if (
                player &&
                !player.destroyed &&
                player.activeMissions.length > 0
            ) {
                const { changed, completedOrFailed } =
                    missionManager.checkPlayerMissionTimeouts(player);
                if (changed) {
                    completedOrFailed.forEach((update) =>
                        this.io.to(player.id).emit("missionUpdate", update),
                    );
                    this.updatePlayerState(player.id, {
                        credits: player.credits,
                        activeMissions: player.activeMissions,
                    });
                }
            }
        });
    }

    getAllPlayers() {
        return this.players;
    }

    handlePlayerHitDuringHyperjumpCharge(playerId) {
        const player = this.getPlayer(playerId);
        if (
            player &&
            player.hyperjumpState === "charging" &&
            player.hyperjumpChargeTimeoutId
        ) {
            clearTimeout(player.hyperjumpChargeTimeoutId);
            player.hyperjumpChargeTimeoutId = null;
            player.hyperjumpState = "idle";
            this.updatePlayerState(playerId, { hyperjumpState: "idle" }); // Inform all clients
            this.io
                .to(playerId)
                .emit("hyperjumpCancelled", {
                    message: "Hyperjump disrupted by enemy fire!",
                });
            console.log(
                `Player ${playerId} hyperjump charge disrupted by damage.`,
            );
        }
    }
}

module.exports = PlayerManager;

/* ===== END: hypernova/server/modules/player_manager.js ===== */


/* ===== START: hypernova/server/modules/world_manager.js ===== */
// server/modules/world_manager.js
class WorldManager {
    constructor(io, systemsBase, tradeGoods, gameConfig) {
        this.io = io;
        this.systemsBase = systemsBase;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
        this.systems = [];
        this.economyManager = null;
        this.missionManager = null;
    }

    initialize(economyManager, missionManager) {
        this.economyManager = economyManager;
        this.missionManager = missionManager;
        this.systems = JSON.parse(JSON.stringify(this.systemsBase));

        this.systems.forEach((system) => {
            system.planets.forEach((planet) => {
                planet.stock = {};
                planet.buyPrices = {};
                planet.sellPrices = {};
                planet.availableMissions = [];
                planet.dockedShipId = null;
            });
        });

        this.economyManager.initializeAllPlanetEconomies(this.systems);
        this.missionManager.populateAllPlanetMissions(this.systems); // Pass systems here if needed by populate

        console.log("WorldManager initialized, systems processed.");
    }

    getSystem(systemIndex) {
        return this.systems[systemIndex];
    }

    getPlanet(systemIndex, planetIndex) {
        const system = this.getSystem(systemIndex);
        return system ? system.planets[planetIndex] : null;
    }

    getPlanetDetailsForDocking(systemIndex, planetIndex) {
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (planet) {
            return { x: planet.x, y: planet.y, name: planet.name };
        }
        return null;
    }

    playerDockedAtPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            console.error(
                "WorldManager.playerDockedAtPlanet: Player object is null/undefined.",
            );
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            console.error(
                `WorldManager.playerDockedAtPlanet: Planet ${planetIndex} in system ${systemIndex} not found.`,
            );
            return false;
        }

        if (planet.dockedShipId && planet.dockedShipId !== player.id) {
            console.warn(
                `WorldManager.playerDockedAtPlanet: Planet ${planet.name} is already occupied by ${planet.dockedShipId}. Player ${player.id} cannot dock.`,
            );
            return false;
        }

        if (player.dockedAtPlanetIdentifier) {
            if (
                player.dockedAtPlanetIdentifier.systemIndex !== systemIndex ||
                player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
            ) {
                this.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
        }

        planet.dockedShipId = player.id;
        console.log(
            `WorldManager: Player ${player.id} server-side DOCKED at ${planet.name} (System: ${this.systems[systemIndex].name}).`,
        );
        return true;
    }

    playerUndockedFromPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            return false;
        }

        if (planet.dockedShipId === player.id) {
            planet.dockedShipId = null;
            console.log(
                `WorldManager: Player ${player.id} server-side UNDOCKED from ${planet.name}.`,
            );
            return true;
        }
        return false;
    }

    getSystemsForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            planets: s.planets.map((p) => ({
                name: p.name,
                x: p.x,
                y: p.y,
                imageFile: p.imageFile, // Make sure imageFile is passed for client
            })),
        }));
    }

    getEconomiesForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            planets: s.planets.map((p) => ({
                name: p.name,
                stock: p.stock,
                buyPrices: p.buyPrices,
                sellPrices: p.sellPrices,
            })),
        }));
    }

    registerSocketHandlers(socket, playerManager) {
        socket.on("dock", ({ systemIndex, planetIndex }) => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });

            if (player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot dock while hyperdrive is charging.",
                });
            }

            if (player.system !== systemIndex) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Wrong system.",
                });
            }
            const planet = this.getPlanet(systemIndex, planetIndex);
            if (!planet) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Planet not found.",
                });
            }

            if (this.playerDockedAtPlanet(player, systemIndex, planetIndex)) {
                player.dockedAtPlanetIdentifier = { systemIndex, planetIndex };
                player.vx = 0;
                player.vy = 0;
                player.x = planet.x;
                player.y = planet.y;

                const missionCompletionResult =
                    this.missionManager.checkCargoMissionCompletionOnDock(
                        player,
                        systemIndex,
                        planetIndex,
                    );

                socket.emit("dockConfirmed", {
                    systemIndex,
                    planetIndex,
                    planetName: planet.name,
                    systemName: this.systems[systemIndex].name,
                    buyPrices: planet.buyPrices,
                    sellPrices: planet.sellPrices,
                    stock: planet.stock,
                    playerX: player.x,
                    playerY: player.y,
                });

                const updatesForPlayer = {
                    dockedAtPlanetIdentifier: player.dockedAtPlanetIdentifier,
                    vx: 0,
                    vy: 0,
                    x: player.x,
                    y: player.y,
                };
                if (missionCompletionResult.creditsChanged)
                    updatesForPlayer.credits = player.credits;
                if (missionCompletionResult.cargoChanged)
                    updatesForPlayer.cargo = player.cargo;
                if (missionCompletionResult.missionsChanged)
                    updatesForPlayer.activeMissions = player.activeMissions;

                playerManager.updatePlayerState(socket.id, updatesForPlayer);
            } else {
                socket.emit("actionFailed", {
                    message: "Docking failed. Planet may be occupied.",
                });
            }
        });

        socket.on("undock", () => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });
            if (!player.dockedAtPlanetIdentifier) {
                return socket.emit("actionFailed", {
                    message: "Not docked (according to server).",
                });
            }
            const { systemIndex, planetIndex } =
                player.dockedAtPlanetIdentifier;
            if (
                this.playerUndockedFromPlanet(player, systemIndex, planetIndex)
            ) {
                player.dockedAtPlanetIdentifier = null;
                socket.emit("undockConfirmed");
                playerManager.updatePlayerState(socket.id, {
                    dockedAtPlanetIdentifier: null,
                });
            } else {
                socket.emit("actionFailed", {
                    message: "Server undocking failed.",
                });
            }
        });
    }
}

module.exports = WorldManager;

/* ===== END: hypernova/server/modules/world_manager.js ===== */


/* ===== START: hypernova/server/utils/data_loader.js ===== */
const fs = require("fs").promises;
const path = require("path");

const dataDir = path.join(__dirname, "../data");

async function loadJson(filename) {
    const filePath = path.join(dataDir, filename);
    try {
        const fileContent = await fs.readFile(filePath, "utf-8");
        return JSON.parse(fileContent);
    } catch (error) {
        console.error(`Error loading data file ${filename}:`, error);
        throw error; // Or return null/empty object depending on desired error handling
    }
}

async function loadAllData() {
    try {
        const [tradeGoods, weapons, systemsBase, shipTypes] = await Promise.all(
            [
                loadJson("trade_goods.json"),
                loadJson("weapons.json"),
                loadJson("systems_init.json"),
                loadJson("ship_types.json"),
            ],
        );
        return { tradeGoods, weapons, systemsBase, shipTypes };
    } catch (error) {
        console.error("Failed to load critical game data. Exiting.", error);
        process.exit(1);
    }
}

module.exports = {
    loadAllData,
};

/* ===== END: hypernova/server/utils/data_loader.js ===== */


/* ===== START: hypernova/server/utils/helpers.js ===== */
function generateMissionId() {
    return `mission_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// Note: systemsData is the live systems array from WorldManager
function getSystemDistance(systemIndex1, systemIndex2, numSystems) {
    if (numSystems === 0) return 0;
    const diff = Math.abs(systemIndex1 - systemIndex2);
    return Math.min(diff, numSystems - diff);
}

module.exports = {
    generateMissionId,
    getSystemDistance,
};

/* ===== END: hypernova/server/utils/helpers.js ===== */
