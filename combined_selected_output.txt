/* ===== START: hypernova/client/js/game_state.js ===== */
// hypernova/client/js/game_state.js
export const gameState = {
    currentUser: null,
    socket: null,
    myId: null,
    allShips: {},
    get myShip() {
        return this.allShips[this.myId];
    },
    projectiles: [],
    loadedImages: {},
    imagePathsToLoad: [],

    // Camera/Viewport for full-screen rendering
    camera: {
        x: 0,
        y: 0,
        width: 800, // Will be updated to screen size
        height: 600, // Will be updated to screen size
        zoom: 1.0, // Future use for zooming
    },

    clientGameData: {
        systems: [], // Will be populated with data that includes universeX, universeY, connections, backgroundFile
        tradeGoods: [],
        weapons: {},
        shipTypes: [],
        MISSION_TYPES: {},
    },
    clientPlanetEconomies: [],

    docked: false,
    dockedAtDetails: null,
    isMenuOpen: false, // For docked station sub-menus
    activeSubMenu: null, // For docked station sub-menus

    selectedTradeIndex: 0,
    selectedWeaponKey: null,
    selectedShipIndex: 0,
    selectedMissionIndex: 0,
    availableMissionsForCurrentPlanet: [],

    weaponCycleIdx: 0,
    controls: {
        rotatingLeft: false,
        rotatingRight: false,
        accelerating: false,
        decelerating: false,
        firing: false, // Added for continuous fire
    },

    isChargingHyperjump: false,
    hyperjumpChargeStartTime: null,
    hyperjumpDeniedMessage: null,
    hyperjumpDeniedMessageTimeoutId: null,

    // Universe Map State
    isMapOpen: false,
    mapSelectedSystemIndex: null, // Index of the system selected on the map for single manual jump

    // ===== NEW ROUTE PLANNING STATE =====
    plannedRoute: [], // Array of system indices for the route
    currentRouteLegIndex: -1, // Index of the next system to jump to in plannedRoute
    // ===== END OF NEW ROUTE PLANNING STATE =====

    updateShipData(id, data) {
        if (!this.allShips[id]) {
            this.allShips[id] = {};
        }
        Object.assign(this.allShips[id], data);
        if (this.allShips[id]) {
            this.defaultShipProps(this.allShips[id]);
        }
    },

    defaultShipProps(ship) {
        if (!ship) return;

        const currentShipTypeData =
            this.clientGameData.shipTypes &&
            ship.type !== undefined &&
            ship.type !== null
                ? this.clientGameData.shipTypes[ship.type]
                : null;

        if (ship.system === undefined) ship.system = 0;
        if (ship.dockedAtPlanetIdentifier === undefined)
            ship.dockedAtPlanetIdentifier = null;

        if (currentShipTypeData) {
            if (ship.maxHealth === undefined)
                ship.maxHealth = currentShipTypeData.maxHealth || 100;
            if (ship.health === undefined || ship.health > ship.maxHealth)
                ship.health = ship.maxHealth;
            if (ship.maxCargo === undefined)
                ship.maxCargo = currentShipTypeData.maxCargo || 10;
            // ===== SHIELD INITIALIZATION (anticipating Step 4) =====
            if (ship.maxShield === undefined)
                ship.maxShield = currentShipTypeData.maxShield || 0; // Default to 0 if not specified
            if (ship.shield === undefined || ship.shield > ship.maxShield)
                ship.shield = ship.maxShield;
            // =========================================================
        } else {
            if (ship.maxHealth === undefined) ship.maxHealth = 100;
            if (ship.health === undefined) ship.health = 100;
            if (ship.maxCargo === undefined) ship.maxCargo = 10;
            // ===== SHIELD INITIALIZATION (anticipating Step 4) =====
            if (ship.maxShield === undefined) ship.maxShield = 0;
            if (ship.shield === undefined) ship.shield = 0;
            // =========================================================
        }


        if (ship.credits === undefined) ship.credits = 0;

        if (
            this.clientGameData.tradeGoods &&
            this.clientGameData.tradeGoods.length > 0
        ) {
            if (
                !ship.cargo ||
                ship.cargo.length !== this.clientGameData.tradeGoods.length
            ) {
                ship.cargo = new Array(
                    this.clientGameData.tradeGoods.length,
                ).fill(0);
            }
        } else if (!ship.cargo) {
            ship.cargo = [];
        }

        if (!ship.weapons) ship.weapons = [];
        if (!ship.activeWeapon && ship.weapons.length > 0)
            ship.activeWeapon = ship.weapons[0];
        if (!ship.activeMissions) ship.activeMissions = [];
    },
};
/* ===== END: hypernova/client/js/game_state.js ===== */

/* ===== START: hypernova/client/js/input_handler.js ===== */
// client/js/input_handler.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";
import { UIManager } from "./ui_manager.js";
import { UniverseMapManager } from "./universe_map_renderer.js"; // Corrected import name
import {
    // BASE_THRUST, // Not used here
    // BASE_ROTATION_SPEED, // Not used here
    DAMPING,
    DOCKING_DISTANCE_SQUARED,
    // MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED, // Used in Network.js
    // HYPERJUMP_DENIED_MESSAGE_DURATION_MS, // Used in Network.js
} from "./client_config.js";

function wrap(value, max) {
    return ((value % max) + max) % max;
}

export function initInputListeners(canvas) {
    window.addEventListener("keydown", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        const keyLower = e.key.toLowerCase();
        // Include Space in gameSpecificKeys if not already there, or handle it separately
        const gameSpecificKeys = [
            "arrowup",
            "arrowdown",
            "arrowleft",
            "arrowright",
            " ", // Ensure space is here
            "d",
            "h",
            "q",
            "e",
            "t",
            "y",
            "o",
            "m",
            "u",
            "b",
            "s",
            "a",
            "escape",
            "j",
        ];

        if (gameState.isMapOpen) {
            if (keyLower === "m" || keyLower === "escape") {
                UniverseMapManager.closeMap();
                e.preventDefault();
            }
            // Potentially add map-specific key handlers here if needed
            return;
        }

        // Prevent default for game-specific keys when not in map or input
        if (gameSpecificKeys.includes(keyLower)) {
            e.preventDefault();
        }

        if (
            gameState.hyperjumpDeniedMessage &&
            keyLower !== "h" &&
            keyLower !== "j"
        ) {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            return;
        }

        if (!gameState.docked) {
            // In-space controls
            switch (keyLower) {
                case " ": // Spacebar
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen) {
                        gameState.controls.firing = true;
                    }
                    break;
                case "arrowup":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.accelerating = true;
                    break;
                case "arrowdown":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.decelerating = true;
                    break;
                case "arrowleft":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.rotatingLeft = true;
                    break;
                case "arrowright":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.rotatingRight = true;
                    break;
                case "d":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        tryDockAction();
                    break;
                case "h":
                    // 'H' currently does nothing specific here.
                    break;
                case "j": // New: Initiate hyperjump for planned route
                    if (
                        !gameState.isMapOpen &&
                        !gameState.docked &&
                        !gameState.isChargingHyperjump &&
                        gameState.plannedRoute.length > 0 &&
                        gameState.currentRouteLegIndex !== -1 &&
                        gameState.currentRouteLegIndex <
                            gameState.plannedRoute.length
                    ) {
                        const targetSystemIndex =
                            gameState.plannedRoute[
                                gameState.currentRouteLegIndex
                            ];
                        if (targetSystemIndex !== gameState.myShip.system) {
                            Network.requestHyperjump(targetSystemIndex);
                        } else {
                            console.warn(
                                "Attempted to 'J' jump to current system. Advancing route leg.",
                            );
                            gameState.currentRouteLegIndex++;
                            if (
                                gameState.currentRouteLegIndex >=
                                gameState.plannedRoute.length
                            ) {
                                gameState.plannedRoute = [];
                                gameState.currentRouteLegIndex = -1;
                            }
                        }
                    } else if (
                        !gameState.docked &&
                        !gameState.isChargingHyperjump
                    ) {
                        if (gameState.plannedRoute.length > 0) {
                            gameState.plannedRoute = [];
                            gameState.currentRouteLegIndex = -1;
                        }
                    }
                    break;
                case "q":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        cycleWeaponAction(-1);
                    break;
                case "e":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        cycleWeaponAction(1);
                    break;
                case "m":
                    if (!gameState.docked) {
                        UniverseMapManager.toggleMap();
                    } else {
                        handleMenuKeyDown(keyLower); // For docked missions menu
                    }
                    break;
            }
        } else {
            // Docked controls
            handleMenuKeyDown(keyLower);
        }
    });

    window.addEventListener("keyup", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }
        if (gameState.isMapOpen) return;


        const keyLower = e.key.toLowerCase();
        // Reset ship movement controls if ship exists, not destroyed, and not docked
        if (gameState.myShip && !gameState.myShip.destroyed && !gameState.docked) {
            switch (keyLower) {
                case "arrowup":
                    gameState.controls.accelerating = false;
                    break;
                case "arrowdown":
                    gameState.controls.decelerating = false;
                    break;
                case "arrowleft":
                    gameState.controls.rotatingLeft = false;
                    break;
                case "arrowright":
                    gameState.controls.rotatingRight = false;
                    break;
                case " ": // Spacebar
                    gameState.controls.firing = false;
                    break;
            }
        } else { // If docked, destroyed, or no ship, ensure all controls are off
            gameState.controls.accelerating = false;
            gameState.controls.decelerating = false;
            gameState.controls.rotatingLeft = false;
            gameState.controls.rotatingRight = false;
            gameState.controls.firing = false;
        }
    });
}

function tryDockAction() {
    if (
        !gameState.myShip ||
        !gameState.clientGameData.systems[gameState.myShip.system]
    )
        return;
    const planetsInCurrentSystem =
        gameState.clientGameData.systems[gameState.myShip.system].planets;
    let nearestDistSq = Infinity,
        nearestPlanetIndex = -1;

    planetsInCurrentSystem.forEach((p, index) => {
        const planetScale = p.planetImageScale || 1.0;
        const effectiveDockingDistanceSq =
            DOCKING_DISTANCE_SQUARED * Math.pow(planetScale, 2) * 2.5;

        const d2 =
            (gameState.myShip.x - p.x) ** 2 + (gameState.myShip.y - p.y) ** 2;
        if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearestPlanetIndex = index;
        }
    });
    if (nearestPlanetIndex !== -1) {
        const planetForDocking = planetsInCurrentSystem[nearestPlanetIndex];
        const effectiveDockingDistanceSq =
            DOCKING_DISTANCE_SQUARED *
            Math.pow(planetForDocking?.planetImageScale || 1.0, 2) *
            2.5;

        if (nearestDistSq < effectiveDockingDistanceSq) {
            Network.requestDock(gameState.myShip.system, nearestPlanetIndex);
        }
    }
}

function cycleWeaponAction(direction) {
    if (
        !gameState.myShip ||
        !gameState.myShip.weapons ||
        gameState.myShip.weapons.length === 0
    )
        return;
    gameState.weaponCycleIdx =
        (gameState.weaponCycleIdx +
            direction +
            gameState.myShip.weapons.length) %
        gameState.myShip.weapons.length;
    const weaponName = gameState.myShip.weapons[gameState.weaponCycleIdx];
    Network.equipWeapon(weaponName);
}

function handleMenuKeyDown(keyLower) {
    if (!gameState.docked || !gameState.myShip) {
        return;
    }
    if (!gameState.activeSubMenu) {
        switch (keyLower) {
            case "t":
                gameState.activeSubMenu = "trade";
                gameState.selectedTradeIndex = 0;
                UIManager.renderTradeMenu();
                break;
            case "y":
                gameState.activeSubMenu = "shipyard";
                gameState.selectedShipIndex = 0;
                UIManager.renderShipyardMenu();
                break;
            case "o":
                gameState.activeSubMenu = "outfitter";
                const weaponKeysList = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (
                    !gameState.selectedWeaponKey ||
                    !weaponKeysList.includes(gameState.selectedWeaponKey)
                ) {
                    gameState.selectedWeaponKey = weaponKeysList[0] || null;
                }
                UIManager.renderOutfitterMenu();
                break;
            case "m": // This 'm' is for DOCKED missions
                gameState.activeSubMenu = "missions";
                gameState.selectedMissionIndex = 0;
                gameState.availableMissionsForCurrentPlanet = [];
                UIManager.renderMissionsMenu();
                if (gameState.dockedAtDetails) {
                    Network.requestMissions(
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                break;
            case "u":
                Network.undock();
                break;
        }
    } else {
        // We are in a sub-menu
        if (keyLower === "escape") {
            gameState.activeSubMenu = null;
            UIManager.renderDockedStationInterface();
            return;
        }
        switch (gameState.activeSubMenu) {
            case "trade":
                const numTradeGoods =
                    gameState.clientGameData.tradeGoods.length;
                if (keyLower === "arrowup")
                    gameState.selectedTradeIndex = Math.max(
                        0,
                        gameState.selectedTradeIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedTradeIndex = Math.min(
                        numTradeGoods - 1,
                        gameState.selectedTradeIndex + 1,
                    );
                else if (keyLower === "b" && numTradeGoods > 0)
                    Network.buyGood(gameState.selectedTradeIndex);
                else if (keyLower === "s" && numTradeGoods > 0)
                    Network.sellGood(gameState.selectedTradeIndex);
                UIManager.renderTradeMenu();
                break;
            case "outfitter":
                const weaponKeys = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (weaponKeys.length > 0) {
                    let currentWKeyIndex = weaponKeys.indexOf(
                        gameState.selectedWeaponKey,
                    );
                    if (currentWKeyIndex === -1 && weaponKeys.length > 0)
                        currentWKeyIndex = 0;
                    if (keyLower === "arrowup")
                        currentWKeyIndex = Math.max(0, currentWKeyIndex - 1);
                    else if (keyLower === "arrowdown")
                        currentWKeyIndex = Math.min(
                            weaponKeys.length - 1,
                            currentWKeyIndex + 1,
                        );
                    gameState.selectedWeaponKey = weaponKeys[currentWKeyIndex];
                }
                if (keyLower === "b" && gameState.selectedWeaponKey)
                    Network.equipWeapon(gameState.selectedWeaponKey);
                UIManager.renderOutfitterMenu();
                break;
            case "shipyard":
                const numShipTypes = gameState.clientGameData.shipTypes.length;
                if (keyLower === "arrowup")
                    gameState.selectedShipIndex = Math.max(
                        0,
                        gameState.selectedShipIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedShipIndex = Math.min(
                        numShipTypes - 1,
                        gameState.selectedShipIndex + 1,
                    );
                else if (keyLower === "b" && numShipTypes > 0)
                    Network.buyShip(gameState.selectedShipIndex);
                UIManager.renderShipyardMenu();
                break;
            case "missions":
                const numMissions =
                    gameState.availableMissionsForCurrentPlanet.length;
                if (keyLower === "arrowup")
                    gameState.selectedMissionIndex = Math.max(
                        0,
                        gameState.selectedMissionIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedMissionIndex = Math.min(
                        numMissions - 1,
                        gameState.selectedMissionIndex + 1,
                    );
                else if (
                    keyLower === "a" &&
                    numMissions > 0 &&
                    gameState.availableMissionsForCurrentPlanet[
                        gameState.selectedMissionIndex
                    ]
                ) {
                    const missionToAccept =
                        gameState.availableMissionsForCurrentPlanet[
                            gameState.selectedMissionIndex
                        ];
                    Network.acceptMission(
                        missionToAccept.id,
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                UIManager.renderMissionsMenu();
                break;
        }
    }
}

export function processInputs() {
    if (gameState.isMapOpen) {
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            !gameState.docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            Network.sendControls();
        }
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        gameState.controls.firing = false; // Ensure firing stops if map opens
        return;
    }

    if (!gameState.myShip || gameState.myShip.destroyed || gameState.docked) {
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            gameState.isChargingHyperjump &&
            !gameState.docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            Network.sendControls();
        }
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        gameState.controls.firing = false; // Ensure firing stops if docked/destroyed
        return;
    }

    // Continuous firing check
    if (gameState.controls.firing && !gameState.isChargingHyperjump) {
        Network.fireWeapon(); // Server will handle RPM
    }

    const myShip = gameState.myShip;
    if (
        !myShip ||
        myShip.type === undefined ||
        myShip.type === null ||
        !gameState.clientGameData.shipTypes ||
        myShip.type >= gameState.clientGameData.shipTypes.length ||
        !gameState.clientGameData.shipTypes[myShip.type]
    ) {
        return;
    }
    const shipDef = gameState.clientGameData.shipTypes[myShip.type];

    const thrust = (shipDef.speedMult || 1.0) * 0.1;
    const rotSpd = (shipDef.rotMult || 1.0) * 0.07;
    const revThrust = thrust * (shipDef.revMult || 1.0);

    if (gameState.controls.rotatingLeft) myShip.angle -= rotSpd;
    if (gameState.controls.rotatingRight) myShip.angle += rotSpd;
    myShip.angle = wrap(myShip.angle, 2 * Math.PI);

    if (gameState.controls.accelerating) {
        myShip.vx += thrust * Math.cos(myShip.angle);
        myShip.vy += thrust * Math.sin(myShip.angle);
    }
    if (gameState.controls.decelerating) {
        myShip.vx -= revThrust * Math.cos(myShip.angle);
        myShip.vy -= revThrust * Math.sin(myShip.angle);
    }

    myShip.vx *= DAMPING;
    myShip.vy *= DAMPING;

    myShip.x += myShip.vx;
    myShip.y += myShip.vy;

    Network.sendControls();
}
/* ===== END: hypernova/client/js/input_handler.js ===== */

/* ===== START: hypernova/client/js/network.js ===== */
// hypernova/client/js/network.js
import { gameState } from "./game_state.js";
import { UIManager } from "./ui_manager.js";
import {
    HYPERJUMP_DENIED_MESSAGE_DURATION_MS,
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED,
} from "./client_config.js";

export async function saveProgress() {
    // ... (existing code)
    if (!gameState.socket || !gameState.myShip || !gameState.currentUser) {
        console.warn(
            "saveProgress: Cannot save - No socket, ship, or user data.",
        );
        return;
    }
    console.log(
        `saveProgress: Preparing data. Current gameState.docked: ${gameState.docked}, dockedAtDetails being saved: ${JSON.stringify(gameState.docked ? gameState.dockedAtDetails : null)}`,
    );
    const progressData = {
        username: gameState.currentUser.username,
        shipData: {
            x: gameState.myShip.x,
            y: gameState.myShip.y,
            angle: gameState.myShip.angle,
            vx: gameState.myShip.vx,
            vy: gameState.myShip.vy,
            type: gameState.myShip.type,
            credits: gameState.myShip.credits,
            cargo: gameState.myShip.cargo,
            maxCargo: gameState.myShip.maxCargo,
            health: gameState.myShip.health,
            maxHealth: gameState.myShip.maxHealth,
            shield: gameState.myShip.shield, // Save shield
            maxShield: gameState.myShip.maxShield, // Save maxShield
            weapons: gameState.myShip.weapons,
            activeWeapon: gameState.myShip.activeWeapon,
            system: gameState.myShip.system,
            activeMissions: gameState.myShip.activeMissions,
        },
        dockedAtDetails: gameState.docked ? gameState.dockedAtDetails : null,
    };

    try {
        const response = await fetch("/save-progress", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(progressData),
        });
        const result = await response.json();
        if (response.ok && result.success) {
            console.log("saveProgress: Progress saved successfully to server.");
        } else {
            console.error(
                "saveProgress: Failed to save progress to server:",
                result.message || "Server error",
            );
        }
    } catch (error) {
        console.error(
            "saveProgress: Error during fetch to save progress:",
            error,
        );
    }
}

export function initNetwork(onReadyCallback) {
    const socket = io();
    gameState.socket = socket;

    socket.on("init", (data) => {
        console.log(
            "network.js/init: Received init data (first 200 chars):",
            JSON.stringify(data).substring(0, 200),
        );
        if (!data || !data.id || !data.gameData) {
            console.error(
                "network.js/init: Incomplete init data received from server.",
            );
            return;
        }
        gameState.myId = data.id;
        console.log("network.js/init: Set gameState.myId to:", gameState.myId);

        gameState.clientGameData.systems = data.gameData.systems || [];
        gameState.clientGameData.tradeGoods = data.gameData.tradeGoods || [];
        gameState.clientGameData.weapons = data.gameData.weapons || {};
        gameState.clientGameData.shipTypes = data.gameData.shipTypes || [];
        gameState.clientGameData.MISSION_TYPES =
            data.gameData.MISSION_TYPES || {};
        gameState.clientPlanetEconomies = data.gameData.economies || [];

        const uniqueImageFiles = new Set();
        if (gameState.clientGameData.systems) {
            gameState.clientGameData.systems.forEach((system) => {
                if (system.backgroundFile) {
                    uniqueImageFiles.add(
                        `assets/images/backgrounds/${system.backgroundFile}`,
                    );
                }
                if (system.planets) {
                    system.planets.forEach((planet) => {
                        if (planet.imageFile) {
                            uniqueImageFiles.add(
                                `assets/images/${planet.imageFile}`,
                            );
                        }
                    });
                }
            });
        }
        if (gameState.clientGameData.shipTypes) {
            gameState.clientGameData.shipTypes.forEach((shipType) => {
                if (shipType.imageFile) {
                    uniqueImageFiles.add(`assets/images/${shipType.imageFile}`);
                }
            });
        }
        gameState.imagePathsToLoad = Array.from(uniqueImageFiles);

        if (data.ships) {
            for (const shipId in data.ships) {
                gameState.updateShipData(shipId, data.ships[shipId]);
            }
        }

        if (gameState.pendingProgressToApply && gameState.myId) {
            const pendingProgress = gameState.pendingProgressToApply;
            gameState.updateShipData(gameState.myId, pendingProgress.shipData);
            if (
                gameState.myShip &&
                pendingProgress.shipData.system !== undefined
            ) {
                gameState.myShip.system = pendingProgress.shipData.system;
            }
            if (pendingProgress.dockedAtDetails) {
                gameState.docked = true;
                gameState.dockedAtDetails = pendingProgress.dockedAtDetails;
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
            }
            delete gameState.pendingProgressToApply;
        } else if (gameState.myId && !gameState.myShip) {
            // Ensure myShip object exists even if no prior data
            gameState.allShips[gameState.myId] = {}; // This creates the object
            gameState.defaultShipProps(gameState.myShip); // Then default props are applied
        }


        console.log(
            "network.js/init: Client initialization sequence complete. Final My ship type:",
            gameState.myShip ? gameState.myShip.type : "N/A",
            "Final gameState.docked:",
            gameState.docked,
        );
        if (onReadyCallback) {
            console.log("network.js/init: Calling onReadyCallback.");
            onReadyCallback();
        }
    });

    socket.on("state", (updatedShipDataMap) => {
        for (const id in updatedShipDataMap) {
            const update = updatedShipDataMap[id];
            if (id === gameState.myId) {
                if (
                    update.hyperjumpState === "idle" &&
                    gameState.isChargingHyperjump
                ) {
                    gameState.isChargingHyperjump = false;
                    gameState.hyperjumpChargeStartTime = null;
                }
            }
            gameState.updateShipData(id, update);
            if (id === gameState.myId) {
                UIManager.updateShipStatsPanel();
                UIManager.updateActiveMissionsPanel(); 
            }
        }
        if (
            gameState.myShip &&
            gameState.myShip.dockedAtPlanetIdentifier === null &&
            gameState.docked
        ) {
            UIManager.undockCleanup();
        }
    });

    socket.on("playerJoined", (data) => {
        gameState.updateShipData(data.id, data.ship);
    });

    socket.on("playerLeft", (id) => {
        delete gameState.allShips[id];
    });

    socket.on("projectile", (data) => {
        const projectileData = { ...data }; // Clone
        projectileData.startX = data.x;
        projectileData.startY = data.y;
        projectileData.startAngle = data.angle;
        projectileData.time = Date.now();
        // 'range' and 'color' are already in data from server
        gameState.projectiles.push(projectileData);
    });

    socket.on("dockConfirmed", (data) => {
        gameState.docked = true;
        if (gameState.myShip) {
            gameState.myShip.dockedAtPlanetIdentifier = {
                systemIndex: data.systemIndex,
                planetIndex: data.planetIndex,
            };
            gameState.myShip.x = data.playerX;
            gameState.myShip.y = data.playerY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
        }
        gameState.dockedAtDetails = { ...data };
        UIManager.openDockMenu(); 
        saveProgress();
    });

    socket.on("undockConfirmed", () => {
        UIManager.undockCleanup(); 
    });

    socket.on("tradeError", ({ message }) => {
        alert(`Trade Error: ${message}`);
    });
    socket.on("actionFailed", ({ message }) => {
        alert(`Action Failed: ${message}`);
    });
    socket.on("actionSuccess", ({ message }) => {
        console.log("Action Success:", message);
    });

    socket.on("tradeSuccess", (data) => {
        if (gameState.myShip) {
            gameState.myShip.credits = data.credits;
            gameState.myShip.cargo = data.cargo;
        }
        if (
            gameState.docked &&
            gameState.dockedAtDetails &&
            data.updatedPlanetData
        ) {
            Object.assign(gameState.dockedAtDetails, data.updatedPlanetData);
        }
        if (gameState.activeSubMenu === "trade") UIManager.renderTradeMenu();
        UIManager.updateShipStatsPanel(); 
    });

    socket.on("updatePlanetEconomies", (updatedSystemsEconomies) => {
        /* Not directly used client-side yet */
    });

    socket.on("planetEconomyUpdate", (data) => {
        if (
            gameState.docked &&
            gameState.dockedAtDetails &&
            gameState.dockedAtDetails.systemIndex === data.systemIndex &&
            gameState.dockedAtDetails.planetIndex === data.planetIndex
        ) {
            Object.assign(gameState.dockedAtDetails, data);
            if (gameState.activeSubMenu === "trade")
                UIManager.renderTradeMenu();
        }
    });

    socket.on("availableMissionsList", (data) => {
        gameState.availableMissionsForCurrentPlanet = data.missions;
        if (gameState.activeSubMenu === "missions")
            UIManager.renderMissionsMenu();
    });

    socket.on("missionAccepted", (data) => {
        if (gameState.myShip)
            gameState.myShip.activeMissions.push(data.mission);
        if (
            gameState.activeSubMenu === "missions" &&
            gameState.dockedAtDetails
        ) {
            const missionIdx =
                gameState.availableMissionsForCurrentPlanet.findIndex(
                    (m) => m.id === data.mission.id,
                );
            if (missionIdx > -1)
                gameState.availableMissionsForCurrentPlanet.splice(
                    missionIdx,
                    1,
                );
            UIManager.renderMissionsMenu();
        }
        UIManager.updateActiveMissionsPanel(); 
    });

    socket.on("missionUpdate", (data) => {
        if (gameState.myShip && gameState.myShip.activeMissions) {
            const missionIdx = gameState.myShip.activeMissions.findIndex(
                (m) => m.id === data.missionId,
            );
            if (missionIdx !== -1) {
                if (
                    data.status === "COMPLETED" ||
                    data.status === "FAILED_TIME"
                ) {
                    gameState.myShip.activeMissions.splice(missionIdx, 1);
                    if (data.creditsAwarded)
                        gameState.myShip.credits += data.creditsAwarded; 
                    if (data.creditsPenalized)
                        gameState.myShip.credits -= data.creditsPenalized;
                } else if (data.progress) {
                    gameState.myShip.activeMissions[
                        missionIdx
                    ].targetsDestroyed = parseInt(data.progress.split("/")[0]);
                }
            }
        }
        UIManager.updateActiveMissionsPanel(); 
        UIManager.updateShipStatsPanel(); 
        if (data.message) alert(data.message);
    });

    socket.on("hyperjumpChargeStarted", ({ chargeTime }) => {
        gameState.isChargingHyperjump = true;
        gameState.hyperjumpChargeStartTime = Date.now();
    });

    socket.on("hyperjumpDenied", ({ message }) => {
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        gameState.hyperjumpDeniedMessage = message;
        if (gameState.hyperjumpDeniedMessageTimeoutId) {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        }
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
    });

    socket.on("hyperjumpCancelled", ({ message }) => {
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        if (message) {
            gameState.hyperjumpDeniedMessage = message;
            if (gameState.hyperjumpDeniedMessageTimeoutId) {
                clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            }
            gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                gameState.hyperjumpDeniedMessage = null;
                gameState.hyperjumpDeniedMessageTimeoutId = null;
            }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        }
    });

    socket.on("hyperjumpComplete", (data) => {
        const previousSystem = gameState.myShip ? gameState.myShip.system : -1;
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;

        if (gameState.myShip) {
            gameState.myShip.system = data.newSystem;
            gameState.myShip.x = data.newX;
            gameState.myShip.y = data.newY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
            gameState.myShip.angle =
                data.newAngle !== undefined ? data.newAngle : 0;
            gameState.myShip.dockedAtPlanetIdentifier = null;
        }
        gameState.docked = false;
        UIManager.undockCleanup(); 

        if (
            gameState.plannedRoute.length > 0 &&
            gameState.currentRouteLegIndex !== -1
        ) {
            const expectedSystem =
                gameState.plannedRoute[gameState.currentRouteLegIndex];
            if (data.newSystem === expectedSystem) {
                gameState.currentRouteLegIndex++;
                if (
                    gameState.currentRouteLegIndex >=
                    gameState.plannedRoute.length
                ) {
                    console.log("Route completed.");
                    gameState.plannedRoute = [];
                    gameState.currentRouteLegIndex = -1;
                } else {
                    const nextSystemName =
                        gameState.clientGameData.systems[
                            gameState.plannedRoute[
                                gameState.currentRouteLegIndex
                            ]
                        ]?.name || "Unknown System";
                    console.log(
                        `Route advanced. Next jump: ${nextSystemName}. Press J.`,
                    );
                }
            } else {
                console.log("Jumped to an unexpected system. Clearing route.");
                gameState.plannedRoute = [];
                gameState.currentRouteLegIndex = -1;
            }
        }
    });
}

export function sendControls() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        (gameState.myShip && gameState.myShip.destroyed)
    ) {
        return;
    }
    gameState.socket.emit("control", {
        x: gameState.myShip.x,
        y: gameState.myShip.y,
        angle: gameState.myShip.angle,
        vx: gameState.myShip.vx,
        vy: gameState.myShip.vy,
        system: gameState.myShip.system,
    });
}

export function fireWeapon() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        !gameState.myShip.activeWeapon ||
        gameState.docked ||
        gameState.isChargingHyperjump ||
        gameState.isMapOpen
    ) {
        if (gameState.isMapOpen)
            console.warn("fireWeapon: Cannot fire, map is open.");
        return;
    }
    gameState.socket.emit("fire");
}

export function equipWeapon(weaponName) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        if (gameState.isChargingHyperjump)
            console.warn("equipWeapon: Cannot equip while charging hyperjump.");
        return;
    }
    gameState.socket.emit("equipWeapon", { weapon: weaponName });
}

export function requestDock(systemIndex, planetIndex) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        if (gameState.isChargingHyperjump)
            console.warn("requestDock: Cannot dock while charging hyperjump.");
        return;
    }
    gameState.socket.emit("dock", { systemIndex, planetIndex });
}

export function undock() {
    if (!gameState.socket || !gameState.docked) {
        console.warn(
            `undock: Pre-condition failed. Socket: ${!!gameState.socket}, gameState.docked: ${gameState.docked}.`,
        );
        return;
    }
    gameState.socket.emit("undock");
    saveProgress();
}

export function buyGood(goodIndex) {
    const good = gameState.clientGameData.tradeGoods[goodIndex];
    if (!good || !gameState.dockedAtDetails || !gameState.socket) return;
    gameState.socket.emit("buyGood", {
        goodName: good.name,
        quantity: 1,
        systemIndex: gameState.dockedAtDetails.systemIndex,
        planetIndex: gameState.dockedAtDetails.planetIndex,
    });
}
export function sellGood(goodIndex) {
    const good = gameState.clientGameData.tradeGoods[goodIndex];
    if (!good || !gameState.dockedAtDetails || !gameState.socket) return;
    gameState.socket.emit("sellGood", {
        goodName: good.name,
        quantity: 1,
        systemIndex: gameState.dockedAtDetails.systemIndex,
        planetIndex: gameState.dockedAtDetails.planetIndex,
    });
}
export function buyShip(shipTypeIndex) {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.isChargingHyperjump
    ) {
        if (gameState.isChargingHyperjump)
            console.warn("buyShip: Cannot buy ship while charging hyperjump.");
        return;
    }
    gameState.socket.emit("buyShip", { shipTypeIndex });
}

export function requestMissions(systemIndex, planetIndex) {
    if (!gameState.socket) return;
    gameState.socket.emit("requestMissions", { systemIndex, planetIndex });
}
export function acceptMission(missionId, systemIndex, planetIndex) {
    if (!gameState.socket) return;
    gameState.socket.emit("acceptMission", {
        missionId,
        systemIndex,
        planetIndex,
    });
}

export function requestHyperjump(targetSystemIndex = null) {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.docked ||
        gameState.isChargingHyperjump
    ) {
        let reason = "Pre-condition failed";
        if (gameState.docked) reason = "docked";
        if (gameState.isChargingHyperjump) reason = "already charging";
        if (gameState.myShip?.destroyed) reason = "ship destroyed";
        console.warn(`requestHyperjump: Cannot request. Reason: ${reason}`);

        const alertMessage = `Hyperjump denied: ${reason === "docked" ? "Cannot engage hyperdrive while docked." : reason === "already charging" ? "Hyperdrive already engaged." : reason === "ship destroyed" ? "Ship systems critical." : "Cannot engage hyperdrive."}`;
        gameState.hyperjumpDeniedMessage = alertMessage;
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }

    const currentSystemData =
        gameState.clientGameData.systems[gameState.myShip.system];
    if (currentSystemData && currentSystemData.planets) {
        for (const planet of currentSystemData.planets) {
            if (!planet) continue;
            const distSq =
                (gameState.myShip.x - planet.x) ** 2 +
                (gameState.myShip.y - planet.y) ** 2;
            const planetScale = planet.planetImageScale || 1.0;
            const baseMinJumpDistSq =
                MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED || 22500;
            const minJumpDistSq =
                baseMinJumpDistSq * Math.pow(planetScale, 2) * 1.5;

            if (distSq < minJumpDistSq) {
                gameState.hyperjumpDeniedMessage =
                    "Too close to a celestial body to engage hyperdrive.";
                if (gameState.hyperjumpDeniedMessageTimeoutId)
                    clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
                gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                    gameState.hyperjumpDeniedMessage = null;
                    gameState.hyperjumpDeniedMessageTimeoutId = null;
                }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
                return;
            }
        }
    }
    if (targetSystemIndex === null) {
        gameState.hyperjumpDeniedMessage =
            "Error: No target system selected for hyperjump.";
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }
    if (targetSystemIndex === gameState.myShip.system) {
        gameState.hyperjumpDeniedMessage = "Cannot jump to the current system.";
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }

    console.log(
        `network.js: Emitting 'requestHyperjump' for system ${targetSystemIndex}.`,
    );
    gameState.socket.emit("requestHyperjump", { targetSystemIndex });
}

export function cancelHyperjumpRequest() {
    if (!gameState.socket || !gameState.isChargingHyperjump) return;
    console.log("network.js: Emitting 'cancelHyperjump'.");
    gameState.socket.emit("cancelHyperjump");
}
/* ===== END: hypernova/client/js/network.js ===== */

/* ===== START: hypernova/client/js/renderer.js ===== */
// hypernova/client/js/renderer.js
import { gameState } from "./game_state.js";
import {
    PROJECTILE_LIFESPAN_MS,
    DOCKING_DISTANCE_SQUARED,
    HYPERJUMP_CHARGE_TIME_MS,
} from "./client_config.js";

let ctx = null;
let canvas = null;
let minimapCanvas = null; 
let minimapCtx = null;
let initialized = false;

const PARALLAX_LAYERS = [
    {
        speed: 0.05,
        stars: [],
        starDensity: 0.000015,
        minStarSize: 0.2,
        maxStarSize: 0.7,
        opacity: 0.4,
    }, 
    {
        speed: 0.15,
        stars: [],
        starDensity: 0.00003,
        minStarSize: 0.4,
        maxStarSize: 1.0,
        opacity: 0.6,
    },
    {
        speed: 0.35,
        stars: [],
        starDensity: 0.00005,
        minStarSize: 0.6,
        maxStarSize: 1.5,
        opacity: 0.8,
    },
];

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}

function generateParallaxStars() {
    if (!canvas) return;
    PARALLAX_LAYERS.forEach((layer) => {
        layer.stars = [];
        const numStars = Math.floor(
            canvas.width * canvas.height * layer.starDensity,
        );
        for (let i = 0; i < numStars; i++) {
            layer.stars.push({
                x: Math.random() * canvas.width * 3 - canvas.width, 
                y: Math.random() * canvas.height * 3 - canvas.height,
                radius: getRandom(layer.minStarSize, layer.maxStarSize),
                opacity: getRandom(layer.opacity * 0.5, layer.opacity),
            });
        }
    });
}

export const Renderer = {
    init(mainCanvasElement) {
        canvas = mainCanvasElement;
        ctx = canvas.getContext("2d");

        minimapCanvas = document.getElementById("minimapCanvas");
        if (minimapCanvas) {
            minimapCtx = minimapCanvas.getContext("2d");
            minimapCanvas.width = minimapCanvas.clientWidth;
            minimapCanvas.height = minimapCanvas.clientHeight;
        } else {
            console.warn("Minimap canvas not found!");
        }

        gameState.camera.width = canvas.width;
        gameState.camera.height = canvas.height;
        generateParallaxStars();
        initialized = true;
        console.log(
            "Renderer initialized with canvas:",
            canvas.width,
            "x",
            canvas.height,
        );
    },

    isInitialized() {
        return initialized;
    },

    updateViewPort(width, height) {
        generateParallaxStars();

        if (minimapCanvas) {
            minimapCanvas.width = minimapCanvas.clientWidth;
            minimapCanvas.height = minimapCanvas.clientHeight;
        }
        console.log("Renderer viewport updated:", width, "x", height);
    },

    drawSystemBackground() {
        if (!gameState.myShip || gameState.myShip.system === undefined) {
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        const systemData =
            gameState.clientGameData.systems[gameState.myShip.system];
        if (systemData && systemData.backgroundFile) {
            const bgImg = gameState.loadedImages[systemData.backgroundFile];
            if (bgImg) {
                const camX = gameState.camera.x;
                const camY = gameState.camera.y;
                const parallaxFactor = 0.1; 

                const imgWidth = bgImg.width;
                const imgHeight = bgImg.height;

                const startX =
                    Math.floor((camX * parallaxFactor) / imgWidth) * imgWidth;
                const startY =
                    Math.floor((camY * parallaxFactor) / imgHeight) * imgHeight;

                ctx.save();
                ctx.translate(
                    -(camX * parallaxFactor),
                    -(camY * parallaxFactor),
                );
                for (
                    let x = startX - imgWidth;
                    x <
                    startX + canvas.width / (1 - parallaxFactor) + imgWidth * 2;
                    x += imgWidth
                ) {
                    for (
                        let y = startY - imgHeight;
                        y <
                        startY +
                            canvas.height / (1 - parallaxFactor) +
                            imgHeight * 2;
                        y += imgHeight
                    ) {
                        ctx.drawImage(bgImg, x, y, imgWidth, imgHeight);
                    }
                }
                ctx.restore();
            } else {
                ctx.fillStyle = systemData.fallbackColor || "#010205"; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        this.drawParallaxStars(); 
    },

    drawParallaxStars() {
        const camX = gameState.camera.x;
        const camY = gameState.camera.y;

        PARALLAX_LAYERS.forEach((layer) => {
            ctx.beginPath();
            layer.stars.forEach((star) => {
                const parallaxX = star.x - camX * layer.speed;
                const parallaxY = star.y - camY * layer.speed;
                const wrapWidth = canvas.width + canvas.width / layer.speed; 
                const wrapHeight = canvas.height + canvas.height / layer.speed;

                let screenX = parallaxX % wrapWidth;
                if (screenX < 0) screenX += wrapWidth;
                screenX %= canvas.width; 

                let screenY = parallaxY % wrapHeight;
                if (screenY < 0) screenY += wrapHeight;
                screenY %= canvas.height;

                ctx.moveTo(screenX + star.radius, screenY); 
                ctx.arc(screenX, screenY, star.radius, 0, Math.PI * 2);
            });
            ctx.fillStyle = `rgba(255, 255, 240, ${layer.opacity})`;
            ctx.fill();
        });
    },

    draw() {
        if (!ctx || !initialized) return;
        if (!gameState.myShip) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }

        this.drawSystemBackground();

        ctx.save();
        ctx.translate(-gameState.camera.x, -gameState.camera.y);

        if (gameState.myShip.system !== undefined) {
            const currentSystemData =
                gameState.clientGameData.systems[gameState.myShip.system];
            if (currentSystemData && currentSystemData.planets) {
                currentSystemData.planets.forEach((p) => this.drawPlanet(p));
            }

            const now = Date.now();
            gameState.projectiles = gameState.projectiles.filter(
                (p) => now - (p.time || 0) < PROJECTILE_LIFESPAN_MS,
            );
            gameState.projectiles.forEach((p) => this.drawProjectile(p));

            for (const id in gameState.allShips) {
                const ship = gameState.allShips[id];
                if (!ship || ship.system !== gameState.myShip.system) continue;
                this.drawShip(ship);

                if (
                    id !== gameState.myId &&
                    !ship.destroyed &&
                    ship.type !== undefined
                ) {
                    const shipDef =
                        gameState.clientGameData.shipTypes[ship.type];
                    const shipRenderScale = shipDef.scale || 1.0;
                    const labelOffset =
                        shipDef && shipDef.imgHeight
                            ? (shipDef.imgHeight / 2) * shipRenderScale + 10
                            : 25;
                    ctx.fillStyle = ship.color || "#0f0";
                    ctx.font = "12px monospace";
                    ctx.textAlign = "center";
                    const displayName = ship.username || id.substring(0, 6);
                    ctx.fillText(displayName, ship.x, ship.y - labelOffset);
                    ctx.textAlign = "left";
                }
            }
        }
        ctx.restore();
        this.drawHUD();
    },

    drawPlanet(planet) {
        const img = gameState.loadedImages[planet.imageFile];
        const BASE_PLANET_RENDER_SIZE = 128;
        const scale = planet.planetImageScale || 1.0;
        const renderSize = BASE_PLANET_RENDER_SIZE * scale;

        if (img) {
            ctx.save();
            ctx.drawImage(
                img,
                planet.x - renderSize / 2,
                planet.y - renderSize / 2,
                renderSize,
                renderSize,
            );
            ctx.globalCompositeOperation = "lighter"; 
            const glowRadius = renderSize * 0.65; 
            const gradient = ctx.createRadialGradient(
                planet.x,
                planet.y,
                renderSize * 0.48, 
                planet.x,
                planet.y,
                glowRadius, 
            );
            gradient.addColorStop(0, `rgba(120, 170, 255, 0.25)`); 
            gradient.addColorStop(0.7, `rgba(120, 170, 255, 0.1)`);
            gradient.addColorStop(1, `rgba(120, 170, 255, 0)`); 
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = "source-over"; 
            ctx.restore();
        } else {
            ctx.fillStyle = planet.fallbackColor || "#335577";
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, renderSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = "#E0E8FF";
        ctx.font = `${Math.max(10, 12 * scale)}px monospace`; 
        ctx.textAlign = "center";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 2;
        ctx.fillText(
            planet.name,
            planet.x,
            planet.y + renderSize / 2 + Math.max(12, 15 * scale), 
        );
        ctx.shadowBlur = 0;
        ctx.textAlign = "left";
    },

    drawShip(ship) {
        if (ship.destroyed || ship.type === undefined) return;
        const shipTypeDefinition =
            gameState.clientGameData.shipTypes[ship.type];
        if (!shipTypeDefinition) return;

        const img = gameState.loadedImages[shipTypeDefinition.imageFile];
        const shipScale = shipTypeDefinition.scale || 1.0;

        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        if (img) {
            const w = (shipTypeDefinition.imgWidth || img.width) * shipScale;
            const h = (shipTypeDefinition.imgHeight || img.height) * shipScale;
            ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
            ctx.fillStyle = ship.color || "#0f0";
            ctx.beginPath();
            ctx.moveTo(15 * shipScale, 0);
            ctx.lineTo(-10 * shipScale, 8 * shipScale);
            ctx.lineTo(-10 * shipScale, -8 * shipScale);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    },

    drawProjectile(p) {
        const elapsedTime = (Date.now() - p.time) / 1000.0; // Time in seconds
        // Projectile speed determined by its range and lifespan
        const projectileDisplaySpeed = p.range / (PROJECTILE_LIFESPAN_MS / 1000.0);
        const distanceTravelled = projectileDisplaySpeed * elapsedTime;

        // Current position of the projectile's tip
        const currentX = p.startX + Math.cos(p.startAngle) * distanceTravelled;
        const currentY = p.startY + Math.sin(p.startAngle) * distanceTravelled;

        // Define projectile visual length (e.g. 1/10th of its range, or a fixed size)
        const visualLength = Math.min(20, p.range / 5); // Cap visual length
        const projectileWidth = 3; // Thickness of the bolt

        ctx.save();
        // Translate to the current tip of the projectile
        ctx.translate(currentX, currentY);
        ctx.rotate(p.startAngle); // Rotate to the projectile's direction

        // Draw the projectile shape (e.g., a rectangle/thick line)
        // The shape will be drawn extending "backwards" from its current tip position
        // because we translated to the tip.
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 7;

        // Draw as a rectangle (bolt)
        // Origin is at (0,0) which is the tip. Draw backwards.
        ctx.fillRect(-visualLength, -projectileWidth / 2, visualLength, projectileWidth);

        // Rounded ends for the bolt:
        // ctx.beginPath();
        // ctx.moveTo(-visualLength + projectileWidth / 2, 0); // Start of line segment
        // ctx.lineTo(0 - projectileWidth / 2, 0); // End of line segment (just before tip circle)
        // ctx.lineWidth = projectileWidth;
        // ctx.strokeStyle = p.color;
        // ctx.lineCap = "round";
        // ctx.stroke();

        ctx.restore();
    },

    drawHUD() {
        ctx.font = "14px monospace";
        ctx.fillStyle = "#00FF00";

        if (
            gameState.hyperjumpDeniedMessage &&
            !gameState.isChargingHyperjump
        ) {
            ctx.fillStyle = "red";
            ctx.font = "16px monospace";
            const messageWidth = ctx.measureText(
                gameState.hyperjumpDeniedMessage,
            ).width;
            ctx.fillText(
                gameState.hyperjumpDeniedMessage,
                canvas.width / 2 - messageWidth / 2,
                canvas.height - 60,
            );
            ctx.fillStyle = "#00FF00"; 
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            ctx.fillStyle = "red";
            ctx.font = "24px monospace";
            const msg = "SHIP DESTROYED - AWAITING RESPAWN";
            ctx.textAlign = "center";
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = "left";
            return;
        }

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return; 

        let cargoCount =
            myShip.cargo && myShip.cargo.length > 0
                ? myShip.cargo.reduce((s, v) => s + v, 0)
                : 0;

        const hudPadding = 15;
        ctx.textAlign = "left";
        ctx.fillText(
            `Pilot: ${gameState.currentUser.username}`,
            hudPadding,
            hudPadding + 14,
        );
        ctx.fillText(
            `Credits: $${myShip.credits.toLocaleString()}`,
            hudPadding,
            hudPadding + 32,
        );
        ctx.fillText( // Shield display will be added here in next phase
            `Health: ${myShip.health || 0}/${myShip.maxHealth || 0}`,
            hudPadding,
            hudPadding + 50, // Adjust Y if shields are added above
        );
        ctx.fillText(
            `Cargo: ${cargoCount}/${currentShipDef.maxCargo}`,
            hudPadding,
            hudPadding + 68, // Adjust Y
        );

        const systemName =
            gameState.clientGameData.systems[myShip.system]?.name ||
            "Unknown System";
        ctx.fillText(`System: ${systemName}`, hudPadding, hudPadding + 86); // Adjust Y

        if (myShip.activeWeapon) {
            const weaponDisplayName =
                gameState.clientGameData.weapons[myShip.activeWeapon]?.name ||
                myShip.activeWeapon;
            ctx.fillText(
                `Weapon: ${weaponDisplayName}`,
                hudPadding,
                hudPadding + 104, // Adjust Y
            );
        }

        let hudNextY = hudPadding + 138; // Adjust Y
        if (myShip.activeMissions && myShip.activeMissions.length > 0) {
            ctx.fillText("Active Missions:", hudPadding, hudNextY);
            hudNextY += 18;
            myShip.activeMissions.slice(0, 3).forEach((mission) => {
                let missionText =
                    mission.title.length > 40
                        ? mission.title.substring(0, 37) + "..."
                        : mission.title;
                if (
                    mission.type ===
                    gameState.clientGameData.MISSION_TYPES.BOUNTY
                ) {
                    missionText += ` (${mission.targetsDestroyed || 0}/${mission.targetsRequired})`;
                }
                const timeRemainingMin = Math.max(
                    0,
                    Math.round((mission.timeLimit - Date.now()) / 60000),
                );
                missionText += ` (${timeRemainingMin}m)`;
                ctx.fillText(`- ${missionText}`, hudPadding + 5, hudNextY);
                hudNextY += 18;
            });
        }

        if (
            gameState.isChargingHyperjump &&
            gameState.hyperjumpChargeStartTime
        ) {
            const chargeProgress = Math.min(
                1,
                (Date.now() - gameState.hyperjumpChargeStartTime) /
                    HYPERJUMP_CHARGE_TIME_MS,
            );
            ctx.fillStyle = "#0af";
            ctx.font = "18px monospace";
            const chargeText = `Hyperdrive Charging: ${Math.round(chargeProgress * 100)}%`;
            const textWidth = ctx.measureText(chargeText).width;
            ctx.textAlign = "center";
            ctx.fillText(chargeText, canvas.width / 2, canvas.height - 80);

            const barWidth = 250;
            const barHeight = 15;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height - 60;

            ctx.strokeStyle = "#0af";
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.fillRect(
                barX + 2,
                barY + 2,
                (barWidth - 4) * chargeProgress,
                barHeight - 4,
            );
            ctx.fillStyle = "#00FF00"; 
            ctx.lineWidth = 1; 
            ctx.textAlign = "left"; 
        }

        let messageDisplayedAtBottom = false; 
        if (
            gameState.plannedRoute.length > 0 &&
            gameState.currentRouteLegIndex !== -1 &&
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            if (
                gameState.currentRouteLegIndex < gameState.plannedRoute.length
            ) {
                const nextDestSystemIndex =
                    gameState.plannedRoute[gameState.currentRouteLegIndex];
                const nextDestSystem =
                    gameState.clientGameData.systems[nextDestSystemIndex];
                if (nextDestSystem) {
                    ctx.font = "16px monospace";
                    ctx.fillStyle = "#FFA500"; 
                    const routeMsg = `Next Jump (J): ${nextDestSystem.name}`;
                    ctx.textAlign = "center";
                    ctx.fillText(
                        routeMsg,
                        canvas.width / 2,
                        canvas.height - 30,
                    );
                    messageDisplayedAtBottom = true;
                }
            } else {
                ctx.font = "16px monospace";
                ctx.fillStyle = "#00FF00";
                const routeMsg =
                    "Route complete. Press J to clear or plot new.";
                ctx.textAlign = "center";
                ctx.fillText(routeMsg, canvas.width / 2, canvas.height - 30);
                messageDisplayedAtBottom = true;
            }
            ctx.textAlign = "left";
            ctx.fillStyle = "#00FF00";
        }

        if (
            !messageDisplayedAtBottom &&
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            const planets =
                gameState.clientGameData.systems[myShip.system]?.planets;
            let canDock = false,
                dockPlanetName = "";
            if (planets) {
                planets.forEach((p) => {
                    const interactionRadiusSq =
                        DOCKING_DISTANCE_SQUARED *
                        Math.pow(p.planetImageScale || 1.0, 2) *
                        2;
                    if (
                        (myShip.x - p.x) ** 2 + (myShip.y - p.y) ** 2 <
                        interactionRadiusSq
                    ) {
                        canDock = true;
                        dockPlanetName = p.name;
                    }
                });
            }
            if (canDock) {
                ctx.font = "16px monospace";
                const dockMsg = `Press 'D' to dock at ${dockPlanetName}`;
                ctx.textAlign = "center";
                ctx.fillText(dockMsg, canvas.width / 2, canvas.height - 30);
                messageDisplayedAtBottom = true; 
            }
            ctx.textAlign = "left"; 
        }
    },

    drawMinimap() {
        if (
            !minimapCtx ||
            !minimapCanvas ||
            !gameState.myShip ||
            gameState.myShip.system === undefined
        ) {
            if (minimapCtx) {
                minimapCtx.fillStyle = "#05080a";
                minimapCtx.fillRect(
                    0,
                    0,
                    minimapCanvas.width,
                    minimapCanvas.height,
                );
            }
            return;
        }

        minimapCtx.fillStyle = "#05080a"; 
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

        const currentSystemData =
            gameState.clientGameData.systems[gameState.myShip.system];
        if (!currentSystemData || !currentSystemData.planets) return;

        let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
        currentSystemData.planets.forEach((p) => {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
        });
        if (gameState.myShip.x < minX) minX = gameState.myShip.x;
        if (gameState.myShip.x > maxX) maxX = gameState.myShip.x;
        if (gameState.myShip.y < minY) minY = gameState.myShip.y;
        if (gameState.myShip.y > maxY) maxY = gameState.myShip.y;

        const systemWidth = Math.max(500, maxX - minX); 
        const systemHeight = Math.max(500, maxY - minY);
        const systemCenterX = minX + systemWidth / 2;
        const systemCenterY = minY + systemHeight / 2;

        const mapPadding = 10; 
        const mapDrawableWidth = minimapCanvas.width - 2 * mapPadding;
        const mapDrawableHeight = minimapCanvas.height - 2 * mapPadding;

        const scaleX = mapDrawableWidth / systemWidth;
        const scaleY = mapDrawableHeight / systemHeight;
        const scale = Math.min(scaleX, scaleY) * 0.9; 

        minimapCtx.save();
        minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2); 

        currentSystemData.planets.forEach((p) => {
            const mapX = (p.x - systemCenterX) * scale;
            const mapY = (p.y - systemCenterY) * scale;
            const planetRadius = (p.planetImageScale || 1.0) * 3 * scale + 2; 

            minimapCtx.fillStyle = p.fallbackColor || "#557799";
            minimapCtx.beginPath();
            minimapCtx.arc(
                mapX,
                mapY,
                Math.max(2, planetRadius),
                0,
                Math.PI * 2,
            );
            minimapCtx.fill();

            minimapCtx.fillStyle = "#ccc";
            minimapCtx.font = `${Math.max(6, 8 * scale)}px monospace`;
            minimapCtx.textAlign = "center";
            minimapCtx.fillText(
                p.name.substring(0, 3),
                mapX,
                mapY + planetRadius + 8 * scale,
            );
        });

        const playerMapX = (gameState.myShip.x - systemCenterX) * scale;
        const playerMapY = (gameState.myShip.y - systemCenterY) * scale;
        minimapCtx.fillStyle = "#00FF00"; 
        minimapCtx.save();
        minimapCtx.translate(playerMapX, playerMapY);
        minimapCtx.rotate(gameState.myShip.angle);
        const playerSize = Math.max(2, 4 * scale);
        minimapCtx.beginPath();
        minimapCtx.moveTo(playerSize, 0);
        minimapCtx.lineTo(-playerSize / 2, -playerSize / 1.5);
        minimapCtx.lineTo(-playerSize / 2, playerSize / 1.5);
        minimapCtx.closePath();
        minimapCtx.fill();
        minimapCtx.restore();

        minimapCtx.restore(); 
    },
};
/* ===== END: hypernova/client/js/renderer.js ===== */