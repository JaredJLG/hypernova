

/* ===== START: hypernova/client/index.html ===== */
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HyperNova OS Boot</title>
        <link rel="stylesheet" href="css/style.css" />
    </head>
    <body>
        <div id="login-screen">
            <canvas id="login-background-canvas"></canvas>

            <div id="login-vfx-container">
                <div class="scanline"></div>
            </div>
            <div class="login-form-container">
                <h2 class="glitch" data-text="SYSTEM ACCESS">SYSTEM ACCESS</h2>
                <form id="login-form">
                    <div>
                        <label for="username">PILOT ID:</label>
                        <input
                            type="text"
                            id="username"
                            name="username"
                            required
                            placeholder="Enter Callsign"
                        />
                    </div>
                    <div>
                        <label for="password">PASSCODE:</label>
                        <input
                            type="password"
                            id="password"
                            name="password"
                            required
                            placeholder="Enter Secure Key"
                        />
                    </div>
                    <button type="submit" class="cybr-btn">
                        Engage
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </button>
                </form>
                <p id="login-error" class="login-feedback"></p>
                <p id="login-message" class="login-feedback"></p>
                <div class="footer-text">HyperNova Secure Terminal v2.7.3</div>
            </div>
        </div>

        <div id="game-container" class="hidden">
            {/* This container will be made full-screen */ }
            <canvas id="gameCanvas"></canvas> {/* This canvas will be resized by
            JS */}
            <div id="ui"></div>
            {/* UI remains an overlay for menus */} {/* ===== NEW RIGHT HUD
            PANEL ===== */}
            <div id="right-hud-panel" class="hidden">
                <div class="panel-section" id="ship-stats-section">
                    <h4>PILOT STATUS</h4>
                    <div id="ship-stats-content">
                        {/*
                        <!-- Ship stats will be populated by JS -->
                        */}
                    </div>
                </div>
                <div class="panel-section" id="active-missions-section">
                    <h4>MISSION LOG</h4>
                    <ul id="active-missions-list">
                        {/*
                        <!-- Active missions will be populated by JS -->
                        */}
                    </ul>
                </div>
                <div class="panel-section" id="minimap-section">
                    <h4>SYSTEM MAP</h4>
                    <canvas id="minimapCanvas"></canvas>
                </div>
                <div class="panel-footer">HN OS v3.1</div>
            </div>
            {/* ===== END OF NEW RIGHT HUD PANEL ===== */} {/* ===== NEW
            UNIVERSE MAP CONTAINER ===== */}
            <div id="universe-map-container" class="hidden">
                <canvas id="universeMapCanvas"></canvas>
                {/* Buttons for the map will be drawn on canvas */}
            </div>
            {/* ===== END OF NEW UNIVERSE MAP CONTAINER ===== */}
        </div>

        <audio id="login-music" loop>
            <source
                src="assets/audio/upbeat-space-theme.mp3"
                type="audio/mpeg"
            />
            Your browser does not support the audio element.
        </audio>

        <script src="/socket.io/socket.io.js"></script>
        <script type="module" src="js/main.js"></script>
    </body>
</html>


/* ===== END: hypernova/client/index.html ===== */


/* ===== START: hypernova/client/css/style.css ===== */
/* ===== START: hypernova/client/css/style.css ===== */
/* Existing styles from your file */
body {
  margin: 0;
  background-color: #000; /* Fallback for body */
  color: #00FF00;
  font-family: 'Courier New', Courier, monospace;
  overflow: hidden; /* Critical for full-screen */
}

#game-container {
    position: fixed; /* Take up full viewport */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000; /* Background of the container if canvas doesn't fill it */
}

#gameCanvas {
  display: block;
  /* background: #000; */ /* Background will be drawn by renderer now */
  /* Width and height will be set by JavaScript */
  position: absolute;
  top: 0;
  left: 0;
}

#ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10; /* Ensure UI is above game canvas */
}
/* .panel class is no longer primarily used for docked menus, but kept for potential other uses or if sub-menus revert styling */
.panel {
  position: absolute;
  background: rgba(0, 20, 30, 0.85);
  border: 1px solid rgba(0, 200, 255, 0.5);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
  padding: 15px;
  max-width: 520px;
  pointer-events: auto;
  color: #99FFFF;
  font-family: inherit;
  border-radius: 5px;
  /* Centering for old panel style if used */
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
}


button {
  background: rgba(0, 100, 150, 0.6);
  color: #66FFFF;
  border: 1px solid #00AACC;
  padding: 8px 15px;
  margin: 5px;
  pointer-events: auto;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 1px;
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.2s, box-shadow 0.2s;
}
button:hover {
    background: rgba(0, 150, 200, 0.8);
    box-shadow: 0 0 8px rgba(0, 200, 255, 0.5);
}


::selection {
  background: #0f0;
  color: #000;
}
/* .trade-item-selected and .menu-item might be deprecated if not used by new sub-menu style */
.trade-item-selected {
  background-color: rgba(0, 100, 100, 0.3);
  border-left: 2px solid #00f2ea;
}
.menu-item {
  padding: 4px 2px;
}
.menu-item div {
  padding: 2px 0;
}
body.no-scroll {
  overflow: hidden;
}

/* ===== HYPER COOL SCI-FI LOGIN SCREEN STYLES ===== */

#login-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', Courier, monospace;
    overflow: hidden;
    background-color: #000000;
    color: #00FF00;
}

#login-background-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
}

#login-vfx-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}

.scanline {
    width: 100%;
    height: 100px;
    position: absolute;
    top: -100px;
    left: 0;
    background: linear-gradient(
        to bottom,
        rgba(20, 100, 200, 0),
        rgba(50, 150, 255, 0.08) 40%,
        rgba(50, 150, 255, 0.12) 50%,
        rgba(50, 150, 255, 0.08) 60%,
        rgba(20, 100, 200, 0)
    );
    animation: scan 7s linear infinite;
    opacity: 0.6;
}

@keyframes scan {
    0% { top: -100px; }
    100% { top: 100%; }
}

.login-form-container {
    position: relative;
    z-index: 2;
    background: rgba(5, 15, 30, 0.85);
    padding: 30px 40px;
    border-radius: 8px;
    border: 1px solid rgba(0, 255, 255, 0.3);
    box-shadow: 0 0 25px rgba(0, 200, 255, 0.3),
                inset 0 0 15px rgba(0, 150, 200, 0.2);
    text-align: center;
    width: 380px;
    animation: fadeInForm 1s ease-out forwards;
}

@keyframes fadeInForm {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

#login-screen h2 {
    font-size: 2em;
    color: #66FFFF;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 30px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    padding-bottom: 15px;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}

.glitch {
    position: relative;
    color: #66FFFF;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}
.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: inherit;
    overflow: hidden;
}
.glitch::before {
    left: 2px;
    text-shadow: -1px 0 red;
    animation: glitch-anim-1 2s infinite linear alternate-reverse;
}
.glitch::after {
    left: -2px;
    text-shadow: -1px 0 blue, 2px 2px yellow;
    animation: glitch-anim-2 2s infinite linear alternate-reverse;
}

@keyframes glitch-anim-1 {
    0% { clip: rect(35px, 9999px, 92px, 0); }
    25% { clip: rect(32px, 9999px, 1px, 0); }
    50% { clip: rect(45px, 9999px, 36px, 0); }
    75% { clip: rect(11px, 9999px, 5px, 0); }
    100% { clip: rect(62px, 9999px, 77px, 0); }
}
@keyframes glitch-anim-2 {
    0% { clip: rect(70px, 9999px, 10px, 0); }
    25% { clip: rect(3px, 9999px, 48px, 0); }
    50% { clip: rect(90px, 9999px, 50px, 0); }
    75% { clip: rect(22px, 9999px, 79px, 0); }
    100% { clip: rect(5px, 9999px, 60px, 0); }
}


#login-form div {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

#login-form label {
    display: block;
    width: auto;
    margin-right: 0;
    margin-bottom: 8px;
    color: #00AACC;
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: left;
}

#login-form input[type="text"],
#login-form input[type="password"] {
    background-color: rgba(0, 50, 70, 0.5);
    border: 1px solid #007799;
    color: #99FFFF;
    padding: 12px 15px;
    font-family: inherit;
    border-radius: 4px;
    width: calc(100% - 30px);
    box-shadow: inset 0 0 8px rgba(0, 100, 150, 0.3);
    transition: border-color 0.3s, box-shadow 0.3s;
    caret-color: #66FFFF;
}

#login-form input[type="text"]::placeholder,
#login-form input[type="password"]::placeholder {
    color: #007799;
    opacity: 0.7;
}

#login-form input[type="text"]:focus,
#login-form input[type="password"]:focus {
    outline: none;
    border-color: #66FFFF;
    box-shadow: 0 0 10px rgba(102, 255, 255, 0.5),
                inset 0 0 10px rgba(102, 255, 255, 0.3);
}

/* ===== NEW FANCY SCI-FI ENGAGE BUTTON ===== */
.cybr-btn {
    --btn-color-primary: #00f2ea; /* Bright Teal/Cyan */
    --btn-color-secondary: #7DF9FF; /* Electric Blue / Lighter Cyan */
    --btn-glow-color: rgba(0, 242, 234, 0.5);
    --btn-bg-color: rgba(10, 30, 50, 0.6); /* Slightly transparent dark blue */
    --btn-border-size: 2px;

    position: relative;
    padding: 12px 30px;
    margin-top: 25px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 1.1em;
    font-weight: bold;
    color: var(--btn-color-primary);
    background-color: var(--btn-bg-color);
    border: var(--btn-border-size) solid var(--btn-color-primary);
    border-radius: 5px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    cursor: pointer;
    outline: none;
    overflow: hidden;
    transition: color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    z-index: 1;
}

.cybr-btn::before,
.cybr-btn::after {
    content: '';
    position: absolute;
    width: 0;
    height: var(--btn-border-size);
    background-color: var(--btn-color-secondary);
    transition: width 0.4s ease-out;
    z-index: -1;
}

.cybr-btn::before {
    top: 0;
    left: 50%;
    transform: translateX(-50%);
}

.cybr-btn::after {
    bottom: 0;
    right: 50%;
    transform: translateX(50%);
}

.cybr-btn:hover::before,
.cybr-btn:hover::after {
    width: 105%;
}

.cybr-btn span[aria-hidden="true"] {
    display: block;
    position: absolute;
    width: var(--btn-border-size);
    height: 0%;
    background-color: var(--btn-color-secondary);
    opacity: 0;
    transition: height 0.4s ease-out 0.2s, opacity 0.3s ease-out 0.2s;
}

.cybr-btn span[aria-hidden="true"]:first-of-type {
    top: 50%;
    left: 0;
    transform: translateY(-50%);
}

.cybr-btn span[aria-hidden="true"]:nth-of-type(2) {
    bottom: 50%;
    right: 0;
    transform: translateY(50%);
}

.cybr-btn:hover span[aria-hidden="true"] {
    height: 105%;
    opacity: 1;
}

.cybr-btn:hover {
    color: #ffffff;
    background-color: rgba(0, 242, 234, 0.15);
    border-color: var(--btn-color-secondary);
    box-shadow: 0 0 15px var(--btn-glow-color), 0 0 25px var(--btn-glow-color);
}

.cybr-btn:active {
    color: var(--btn-color-primary);
    background-color: rgba(0, 242, 234, 0.25);
    box-shadow: 0 0 5px var(--btn-glow-color), inset 0 0 10px var(--btn-glow-color);
    transform: translateY(1px);
}
/* ===== END OF NEW BUTTON STYLES ===== */


#login-error, #login-message {
    margin-top: 20px;
    min-height: 1.2em;
    font-size: 0.9em;
    letter-spacing: 0.5px;
}
#login-error {
    color: #FF6666;
    text-shadow: 0 0 5px #FF6666;
}
#login-message {
    color: #66FF99;
    text-shadow: 0 0 5px #66FF99;
}
.login-feedback {
    opacity: 0;
    transition: opacity 0.5s;
}
.login-feedback:not(:empty) {
    opacity: 1;
}


.footer-text { /* General footer text for login */
    margin-top: 30px;
    font-size: 0.75em;
    color: rgba(0, 255, 255, 0.4);
    letter-spacing: 1px;
}


.hidden {
    display: none !important;
}

/* Universe Map Specific (if ever HTML based, good to have a placeholder) */
.universe-map-container { } /* Keep for potential future HTML map elements */
.system-entry { }

/* ===== NEW DOCKED STATION UI STYLES ===== */
#docked-station-ui {
    position: fixed; /* Changed from absolute to fixed if #ui container is not full screen */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 800px;
    height: 600px;
    background-color: #1a1a1e;
    border: 3px solid #4a4e54;
    box-shadow: 0 0 20px rgba(0,0,0,0.7);
    color: #c0c0c0;
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    padding: 15px;
    box-sizing: border-box;
    pointer-events: auto;
    z-index: 20;
}

.station-viewscreen {
    background-color: #08080a;
    border: 2px solid #333;
    height: 180px; /* Adjusted height */
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    font-size: 1.2em;
    color: #50a0f0;
}

.station-dialogue-area {
    background-color: #111315;
    border: 1px solid #333;
    padding: 10px 15px; /* Adjusted padding */
    margin-bottom: 10px;
    font-size: 0.9em;
    min-height: 50px; /* Adjusted height */
    line-height: 1.4;
}

.station-dialogue-area button {
    display: block;
    margin: 8px auto 0; /* Adjusted margin */
    padding: 6px 20px; /* Adjusted padding */
    background-color: #900000;
    color: #ddd;
    border: 1px solid #c00000;
    border-radius: 4px;
    text-transform: uppercase;
    font-weight: bold;
    cursor: pointer;
}
.station-dialogue-area button:hover {
    background-color: #b00000;
}

.station-content-area {
    display: flex;
    flex-grow: 1;
    gap: 15px;
    overflow: hidden; /* Prevent content from breaking layout */
}

.station-button-column {
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    gap: 10px;
    width: 150px;
}

.station-planet-info {
    flex-grow: 1;
    background-color: #111315;
    border: 1px solid #333;
    padding: 15px;
    overflow-y: auto;
}
.station-planet-info h3 {
    margin-top: 0;
    color: #00f2ea;
    border-bottom: 1px solid #00887a;
    padding-bottom: 5px;
}

.station-action-button {
    padding: 10px 15px;
    background: linear-gradient(to bottom, #a00000, #700000);
    color: #f0f0f0;
    border: 2px outset #c03030;
    border-radius: 20px;
    text-align: center;
    font-weight: bold;
    text-transform: uppercase;
    cursor: pointer;
    box-shadow: 0 2px 3px rgba(0,0,0,0.4);
    transition: background 0.2s, transform 0.1s;
    margin: 0;
}
.station-action-button:hover {
    background: linear-gradient(to bottom, #b00000, #800000);
    border-color: #d04040;
    box-shadow: 0 2px 5px rgba(0,0,0,0.5);
}
.station-action-button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 1px rgba(0,0,0,0.4);
    border-style: inset;
}

.station-footer-text {
    text-align: center;
    font-size: 0.75em;
    color: rgba(0, 255, 255, 0.4);
    letter-spacing: 1px;
    margin-top: auto; /* Push footer to bottom of flex container */
    padding-top: 10px;
    border-top: 1px solid #333;
}

/* ===== STYLES FOR SUB-MENUS WITHIN DOCKED STATION UI ===== */
.station-submenu-content {
    width: 100%; /* Take full width of its host (.station-content-area) */
    height: 100%; /* Take full height */
    padding: 20px;
    box-sizing: border-box;
    background-color: #0c0e10; /* Slightly different dark bg for sub-menu */
    border: 1px solid #222; /* Inner border for sub-menu area */
    display: flex;
    flex-direction: column;
    overflow-y: auto;
}

.station-submenu-content h3 {
    color: #00f2ea;
    border-bottom: 1px solid #00887a;
    padding-bottom: 8px;
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    font-size: 1.4em;
}
.station-submenu-content > div:first-of-type { /* For Credits/Cargo line */
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #333;
    font-size: 0.95em;
    color: #aaa;
}


.station-submenu-item-list {
    flex-grow: 1;
    overflow-y: auto;
    border: 1px solid #25282c;
    background-color: #101214;
}

.station-submenu-header, .station-submenu-item {
    display: flex;
    justify-content: space-between;
    padding: 8px 10px;
    border-bottom: 1px solid #2a2e34;
    font-size: 0.9em;
    color: #b0b0b0; /* Default item text color */
}

.station-submenu-header {
    font-weight: bold;
    color: #99FFFF;
    background-color: rgba(0, 50, 70, 0.3);
}

.station-submenu-item:last-child {
    border-bottom: none;
}

.station-submenu-item:hover {
    background-color: rgba(0, 100, 100, 0.2);
    color: #e0e0e0;
}

.station-submenu-item.selected {
    background-color: rgba(0, 150, 150, 0.4) !important; /* Ensure override */
    border-left: 3px solid #00f2ea;
    padding-left: 7px;
    color: #ffffff !important;
}

.station-submenu-col {
    text-align: left;
    padding: 0 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.station-submenu-col.col-name { flex: 1 1 30%; min-width: 120px;} /* Allow shrinking but prefer 30% */
.station-submenu-col.col-qty  { flex: 0 0 80px; text-align: right; } /* Fixed width */
.station-submenu-col.col-price { flex: 0 0 90px; text-align: right; }/* Fixed width */
.station-submenu-col.col-stock { flex: 0 0 90px; text-align: right; }/* Fixed width */
.station-submenu-col.col-owned { flex: 0 0 70px; text-align: center; }/* Fixed width */
.station-submenu-col.col-current { flex: 0 0 70px; text-align: center; }/* Fixed width */
.station-submenu-col.col-cargo { flex: 0 0 80px; text-align: right;}/* Fixed width */
.station-submenu-col.col-reward { flex: 0 0 100px; text-align: right;}/* Fixed width */


.station-submenu-actions {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #333;
    display: flex;
    justify-content: center; /* Center buttons */
    gap: 15px; /* Space between buttons */
}

.station-submenu-actions .station-action-button { /* Sub-menu buttons can use the main style */
    min-width: 120px;
}


.mission-details-section {
    margin-top: 5px;
    padding: 8px;
    background-color: rgba(10, 40, 50, 0.5);
    border-radius: 3px;
    font-size: 0.85em;
    color: #99FFFF;
    border-left: 2px solid #00776a; /* Accent for details */
}
.mission-details-section p {
    margin: 4px 0;
    line-height: 1.3;
}
.mission-details-section strong {
    color: #00f2ea;
}


/* Hide elements of main station UI when sub-menu is active */
#docked-station-ui.submenu-active .station-viewscreen,
#docked-station-ui.submenu-active .station-dialogue-area,
#docked-station-ui.submenu-active .station-button-column, /* Hides both button columns */
#docked-station-ui.submenu-active .station-planet-info,
#docked-station-ui.submenu-active .station-footer-text.main-footer {
    display: none !important;
}

/* ===== RIGHT HUD PANEL STYLES ===== */
#right-hud-panel {
    position: fixed;
    right: 0;
    top: 0;
    width: 280px; /* Adjust width as needed */
    height: 100%;
    background-color: rgba(5, 15, 30, 0.9); /* Dark, slightly transparent */
    border-left: 2px solid rgba(0, 255, 255, 0.4); /* Cyan border */
    box-shadow: -5px 0 15px rgba(0, 150, 200, 0.2);
    color: #99FFFF; /* Light cyan text */
    font-family: 'Courier New', Courier, monospace;
    padding: 15px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 15px; /* Space between sections */
    z-index: 15; /* Below docked station UI but above game canvas */
    overflow-y: auto; /* Allow scrolling if content overflows */
}

#right-hud-panel.hidden {
    display: none !important;
}

#right-hud-panel .panel-section {
    background-color: rgba(0, 30, 40, 0.7);
    border: 1px solid rgba(0, 150, 200, 0.3);
    border-radius: 4px;
    padding: 10px;
}

#right-hud-panel h4 {
    color: #00f2ea; /* Bright Cyan */
    margin-top: 0;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(0, 200, 255, 0.2);
    text-transform: uppercase;
    font-size: 0.9em;
    letter-spacing: 1px;
}

#ship-stats-content div {
    margin-bottom: 5px;
    font-size: 0.85em;
}
#ship-stats-content span {
    display: inline-block;
    min-width: 70px; /* For label alignment */
    color: #00AACC; /* Darker cyan for labels */
}

#active-missions-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
    font-size: 0.8em;
}
#active-missions-list li {
    padding: 4px 0;
    border-bottom: 1px dashed rgba(0, 150, 200, 0.2);
    line-height: 1.3;
}
#active-missions-list li:last-child {
    border-bottom: none;
}
#active-missions-list li strong { /* Mission title */
    color: #66FF99; /* Light green */
}


#minimap-section {
    flex-grow: 1; /* Allow minimap to take remaining space if needed */
    display: flex;
    flex-direction: column;
    min-height: 150px; /* Ensure it has some minimum height */
}
#minimapCanvas {
    width: 100%;
    /* Height will be set based on aspect ratio or fixed value */
    height: 200px; /* Example fixed height, adjust as needed */
    background-color: #05080a; /* Very dark background for minimap */
    border: 1px solid rgba(0, 100, 120, 0.5);
    border-radius: 3px;
    display: block; /* Remove extra space below canvas */
}

#right-hud-panel .panel-footer {
    margin-top: auto; /* Push to bottom */
    text-align: center;
    font-size: 0.7em;
    color: rgba(0, 255, 255, 0.3);
    padding-top: 10px;
    border-top: 1px solid rgba(0, 150, 200, 0.2);
}

/* ===== UNIVERSE MAP STYLES ===== */
#universe-map-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 5, 10, 0.95); /* Dark semi-transparent background */
    z-index: 50; /* Above game, potentially below critical popups if any */
    display: flex; 
    align-items: center;
    justify-content: center;
    pointer-events: auto; /* Allow clicks on the map */
}

#universe-map-container.hidden {
    display: none !important;
}

#universeMapCanvas {
    display: block;
    /* Width and height will be set by JavaScript to match window */
    /* background-color: #000810; /* Optional: if container bg is not enough */
    cursor: pointer; /* Indicate it's clickable */
}
/* ===== END: hypernova/client/css/style.css ===== */
/* ===== END: hypernova/client/css/style.css ===== */


/* ===== START: hypernova/client/js/client_config.js ===== */
// client/js/client_config.js
export const BASE_THRUST = 0.1;
export const BASE_ROTATION_SPEED = 0.07;
export const DAMPING = 0.99;
export const PROJECTILE_LIFESPAN_MS = 400; // ms
export const DOCKING_DISTANCE_SQUARED = 400; // (20px)^2
export const MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED = 22500; // (150px)^2 - adjust as needed
export const HYPERJUMP_CHARGE_TIME_MS = 3000; // 3 seconds
export const HYPERJUMP_DENIED_MESSAGE_DURATION_MS = 3000; // 3 seconds


/* ===== END: hypernova/client/js/client_config.js ===== */


/* ===== START: hypernova/client/js/game_state.js ===== */
// hypernova/client/js/game_state.js
export const gameState = {
    currentUser: null,
    socket: null,
    myId: null,
    allShips: {},
    get myShip() {
        return this.allShips[this.myId];
    },
    projectiles: [],
    loadedImages: {},
    imagePathsToLoad: [],

    // Camera/Viewport for full-screen rendering
    camera: {
        x: 0,
        y: 0,
        width: 800, // Will be updated to screen size
        height: 600, // Will be updated to screen size
        zoom: 1.0, // Future use for zooming
    },

    clientGameData: {
        systems: [], // Will be populated with data that includes universeX, universeY, connections, backgroundFile
        tradeGoods: [],
        weapons: {},
        shipTypes: [],
        MISSION_TYPES: {},
    },
    clientPlanetEconomies: [],

    docked: false,
    dockedAtDetails: null,
    isMenuOpen: false, // For docked station sub-menus
    activeSubMenu: null, // For docked station sub-menus

    selectedTradeIndex: 0,
    selectedWeaponKey: null,
    selectedShipIndex: 0,
    selectedMissionIndex: 0,
    availableMissionsForCurrentPlanet: [],

    weaponCycleIdx: 0,
    controls: {
        rotatingLeft: false,
        rotatingRight: false,
        accelerating: false,
        decelerating: false,
    },

    isChargingHyperjump: false,
    hyperjumpChargeStartTime: null,
    hyperjumpDeniedMessage: null,
    hyperjumpDeniedMessageTimeoutId: null,

    // Universe Map State
    isMapOpen: false,
    mapSelectedSystemIndex: null, // Index of the system selected on the map for single manual jump

    // ===== NEW ROUTE PLANNING STATE =====
    plannedRoute: [], // Array of system indices for the route
    currentRouteLegIndex: -1, // Index of the next system to jump to in plannedRoute
    // ===== END OF NEW ROUTE PLANNING STATE =====

    updateShipData(id, data) {
        if (!this.allShips[id]) {
            this.allShips[id] = {};
        }
        Object.assign(this.allShips[id], data);
        if (this.allShips[id]) {
            this.defaultShipProps(this.allShips[id]);
        }
    },

    defaultShipProps(ship) {
        if (!ship) return;

        const currentShipTypeData =
            this.clientGameData.shipTypes &&
            ship.type !== undefined &&
            ship.type !== null
                ? this.clientGameData.shipTypes[ship.type]
                : null;

        if (ship.system === undefined) ship.system = 0;
        if (ship.dockedAtPlanetIdentifier === undefined)
            ship.dockedAtPlanetIdentifier = null;

        if (currentShipTypeData) {
            if (ship.maxHealth === undefined)
                ship.maxHealth = currentShipTypeData.maxHealth || 100;
            if (ship.health === undefined || ship.health > ship.maxHealth)
                ship.health = ship.maxHealth;
            if (ship.maxCargo === undefined)
                ship.maxCargo = currentShipTypeData.maxCargo || 10;
        } else {
            if (ship.maxHealth === undefined) ship.maxHealth = 100;
            if (ship.health === undefined) ship.health = 100;
            if (ship.maxCargo === undefined) ship.maxCargo = 10;
        }

        if (ship.credits === undefined) ship.credits = 0;

        if (
            this.clientGameData.tradeGoods &&
            this.clientGameData.tradeGoods.length > 0
        ) {
            if (
                !ship.cargo ||
                ship.cargo.length !== this.clientGameData.tradeGoods.length
            ) {
                ship.cargo = new Array(
                    this.clientGameData.tradeGoods.length,
                ).fill(0);
            }
        } else if (!ship.cargo) {
            ship.cargo = [];
        }

        if (!ship.weapons) ship.weapons = [];
        if (!ship.activeWeapon && ship.weapons.length > 0)
            ship.activeWeapon = ship.weapons[0];
        if (!ship.activeMissions) ship.activeMissions = [];
    },
};

/* ===== END: hypernova/client/js/game_state.js ===== */


/* ===== START: hypernova/client/js/input_handler.js ===== */
// client/js/input_handler.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";
import { UIManager } from "./ui_manager.js";
import { UniverseMapManager } from "./universe_map_renderer.js"; // Corrected import name
import {
    // BASE_THRUST, // Not used here
    // BASE_ROTATION_SPEED, // Not used here
    DAMPING,
    DOCKING_DISTANCE_SQUARED,
    // MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED, // Used in Network.js
    // HYPERJUMP_DENIED_MESSAGE_DURATION_MS, // Used in Network.js
} from "./client_config.js";

function wrap(value, max) {
    return ((value % max) + max) % max;
}

export function initInputListeners(canvas) {
    window.addEventListener("keydown", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        const keyLower = e.key.toLowerCase();
        const gameSpecificKeys = [
            "arrowup",
            "arrowdown",
            "arrowleft",
            "arrowright",
            " ",
            "d",
            "h",
            "q",
            "e",
            "t",
            "y",
            "o",
            "m",
            "u",
            "b",
            "s",
            "a",
            "escape",
            "j", // Added 'j'
        ];

        if (gameState.isMapOpen) {
            if (keyLower === "m" || keyLower === "escape") {
                UniverseMapManager.closeMap();
                e.preventDefault();
            }
            return;
        }

        if (gameSpecificKeys.includes(keyLower)) {
            e.preventDefault();
        }

        if (
            gameState.hyperjumpDeniedMessage &&
            keyLower !== "h" &&
            keyLower !== "j"
        ) {
            // Check against h and j
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            return;
        }

        if (!gameState.docked) {
            // In-space controls
            if (e.code === "Space" && !gameState.isChargingHyperjump) {
                if (!gameState.isMapOpen) Network.fireWeapon();
            }
            switch (keyLower) {
                case "arrowup":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.accelerating = true;
                    break;
                case "arrowdown":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.decelerating = true;
                    break;
                case "arrowleft":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.rotatingLeft = true;
                    break;
                case "arrowright":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        gameState.controls.rotatingRight = true;
                    break;
                case "d":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        tryDockAction();
                    break;
                case "h":
                    // 'H' currently does nothing specific here.
                    break;
                case "j": // New: Initiate hyperjump for planned route
                    if (
                        !gameState.isMapOpen && // Not in map
                        !gameState.docked &&
                        !gameState.isChargingHyperjump &&
                        gameState.plannedRoute.length > 0 &&
                        gameState.currentRouteLegIndex !== -1 &&
                        gameState.currentRouteLegIndex <
                            gameState.plannedRoute.length
                    ) {
                        const targetSystemIndex =
                            gameState.plannedRoute[
                                gameState.currentRouteLegIndex
                            ];
                        if (targetSystemIndex !== gameState.myShip.system) {
                            // Ensure not trying to jump to current system
                            Network.requestHyperjump(targetSystemIndex);
                        } else {
                            // This case should ideally be prevented by route planning logic
                            // or handled in hyperjumpComplete by advancing leg.
                            // For now, just inform if trying to jump to current system via 'J'.
                            console.warn(
                                "Attempted to 'J' jump to current system. Advancing route leg.",
                            );
                            gameState.currentRouteLegIndex++;
                            if (
                                gameState.currentRouteLegIndex >=
                                gameState.plannedRoute.length
                            ) {
                                gameState.plannedRoute = [];
                                gameState.currentRouteLegIndex = -1;
                                // UIManager.showToast("Route completed."); // Optional feedback
                            }
                        }
                    } else if (
                        !gameState.docked &&
                        !gameState.isChargingHyperjump
                    ) {
                        // Clear route if 'j' is pressed with no valid route leg or route finished
                        if (gameState.plannedRoute.length > 0) {
                            gameState.plannedRoute = [];
                            gameState.currentRouteLegIndex = -1;
                            // UIManager.showToast("Route cleared or finished."); // Optional
                        }
                    }
                    break;
                case "q":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        cycleWeaponAction(-1);
                    break;
                case "e":
                    if (!gameState.isChargingHyperjump && !gameState.isMapOpen)
                        cycleWeaponAction(1);
                    break;
                case "m":
                    if (!gameState.docked) {
                        UniverseMapManager.toggleMap();
                    } else {
                        handleMenuKeyDown(keyLower); // For docked missions menu
                    }
                    break;
            }
        } else {
            // Docked controls
            handleMenuKeyDown(keyLower);
        }
    });

    window.addEventListener("keyup", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }
        if (gameState.isMapOpen) return;

        if (
            !gameState.myShip ||
            gameState.myShip.destroyed ||
            gameState.docked
        ) {
            gameState.controls.accelerating = false;
            gameState.controls.decelerating = false;
            gameState.controls.rotatingLeft = false;
            gameState.controls.rotatingRight = false;
            return;
        }
        const keyLower = e.key.toLowerCase();
        switch (keyLower) {
            case "arrowup":
                gameState.controls.accelerating = false;
                break;
            case "arrowdown":
                gameState.controls.decelerating = false;
                break;
            case "arrowleft":
                gameState.controls.rotatingLeft = false;
                break;
            case "arrowright":
                gameState.controls.rotatingRight = false;
                break;
        }
    });
}

function tryDockAction() {
    // ... (existing code, no changes needed here for routing)
    if (
        !gameState.myShip ||
        !gameState.clientGameData.systems[gameState.myShip.system]
    )
        return;
    const planetsInCurrentSystem =
        gameState.clientGameData.systems[gameState.myShip.system].planets;
    let nearestDistSq = Infinity,
        nearestPlanetIndex = -1;

    planetsInCurrentSystem.forEach((p, index) => {
        const planetScale = p.planetImageScale || 1.0;
        const effectiveDockingDistanceSq =
            DOCKING_DISTANCE_SQUARED * Math.pow(planetScale, 2) * 2.5;

        const d2 =
            (gameState.myShip.x - p.x) ** 2 + (gameState.myShip.y - p.y) ** 2;
        if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearestPlanetIndex = index;
        }
    });
    if (nearestPlanetIndex !== -1) {
        const planetForDocking = planetsInCurrentSystem[nearestPlanetIndex];
        const effectiveDockingDistanceSq =
            DOCKING_DISTANCE_SQUARED *
            Math.pow(planetForDocking?.planetImageScale || 1.0, 2) *
            2.5;

        if (nearestDistSq < effectiveDockingDistanceSq) {
            Network.requestDock(gameState.myShip.system, nearestPlanetIndex);
        }
    }
}

function cycleWeaponAction(direction) {
    // ... (existing code, no changes needed here for routing)
    if (
        !gameState.myShip ||
        !gameState.myShip.weapons ||
        gameState.myShip.weapons.length === 0
    )
        return;
    gameState.weaponCycleIdx =
        (gameState.weaponCycleIdx +
            direction +
            gameState.myShip.weapons.length) %
        gameState.myShip.weapons.length;
    const weaponName = gameState.myShip.weapons[gameState.weaponCycleIdx];
    Network.equipWeapon(weaponName);
}

function handleMenuKeyDown(keyLower) {
    // ... (existing code, no changes needed here for routing)
    if (!gameState.docked || !gameState.myShip) {
        return;
    }
    if (!gameState.activeSubMenu) {
        switch (keyLower) {
            case "t":
                gameState.activeSubMenu = "trade";
                gameState.selectedTradeIndex = 0;
                UIManager.renderTradeMenu();
                break;
            case "y":
                gameState.activeSubMenu = "shipyard";
                gameState.selectedShipIndex = 0;
                UIManager.renderShipyardMenu();
                break;
            case "o":
                gameState.activeSubMenu = "outfitter";
                const weaponKeysList = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (
                    !gameState.selectedWeaponKey ||
                    !weaponKeysList.includes(gameState.selectedWeaponKey)
                ) {
                    gameState.selectedWeaponKey = weaponKeysList[0] || null;
                }
                UIManager.renderOutfitterMenu();
                break;
            case "m": // This 'm' is for DOCKED missions
                gameState.activeSubMenu = "missions";
                gameState.selectedMissionIndex = 0;
                gameState.availableMissionsForCurrentPlanet = [];
                UIManager.renderMissionsMenu();
                if (gameState.dockedAtDetails) {
                    Network.requestMissions(
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                break;
            case "u":
                Network.undock();
                break;
        }
    } else {
        // We are in a sub-menu
        if (keyLower === "escape") {
            gameState.activeSubMenu = null;
            UIManager.renderDockedStationInterface();
            return;
        }
        switch (gameState.activeSubMenu) {
            case "trade":
                const numTradeGoods =
                    gameState.clientGameData.tradeGoods.length;
                if (keyLower === "arrowup")
                    gameState.selectedTradeIndex = Math.max(
                        0,
                        gameState.selectedTradeIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedTradeIndex = Math.min(
                        numTradeGoods - 1,
                        gameState.selectedTradeIndex + 1,
                    );
                else if (keyLower === "b" && numTradeGoods > 0)
                    Network.buyGood(gameState.selectedTradeIndex);
                else if (keyLower === "s" && numTradeGoods > 0)
                    Network.sellGood(gameState.selectedTradeIndex);
                UIManager.renderTradeMenu();
                break;
            case "outfitter":
                const weaponKeys = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (weaponKeys.length > 0) {
                    let currentWKeyIndex = weaponKeys.indexOf(
                        gameState.selectedWeaponKey,
                    );
                    if (currentWKeyIndex === -1 && weaponKeys.length > 0)
                        currentWKeyIndex = 0;
                    if (keyLower === "arrowup")
                        currentWKeyIndex = Math.max(0, currentWKeyIndex - 1);
                    else if (keyLower === "arrowdown")
                        currentWKeyIndex = Math.min(
                            weaponKeys.length - 1,
                            currentWKeyIndex + 1,
                        );
                    gameState.selectedWeaponKey = weaponKeys[currentWKeyIndex];
                }
                if (keyLower === "b" && gameState.selectedWeaponKey)
                    Network.equipWeapon(gameState.selectedWeaponKey);
                UIManager.renderOutfitterMenu();
                break;
            case "shipyard":
                const numShipTypes = gameState.clientGameData.shipTypes.length;
                if (keyLower === "arrowup")
                    gameState.selectedShipIndex = Math.max(
                        0,
                        gameState.selectedShipIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedShipIndex = Math.min(
                        numShipTypes - 1,
                        gameState.selectedShipIndex + 1,
                    );
                else if (keyLower === "b" && numShipTypes > 0)
                    Network.buyShip(gameState.selectedShipIndex);
                UIManager.renderShipyardMenu();
                break;
            case "missions":
                const numMissions =
                    gameState.availableMissionsForCurrentPlanet.length;
                if (keyLower === "arrowup")
                    gameState.selectedMissionIndex = Math.max(
                        0,
                        gameState.selectedMissionIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedMissionIndex = Math.min(
                        numMissions - 1,
                        gameState.selectedMissionIndex + 1,
                    );
                else if (
                    keyLower === "a" &&
                    numMissions > 0 &&
                    gameState.availableMissionsForCurrentPlanet[
                        gameState.selectedMissionIndex
                    ]
                ) {
                    const missionToAccept =
                        gameState.availableMissionsForCurrentPlanet[
                            gameState.selectedMissionIndex
                        ];
                    Network.acceptMission(
                        missionToAccept.id,
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                UIManager.renderMissionsMenu();
                break;
        }
    }
}

export function processInputs() {
    // ... (existing code, some minor adjustments for damping if map is open)
    if (gameState.isMapOpen) {
        // If map is open, apply damping and send controls, but no player input processing
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            !gameState.docked // Only apply physics if not docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            Network.sendControls(); // Still send position updates
        }
        // Reset controls flags if map is open
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        return;
    }

    if (!gameState.myShip || gameState.myShip.destroyed || gameState.docked) {
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            gameState.isChargingHyperjump && // Only apply physics if charging hyperjump
            !gameState.docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            Network.sendControls();
        }
        // Reset controls flags if destroyed or docked (and not charging hyperjump)
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        return;
    }
    // ... (rest of existing processInputs code for ship movement)
    const myShip = gameState.myShip;
    if (
        !myShip ||
        myShip.type === undefined ||
        myShip.type === null ||
        !gameState.clientGameData.shipTypes ||
        myShip.type >= gameState.clientGameData.shipTypes.length ||
        !gameState.clientGameData.shipTypes[myShip.type]
    ) {
        return;
    }
    const shipDef = gameState.clientGameData.shipTypes[myShip.type];

    const thrust = (shipDef.speedMult || 1.0) * 0.1; // Assuming BASE_THRUST was 0.1
    const rotSpd = (shipDef.rotMult || 1.0) * 0.07; // Assuming BASE_ROTATION_SPEED was 0.07
    const revThrust = thrust * (shipDef.revMult || 1.0);

    if (gameState.controls.rotatingLeft) myShip.angle -= rotSpd;
    if (gameState.controls.rotatingRight) myShip.angle += rotSpd;
    myShip.angle = wrap(myShip.angle, 2 * Math.PI);

    if (gameState.controls.accelerating) {
        myShip.vx += thrust * Math.cos(myShip.angle);
        myShip.vy += thrust * Math.sin(myShip.angle);
    }
    if (gameState.controls.decelerating) {
        myShip.vx -= revThrust * Math.cos(myShip.angle);
        myShip.vy -= revThrust * Math.sin(myShip.angle);
    }

    myShip.vx *= DAMPING;
    myShip.vy *= DAMPING;

    myShip.x += myShip.vx;
    myShip.y += myShip.vy;

    Network.sendControls();
}


/* ===== END: hypernova/client/js/input_handler.js ===== */


/* ===== START: hypernova/client/js/main.js ===== */
// hypernova/client/js/main.js
console.log("main.js script started");

import { gameState } from "./game_state.js";
window.gameState = gameState; // For debugging

import { initNetwork } from "./network.js";
import { Renderer } from "./renderer.js";
import { initInputListeners, processInputs } from "./input_handler.js";
import { UIManager } from "./ui_manager.js";
import { UniverseMapManager } from "./universe_map_renderer.js";

// --- DYNAMIC LOGIN BACKGROUND & MUSIC ---
// ... (existing login screen visual and music functions - no changes here)
let loginBgCanvas, loginBgCtx;
let stars = [];
let shootingStars = [];
let loginAnimationId = null;

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}
class Star {
    constructor(x, y, radius, opacity) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.opacity = opacity;
        this.maxOpacity = opacity;
        this.minOpacity = Math.max(0.1, opacity - 0.5);
        this.opacitySpeed =
            getRandom(0.005, 0.015) * (Math.random() > 0.5 ? 1 : -1);
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.fill();
    }
    update() {
        this.opacity += this.opacitySpeed;
        if (this.opacity > this.maxOpacity || this.opacity < this.minOpacity) {
            this.opacitySpeed *= -1;
            this.opacity = Math.max(
                this.minOpacity,
                Math.min(this.maxOpacity, this.opacity),
            );
        }
    }
}
class ShootingStar {
    constructor() {
        this.reset();
    }
    reset() {
        this.active = true;
        this.x = Math.random() * (loginBgCanvas?.width || window.innerWidth);
        this.y = 0;
        this.length = getRandom(150, 300);
        this.angle = getRandom(Math.PI * 0.35, Math.PI * 0.65);
        this.speed = getRandom(300, 500);
        this.opacity = 1;
        this.life = 1;
        const side = Math.random();
        const canvasWidth = loginBgCanvas?.width || window.innerWidth;
        const canvasHeight = loginBgCanvas?.height || window.innerHeight;
        if (side < 0.4) {
            this.x = Math.random() * canvasWidth;
            this.y = -this.length;
            this.angle = getRandom(Math.PI * 0.4, Math.PI * 0.6);
        } else if (side < 0.7) {
            this.x = -this.length;
            this.y = Math.random() * canvasHeight * 0.7;
            this.angle = getRandom(Math.PI * 0.15, Math.PI * 0.35);
        } else {
            this.x = canvasWidth + this.length;
            this.y = Math.random() * canvasHeight * 0.7;
            this.angle = getRandom(Math.PI * 0.65, Math.PI * 0.85);
        }
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
    }
    update(deltaTime) {
        if (!this.active) return;
        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life -= 0.5 * deltaTime;
        if (this.life <= 0) this.active = false;
    }
    draw(ctx) {
        if (!this.active || !ctx) return;
        const tailX = this.x - Math.cos(this.angle) * this.length;
        const tailY = this.y - Math.sin(this.angle) * this.length;
        const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
        gradient.addColorStop(
            0,
            `rgba(220, 220, 255, ${this.opacity * this.life})`,
        );
        gradient.addColorStop(
            0.3,
            `rgba(200, 200, 255, ${this.opacity * this.life * 0.5})`,
        );
        gradient.addColorStop(1, `rgba(150, 150, 220, 0)`);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tailX, tailY);
        ctx.strokeStyle = gradient;
        ctx.lineWidth = getRandom(1.5, 3);
        ctx.stroke();
    }
}
function createStars() {
    if (!loginBgCanvas) return;
    stars = [];
    const numStars = Math.floor(
        (loginBgCanvas.width * loginBgCanvas.height) / 6000,
    );
    for (let i = 0; i < numStars; i++) {
        const x = Math.random() * loginBgCanvas.width;
        const y = Math.random() * loginBgCanvas.height;
        const radius = getRandom(0.2, 1.2);
        const opacity = getRandom(0.2, 0.8);
        stars.push(new Star(x, y, radius, opacity));
    }
}
function animateLoginBackground() {
    if (!loginBgCtx || !loginBgCanvas) {
        if (loginAnimationId) cancelAnimationFrame(loginAnimationId);
        return;
    }
    loginAnimationId = requestAnimationFrame(animateLoginBackground);
    loginBgCtx.fillStyle = "#00000A";
    loginBgCtx.fillRect(0, 0, loginBgCanvas.width, loginBgCanvas.height);
    stars.forEach((star) => {
        star.update();
        star.draw(loginBgCtx);
    });
    if (Math.random() < 0.015) {
        let newShootingStar = shootingStars.find((s) => !s.active);
        if (newShootingStar) newShootingStar.reset();
        else if (shootingStars.length < 10)
            shootingStars.push(new ShootingStar());
    }
    const now = performance.now();
    const deltaTime = (now - (animateLoginBackground.lastTime || now)) / 1000;
    animateLoginBackground.lastTime = now;
    shootingStars.forEach((ss) => {
        ss.update(deltaTime);
        ss.draw(loginBgCtx);
    });
}
function setupLoginMusic() {
    const music = document.getElementById("login-music");
    if (music) {
        music.volume = 0.3;
        music.play().catch((error) => {
            console.warn("Login music autoplay was prevented:", error.message);
            const playMusicOnClick = () => {
                music
                    .play()
                    .catch((e) =>
                        console.warn("Still couldn't play music:", e.message),
                    );
                document.body.removeEventListener("click", playMusicOnClick);
                document.body.removeEventListener("keydown", playMusicOnClick);
            };
            document.body.addEventListener("click", playMusicOnClick, {
                once: true,
            });
            document.body.addEventListener("keydown", playMusicOnClick, {
                once: true,
            });
        });
    } else console.warn("Login music audio element not found.");
}
function stopLoginScreenVisualsAndMusic() {
    if (loginAnimationId) cancelAnimationFrame(loginAnimationId);
    loginAnimationId = null;
    const music = document.getElementById("login-music");
    if (music) {
        music.pause();
        music.currentTime = 0;
    }
    window.removeEventListener("resize", handleLoginResize);
}
function handleLoginResize() {
    if (loginBgCanvas) {
        loginBgCanvas.width = window.innerWidth;
        loginBgCanvas.height = window.innerHeight;
        createStars();
    }
}
function initLoginScreenVisuals() {
    loginBgCanvas = document.getElementById("login-background-canvas");
    if (!loginBgCanvas) {
        console.error("Login background canvas not found!");
        return;
    }
    loginBgCtx = loginBgCanvas.getContext("2d");
    handleLoginResize();
    animateLoginBackground.lastTime = performance.now();
    animateLoginBackground();
    setupLoginMusic();
    window.addEventListener("resize", handleLoginResize);
}

// --- FULLSCREEN GAMEPLAY SETUP ---
function setupGameCanvasFullscreen() {
    const canvas = document.getElementById("gameCanvas");
    if (!canvas) {
        console.error("Game canvas not found for fullscreen setup!");
        return;
    }
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gameState.camera.width = canvas.width;
        gameState.camera.height = canvas.height;
        if (Renderer.isInitialized())
            Renderer.updateViewPort(canvas.width, canvas.height);
        console.log(`Game canvas resized to: ${canvas.width}x${canvas.height}`);
    }
    window.addEventListener("resize", resizeCanvas, false);
    resizeCanvas();
}

async function loadImages(imagePaths) {
    // ... (existing code)
    console.log("main.js/loadImages called with paths:", imagePaths);
    const imagePromises = imagePaths.map((path) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const filename = path.substring(path.lastIndexOf("/") + 1);
                gameState.loadedImages[filename] = img;
                resolve(img);
            };
            img.onerror = (err) => {
                console.error(`Failed to load image: ${path}`, err);
                reject(new Error(`Failed to load image: ${path}`));
            };
            img.src = path;
        });
    });
    try {
        await Promise.all(imagePromises);
        console.log("main.js/loadImages: All images processed.");
    } catch (error) {
        console.error("main.js/loadImages: Error during image loading:", error);
    }
}

async function handleLoginSubmit(username, password) {
    console.log(`main.js/handleLoginSubmit for user: ${username}`);
    const loginErrorEl = document.getElementById("login-error");
    const loginMessageEl = document.getElementById("login-message");
    loginErrorEl.textContent = "";
    loginMessageEl.textContent = "";

    try {
        const response = await fetch("/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password }),
        });
        const result = await response.json();
        console.log("main.js/handleLoginSubmit: API response:", result);

        if (response.ok && result.success) {
            loginMessageEl.textContent = result.message || "Success!";
            gameState.currentUser = { username: result.username };
            stopLoginScreenVisualsAndMusic();
            document.getElementById("login-screen").classList.add("hidden");
            document
                .getElementById("game-container")
                .classList.remove("hidden");
            setupGameCanvasFullscreen();

            initNetwork(async () => {
                console.log(
                    "main.js/onReadyCallback (from initNetwork): START.",
                );
                const systemBackgroundPaths = gameState.clientGameData.systems
                    .filter((sys) => sys.backgroundFile)
                    .map(
                        (sys) =>
                            `assets/images/backgrounds/${sys.backgroundFile}`,
                    );
                const allImagePaths = [
                    ...new Set([
                        ...gameState.imagePathsToLoad,
                        ...systemBackgroundPaths,
                    ]),
                ];

                if (allImagePaths.length > 0) await loadImages(allImagePaths);
                else console.log("main.js/onReadyCallback: No images to load.");

                await loadProgress();

                if (gameState.myId && !gameState.myShip) {
                    gameState.allShips[gameState.myId] =
                        gameState.allShips[gameState.myId] || {};
                    gameState.defaultShipProps(gameState.myShip);
                } else if (
                    gameState.myId &&
                    gameState.myShip &&
                    (gameState.myShip.type === undefined ||
                        gameState.myShip.type === null)
                ) {
                    gameState.defaultShipProps(gameState.myShip);
                }

                const canvasEl = document.getElementById("gameCanvas");
                if (canvasEl) canvasEl.focus();

                // ===== SHOW RIGHT HUD PANEL =====
                UIManager.showRightHudPanel();
                // ================================

                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            });
        } else {
            loginErrorEl.textContent =
                result.message || "Login/Registration failed.";
        }
    } catch (error) {
        console.error("main.js/handleLoginSubmit: Fetch failed:", error);
        loginErrorEl.textContent = "Login request error. Check console.";
    }
}

async function loadProgress() {
    // ... (existing code)
    console.log("main.js/loadProgress: Called.");
    if (!gameState.currentUser || !gameState.currentUser.username) {
        console.log("main.js/loadProgress: No current user, returning.");
        return;
    }
    try {
        const response = await fetch(
            `/load-progress?username=${gameState.currentUser.username}`,
        );
        if (response.ok) {
            const progress = await response.json();
            if (progress && progress.shipData) {
                if (gameState.myId) {
                    if (!gameState.allShips[gameState.myId])
                        gameState.allShips[gameState.myId] = {};
                    gameState.updateShipData(gameState.myId, progress.shipData);

                    const syncData = {
                        credits: progress.shipData.credits,
                        cargo: progress.shipData.cargo,
                        weapons: progress.shipData.weapons,
                        activeWeapon: progress.shipData.activeWeapon,
                        health: progress.shipData.health,
                        type: progress.shipData.type,
                        activeMissions: progress.shipData.activeMissions || [],
                    };
                    if (progress.dockedAtDetails) {
                        gameState.docked = true;
                        gameState.dockedAtDetails = progress.dockedAtDetails;
                        syncData.dockedAtDetails = gameState.dockedAtDetails;
                    } else {
                        gameState.docked = false;
                        gameState.dockedAtDetails = null;
                        syncData.dockedAtDetails = null;
                        syncData.x = progress.shipData.x;
                        syncData.y = progress.shipData.y;
                        syncData.angle = progress.shipData.angle;
                        syncData.vx = progress.shipData.vx;
                        syncData.vy = progress.shipData.vy;
                        syncData.system = progress.shipData.system;
                    }
                    if (gameState.socket)
                        gameState.socket.emit(
                            "clientLoadedDockedState",
                            syncData,
                        );
                } else {
                    gameState.pendingProgressToApply = progress;
                }
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
            }
        } else {
            gameState.docked = false;
            gameState.dockedAtDetails = null;
        }
    } catch (error) {
        console.error(
            "main.js/loadProgress: Error during fetch/processing:",
            error,
        );
        gameState.docked = false;
        gameState.dockedAtDetails = null;
    }
}

document.addEventListener("DOMContentLoaded", () => {
    console.log("main.js/DOMContentLoaded event fired");

    const loginScreenElement = document.getElementById("login-screen");
    if (
        loginScreenElement &&
        !loginScreenElement.classList.contains("hidden")
    ) {
        initLoginScreenVisuals();
    }

    const canvas = document.getElementById("gameCanvas");
    const uiContainer = document.getElementById("ui");
    const gameContainer = document.getElementById("game-container");

    if (!canvas || !uiContainer || !gameContainer) {
        console.error(
            "main.js/DOMContentLoaded: Required HTML elements not found!",
        );
        return;
    }
    if (canvas && !canvas.hasAttribute("tabindex")) {
        canvas.setAttribute("tabindex", "0");
    }

    Renderer.init(canvas);
    UIManager.init(uiContainer);
    UniverseMapManager.init();
    initInputListeners(canvas);

    const loginForm = document.getElementById("login-form");
    if (loginForm) {
        loginForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            const usernameInput = document.getElementById("username");
            const passwordInput = document.getElementById("password");
            if (usernameInput && passwordInput) {
                await handleLoginSubmit(
                    usernameInput.value,
                    passwordInput.value,
                );
            }
        });
    }
});

let lastTime = 0;
// let hudUpdateCounter = 0; // For less frequent HUD text updates
// const HUD_UPDATE_INTERVAL = 30; // Update HUD text every 30 frames approx

function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (gameState.currentUser && gameState.myId && gameState.myShip) {
        if (gameState.isMapOpen) {
            if (!gameState.docked) processInputs(); // Minimal physics for map open
        } else {
            // Normal game rendering and logic
            if (gameState.myShip) {
                gameState.camera.x =
                    gameState.myShip.x - gameState.camera.width / 2;
                gameState.camera.y =
                    gameState.myShip.y - gameState.camera.height / 2;
            }

            if (!gameState.docked) {
                processInputs();
            }
            Renderer.draw(); // This will also call drawMinimap

            // DOM updates for HUD text are now primarily event-driven (see network.js)
            // to avoid excessive DOM manipulation in the game loop.
            // If a fallback polling mechanism is desired for stats/missions:
            // hudUpdateCounter++;
            // if (hudUpdateCounter >= HUD_UPDATE_INTERVAL) {
            //     UIManager.updateShipStatsPanel();
            //     UIManager.updateActiveMissionsPanel();
            //     hudUpdateCounter = 0;
            // }
        }
    }
    requestAnimationFrame(gameLoop);
}


/* ===== END: hypernova/client/js/main.js ===== */


/* ===== START: hypernova/client/js/network.js ===== */
// hypernova/client/js/network.js
import { gameState } from "./game_state.js";
import { UIManager } from "./ui_manager.js";
import {
    HYPERJUMP_DENIED_MESSAGE_DURATION_MS,
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED,
} from "./client_config.js";

export async function saveProgress() {
    // ... (existing code)
    if (!gameState.socket || !gameState.myShip || !gameState.currentUser) {
        console.warn(
            "saveProgress: Cannot save - No socket, ship, or user data.",
        );
        return;
    }
    console.log(
        `saveProgress: Preparing data. Current gameState.docked: ${gameState.docked}, dockedAtDetails being saved: ${JSON.stringify(gameState.docked ? gameState.dockedAtDetails : null)}`,
    );
    const progressData = {
        username: gameState.currentUser.username,
        shipData: {
            x: gameState.myShip.x,
            y: gameState.myShip.y,
            angle: gameState.myShip.angle,
            vx: gameState.myShip.vx,
            vy: gameState.myShip.vy,
            type: gameState.myShip.type,
            credits: gameState.myShip.credits,
            cargo: gameState.myShip.cargo,
            maxCargo: gameState.myShip.maxCargo,
            health: gameState.myShip.health,
            maxHealth: gameState.myShip.maxHealth,
            weapons: gameState.myShip.weapons,
            activeWeapon: gameState.myShip.activeWeapon,
            system: gameState.myShip.system,
            activeMissions: gameState.myShip.activeMissions,
        },
        dockedAtDetails: gameState.docked ? gameState.dockedAtDetails : null,
    };

    try {
        const response = await fetch("/save-progress", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(progressData),
        });
        const result = await response.json();
        if (response.ok && result.success) {
            console.log("saveProgress: Progress saved successfully to server.");
        } else {
            console.error(
                "saveProgress: Failed to save progress to server:",
                result.message || "Server error",
            );
        }
    } catch (error) {
        console.error(
            "saveProgress: Error during fetch to save progress:",
            error,
        );
    }
}

export function initNetwork(onReadyCallback) {
    const socket = io();
    gameState.socket = socket;

    socket.on("init", (data) => {
        // ... (existing code - no changes here)
        console.log(
            "network.js/init: Received init data (first 200 chars):",
            JSON.stringify(data).substring(0, 200),
        );
        if (!data || !data.id || !data.gameData) {
            console.error(
                "network.js/init: Incomplete init data received from server.",
            );
            return;
        }
        gameState.myId = data.id;
        console.log("network.js/init: Set gameState.myId to:", gameState.myId);

        gameState.clientGameData.systems = data.gameData.systems || [];
        gameState.clientGameData.tradeGoods = data.gameData.tradeGoods || [];
        gameState.clientGameData.weapons = data.gameData.weapons || {};
        gameState.clientGameData.shipTypes = data.gameData.shipTypes || [];
        gameState.clientGameData.MISSION_TYPES =
            data.gameData.MISSION_TYPES || {};
        gameState.clientPlanetEconomies = data.gameData.economies || [];

        const uniqueImageFiles = new Set();
        if (gameState.clientGameData.systems) {
            gameState.clientGameData.systems.forEach((system) => {
                if (system.backgroundFile) {
                    uniqueImageFiles.add(
                        `assets/images/backgrounds/${system.backgroundFile}`,
                    );
                }
                if (system.planets) {
                    system.planets.forEach((planet) => {
                        if (planet.imageFile) {
                            uniqueImageFiles.add(
                                `assets/images/${planet.imageFile}`,
                            );
                        }
                    });
                }
            });
        }
        if (gameState.clientGameData.shipTypes) {
            gameState.clientGameData.shipTypes.forEach((shipType) => {
                if (shipType.imageFile) {
                    uniqueImageFiles.add(`assets/images/${shipType.imageFile}`);
                }
            });
        }
        gameState.imagePathsToLoad = Array.from(uniqueImageFiles);

        if (data.ships) {
            for (const shipId in data.ships) {
                gameState.updateShipData(shipId, data.ships[shipId]);
            }
        }

        if (gameState.pendingProgressToApply && gameState.myId) {
            const pendingProgress = gameState.pendingProgressToApply;
            gameState.updateShipData(gameState.myId, pendingProgress.shipData);
            if (
                gameState.myShip &&
                pendingProgress.shipData.system !== undefined
            ) {
                gameState.myShip.system = pendingProgress.shipData.system;
            }
            if (pendingProgress.dockedAtDetails) {
                gameState.docked = true;
                gameState.dockedAtDetails = pendingProgress.dockedAtDetails;
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
            }
            delete gameState.pendingProgressToApply;
        } else if (gameState.myId && !gameState.myShip) {
            // Ensure myShip object exists even if no prior data
            gameState.allShips[gameState.myId] = {};
            gameState.defaultShipProps(gameState.myShip);
        }

        console.log(
            "network.js/init: Client initialization sequence complete. Final My ship type:",
            gameState.myShip ? gameState.myShip.type : "N/A",
            "Final gameState.docked:",
            gameState.docked,
        );
        if (onReadyCallback) {
            console.log("network.js/init: Calling onReadyCallback.");
            onReadyCallback();
        }
    });

    socket.on("state", (updatedShipDataMap) => {
        for (const id in updatedShipDataMap) {
            const update = updatedShipDataMap[id];
            if (id === gameState.myId) {
                if (
                    update.hyperjumpState === "idle" &&
                    gameState.isChargingHyperjump
                ) {
                    gameState.isChargingHyperjump = false;
                    gameState.hyperjumpChargeStartTime = null;
                }
            }
            gameState.updateShipData(id, update);
            if (id === gameState.myId) {
                // If my ship's data was updated
                UIManager.updateShipStatsPanel();
                UIManager.updateActiveMissionsPanel(); // Missions might depend on ship state (e.g. cargo for delivery)
            }
        }
        if (
            gameState.myShip &&
            gameState.myShip.dockedAtPlanetIdentifier === null &&
            gameState.docked
        ) {
            // This case handles server-side undock (e.g. ship destroyed while docked)
            UIManager.undockCleanup();
        }
    });

    socket.on("playerJoined", (data) => {
        gameState.updateShipData(data.id, data.ship);
    });

    socket.on("playerLeft", (id) => {
        delete gameState.allShips[id];
    });

    socket.on("projectile", (data) => {
        data.time = Date.now();
        gameState.projectiles.push(data);
    });

    socket.on("dockConfirmed", (data) => {
        gameState.docked = true;
        if (gameState.myShip) {
            gameState.myShip.dockedAtPlanetIdentifier = {
                systemIndex: data.systemIndex,
                planetIndex: data.planetIndex,
            };
            gameState.myShip.x = data.playerX;
            gameState.myShip.y = data.playerY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
        }
        gameState.dockedAtDetails = { ...data };
        UIManager.openDockMenu(); // This will also update HUD panels
        saveProgress();
    });

    socket.on("undockConfirmed", () => {
        UIManager.undockCleanup(); // This will also update HUD panels
    });

    socket.on("tradeError", ({ message }) => {
        alert(`Trade Error: ${message}`);
    });
    socket.on("actionFailed", ({ message }) => {
        alert(`Action Failed: ${message}`);
    });
    socket.on("actionSuccess", ({ message }) => {
        console.log("Action Success:", message);
    });

    socket.on("tradeSuccess", (data) => {
        if (gameState.myShip) {
            gameState.myShip.credits = data.credits;
            gameState.myShip.cargo = data.cargo;
        }
        if (
            gameState.docked &&
            gameState.dockedAtDetails &&
            data.updatedPlanetData
        ) {
            Object.assign(gameState.dockedAtDetails, data.updatedPlanetData);
        }
        if (gameState.activeSubMenu === "trade") UIManager.renderTradeMenu();
        UIManager.updateShipStatsPanel(); // Update HUD
    });

    socket.on("updatePlanetEconomies", (updatedSystemsEconomies) => {
        /* Not directly used client-side yet */
    });

    socket.on("planetEconomyUpdate", (data) => {
        if (
            gameState.docked &&
            gameState.dockedAtDetails &&
            gameState.dockedAtDetails.systemIndex === data.systemIndex &&
            gameState.dockedAtDetails.planetIndex === data.planetIndex
        ) {
            Object.assign(gameState.dockedAtDetails, data);
            if (gameState.activeSubMenu === "trade")
                UIManager.renderTradeMenu();
        }
    });

    socket.on("availableMissionsList", (data) => {
        gameState.availableMissionsForCurrentPlanet = data.missions;
        if (gameState.activeSubMenu === "missions")
            UIManager.renderMissionsMenu();
    });

    socket.on("missionAccepted", (data) => {
        if (gameState.myShip)
            gameState.myShip.activeMissions.push(data.mission);
        if (
            gameState.activeSubMenu === "missions" &&
            gameState.dockedAtDetails
        ) {
            const missionIdx =
                gameState.availableMissionsForCurrentPlanet.findIndex(
                    (m) => m.id === data.mission.id,
                );
            if (missionIdx > -1)
                gameState.availableMissionsForCurrentPlanet.splice(
                    missionIdx,
                    1,
                );
            UIManager.renderMissionsMenu();
        }
        UIManager.updateActiveMissionsPanel(); // Update HUD
    });

    socket.on("missionUpdate", (data) => {
        if (gameState.myShip && gameState.myShip.activeMissions) {
            const missionIdx = gameState.myShip.activeMissions.findIndex(
                (m) => m.id === data.missionId,
            );
            if (missionIdx !== -1) {
                if (
                    data.status === "COMPLETED" ||
                    data.status === "FAILED_TIME"
                ) {
                    gameState.myShip.activeMissions.splice(missionIdx, 1);
                    if (data.creditsAwarded)
                        gameState.myShip.credits += data.creditsAwarded; // If server sends credit update
                    if (data.creditsPenalized)
                        gameState.myShip.credits -= data.creditsPenalized;
                } else if (data.progress) {
                    gameState.myShip.activeMissions[
                        missionIdx
                    ].targetsDestroyed = parseInt(data.progress.split("/")[0]);
                }
            }
        }
        UIManager.updateActiveMissionsPanel(); // Update HUD
        UIManager.updateShipStatsPanel(); // Credits might have changed
        if (data.message) alert(data.message);
    });

    socket.on("hyperjumpChargeStarted", ({ chargeTime }) => {
        gameState.isChargingHyperjump = true;
        gameState.hyperjumpChargeStartTime = Date.now();
    });

    socket.on("hyperjumpDenied", ({ message }) => {
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        gameState.hyperjumpDeniedMessage = message;
        if (gameState.hyperjumpDeniedMessageTimeoutId) {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        }
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
    });

    socket.on("hyperjumpCancelled", ({ message }) => {
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        if (message) {
            gameState.hyperjumpDeniedMessage = message;
            if (gameState.hyperjumpDeniedMessageTimeoutId) {
                clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            }
            gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                gameState.hyperjumpDeniedMessage = null;
                gameState.hyperjumpDeniedMessageTimeoutId = null;
            }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        }
    });

    socket.on("hyperjumpComplete", (data) => {
        // ... (route progression logic remains the same)
        const previousSystem = gameState.myShip ? gameState.myShip.system : -1;
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;

        if (gameState.myShip) {
            gameState.myShip.system = data.newSystem;
            gameState.myShip.x = data.newX;
            gameState.myShip.y = data.newY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
            gameState.myShip.angle =
                data.newAngle !== undefined ? data.newAngle : 0;
            gameState.myShip.dockedAtPlanetIdentifier = null;
        }
        gameState.docked = false;
        UIManager.undockCleanup(); // This will update HUD panels

        if (
            gameState.plannedRoute.length > 0 &&
            gameState.currentRouteLegIndex !== -1
        ) {
            const expectedSystem =
                gameState.plannedRoute[gameState.currentRouteLegIndex];
            if (data.newSystem === expectedSystem) {
                gameState.currentRouteLegIndex++;
                if (
                    gameState.currentRouteLegIndex >=
                    gameState.plannedRoute.length
                ) {
                    console.log("Route completed.");
                    gameState.plannedRoute = [];
                    gameState.currentRouteLegIndex = -1;
                } else {
                    const nextSystemName =
                        gameState.clientGameData.systems[
                            gameState.plannedRoute[
                                gameState.currentRouteLegIndex
                            ]
                        ]?.name || "Unknown System";
                    console.log(
                        `Route advanced. Next jump: ${nextSystemName}. Press J.`,
                    );
                }
            } else {
                console.log("Jumped to an unexpected system. Clearing route.");
                gameState.plannedRoute = [];
                gameState.currentRouteLegIndex = -1;
            }
        }
    });
}

export function sendControls() {
    // ... (existing code)
    if (
        !gameState.socket ||
        !gameState.myShip ||
        (gameState.myShip && gameState.myShip.destroyed)
    ) {
        return;
    }
    gameState.socket.emit("control", {
        x: gameState.myShip.x,
        y: gameState.myShip.y,
        angle: gameState.myShip.angle,
        vx: gameState.myShip.vx,
        vy: gameState.myShip.vy,
        system: gameState.myShip.system,
    });
}

export function fireWeapon() {
    // ... (existing code)
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        !gameState.myShip.activeWeapon ||
        gameState.docked ||
        gameState.isChargingHyperjump ||
        gameState.isMapOpen
    ) {
        if (gameState.isMapOpen)
            console.warn("fireWeapon: Cannot fire, map is open.");
        return;
    }
    gameState.socket.emit("fire");
}

export function equipWeapon(weaponName) {
    // ... (existing code - already calls UIManager.updateShipStatsPanel after server confirmation via 'state' event)
    if (!gameState.socket || gameState.isChargingHyperjump) {
        if (gameState.isChargingHyperjump)
            console.warn("equipWeapon: Cannot equip while charging hyperjump.");
        return;
    }
    gameState.socket.emit("equipWeapon", { weapon: weaponName });
}

export function requestDock(systemIndex, planetIndex) {
    // ... (existing code)
    if (!gameState.socket || gameState.isChargingHyperjump) {
        if (gameState.isChargingHyperjump)
            console.warn("requestDock: Cannot dock while charging hyperjump.");
        return;
    }
    gameState.socket.emit("dock", { systemIndex, planetIndex });
}

export function undock() {
    // ... (existing code)
    if (!gameState.socket || !gameState.docked) {
        console.warn(
            `undock: Pre-condition failed. Socket: ${!!gameState.socket}, gameState.docked: ${gameState.docked}.`,
        );
        return;
    }
    gameState.socket.emit("undock");
    saveProgress();
}

export function buyGood(goodIndex) {
    // ... (existing code - UIManager.updateShipStatsPanel called by tradeSuccess)
    const good = gameState.clientGameData.tradeGoods[goodIndex];
    if (!good || !gameState.dockedAtDetails || !gameState.socket) return;
    gameState.socket.emit("buyGood", {
        goodName: good.name,
        quantity: 1,
        systemIndex: gameState.dockedAtDetails.systemIndex,
        planetIndex: gameState.dockedAtDetails.planetIndex,
    });
}
export function sellGood(goodIndex) {
    // ... (existing code - UIManager.updateShipStatsPanel called by tradeSuccess)
    const good = gameState.clientGameData.tradeGoods[goodIndex];
    if (!good || !gameState.dockedAtDetails || !gameState.socket) return;
    gameState.socket.emit("sellGood", {
        goodName: good.name,
        quantity: 1,
        systemIndex: gameState.dockedAtDetails.systemIndex,
        planetIndex: gameState.dockedAtDetails.planetIndex,
    });
}
export function buyShip(shipTypeIndex) {
    // ... (existing code - UIManager.updateShipStatsPanel called after server confirmation via 'state' event)
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.isChargingHyperjump
    ) {
        if (gameState.isChargingHyperjump)
            console.warn("buyShip: Cannot buy ship while charging hyperjump.");
        return;
    }
    gameState.socket.emit("buyShip", { shipTypeIndex });
}

export function requestMissions(systemIndex, planetIndex) {
    // ... (existing code)
    if (!gameState.socket) return;
    gameState.socket.emit("requestMissions", { systemIndex, planetIndex });
}
export function acceptMission(missionId, systemIndex, planetIndex) {
    // ... (existing code - UIManager.updateActiveMissionsPanel called by missionAccepted)
    if (!gameState.socket) return;
    gameState.socket.emit("acceptMission", {
        missionId,
        systemIndex,
        planetIndex,
    });
}

export function requestHyperjump(targetSystemIndex = null) {
    // ... (existing code - no direct HUD calls needed here, hyperjumpDeniedMessage is handled by HUD render)
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.docked ||
        gameState.isChargingHyperjump
    ) {
        let reason = "Pre-condition failed";
        if (gameState.docked) reason = "docked";
        if (gameState.isChargingHyperjump) reason = "already charging";
        if (gameState.myShip?.destroyed) reason = "ship destroyed";
        console.warn(`requestHyperjump: Cannot request. Reason: ${reason}`);

        const alertMessage = `Hyperjump denied: ${reason === "docked" ? "Cannot engage hyperdrive while docked." : reason === "already charging" ? "Hyperdrive already engaged." : reason === "ship destroyed" ? "Ship systems critical." : "Cannot engage hyperdrive."}`;
        // Set up denied message to be shown in HUD
        gameState.hyperjumpDeniedMessage = alertMessage;
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }

    const currentSystemData =
        gameState.clientGameData.systems[gameState.myShip.system];
    if (currentSystemData && currentSystemData.planets) {
        for (const planet of currentSystemData.planets) {
            if (!planet) continue;
            const distSq =
                (gameState.myShip.x - planet.x) ** 2 +
                (gameState.myShip.y - planet.y) ** 2;
            const planetScale = planet.planetImageScale || 1.0;
            const baseMinJumpDistSq =
                MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED || 22500;
            const minJumpDistSq =
                baseMinJumpDistSq * Math.pow(planetScale, 2) * 1.5;

            if (distSq < minJumpDistSq) {
                gameState.hyperjumpDeniedMessage =
                    "Too close to a celestial body to engage hyperdrive.";
                if (gameState.hyperjumpDeniedMessageTimeoutId)
                    clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
                gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                    gameState.hyperjumpDeniedMessage = null;
                    gameState.hyperjumpDeniedMessageTimeoutId = null;
                }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
                return;
            }
        }
    }
    if (targetSystemIndex === null) {
        gameState.hyperjumpDeniedMessage =
            "Error: No target system selected for hyperjump.";
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }
    if (targetSystemIndex === gameState.myShip.system) {
        gameState.hyperjumpDeniedMessage = "Cannot jump to the current system.";
        if (gameState.hyperjumpDeniedMessageTimeoutId)
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        return;
    }

    console.log(
        `network.js: Emitting 'requestHyperjump' for system ${targetSystemIndex}.`,
    );
    gameState.socket.emit("requestHyperjump", { targetSystemIndex });
}

export function cancelHyperjumpRequest() {
    // ... (existing code)
    if (!gameState.socket || !gameState.isChargingHyperjump) return;
    console.log("network.js: Emitting 'cancelHyperjump'.");
    gameState.socket.emit("cancelHyperjump");
}


/* ===== END: hypernova/client/js/network.js ===== */


/* ===== START: hypernova/client/js/renderer.js ===== */
// hypernova/client/js/renderer.js
import { gameState } from "./game_state.js";
import {
    PROJECTILE_LIFESPAN_MS,
    DOCKING_DISTANCE_SQUARED,
    HYPERJUMP_CHARGE_TIME_MS,
} from "./client_config.js";

let ctx = null;
let canvas = null;
let minimapCanvas = null; // For the new minimap
let minimapCtx = null;
let initialized = false;

// Parallax background properties
const PARALLAX_LAYERS = [
    {
        speed: 0.05,
        stars: [],
        starDensity: 0.000015,
        minStarSize: 0.2,
        maxStarSize: 0.7,
        opacity: 0.4,
    }, // Deepest, slowest
    {
        speed: 0.15,
        stars: [],
        starDensity: 0.00003,
        minStarSize: 0.4,
        maxStarSize: 1.0,
        opacity: 0.6,
    },
    {
        speed: 0.35,
        stars: [],
        starDensity: 0.00005,
        minStarSize: 0.6,
        maxStarSize: 1.5,
        opacity: 0.8,
    },
];
// let lastCameraX = 0; // Not currently used, but kept if needed later
// let lastCameraY = 0;

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}

function generateParallaxStars() {
    if (!canvas) return;
    PARALLAX_LAYERS.forEach((layer) => {
        layer.stars = [];
        const numStars = Math.floor(
            canvas.width * canvas.height * layer.starDensity,
        );
        for (let i = 0; i < numStars; i++) {
            layer.stars.push({
                x: Math.random() * canvas.width * 3 - canvas.width, // Distribute over a larger area to avoid pop-in during fast pans
                y: Math.random() * canvas.height * 3 - canvas.height,
                radius: getRandom(layer.minStarSize, layer.maxStarSize),
                opacity: getRandom(layer.opacity * 0.5, layer.opacity),
            });
        }
    });
}

export const Renderer = {
    init(mainCanvasElement) {
        canvas = mainCanvasElement;
        ctx = canvas.getContext("2d");

        minimapCanvas = document.getElementById("minimapCanvas");
        if (minimapCanvas) {
            minimapCtx = minimapCanvas.getContext("2d");
            minimapCanvas.width = minimapCanvas.clientWidth;
            minimapCanvas.height = minimapCanvas.clientHeight;
        } else {
            console.warn("Minimap canvas not found!");
        }

        gameState.camera.width = canvas.width;
        gameState.camera.height = canvas.height;
        generateParallaxStars();
        initialized = true;
        console.log(
            "Renderer initialized with canvas:",
            canvas.width,
            "x",
            canvas.height,
        );
    },

    isInitialized() {
        return initialized;
    },

    updateViewPort(width, height) {
        generateParallaxStars();

        if (minimapCanvas) {
            minimapCanvas.width = minimapCanvas.clientWidth;
            minimapCanvas.height = minimapCanvas.clientHeight;
        }
        console.log("Renderer viewport updated:", width, "x", height);
    },

    drawSystemBackground() {
        if (!gameState.myShip || gameState.myShip.system === undefined) {
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        const systemData =
            gameState.clientGameData.systems[gameState.myShip.system];
        if (systemData && systemData.backgroundFile) {
            const bgImg = gameState.loadedImages[systemData.backgroundFile];
            if (bgImg) {
                const camX = gameState.camera.x;
                const camY = gameState.camera.y;
                const parallaxFactor = 0.1; // How much the background moves relative to camera

                const imgWidth = bgImg.width;
                const imgHeight = bgImg.height;

                // Calculate the starting position for drawing the tiled background
                // Ensures seamless tiling by accounting for camera position and parallax
                const startX =
                    Math.floor((camX * parallaxFactor) / imgWidth) * imgWidth;
                const startY =
                    Math.floor((camY * parallaxFactor) / imgHeight) * imgHeight;

                ctx.save();
                // Translate the context by the parallax-adjusted camera offset
                // This makes the background appear to move slower than the foreground
                ctx.translate(
                    -(camX * parallaxFactor),
                    -(camY * parallaxFactor),
                );

                // Tile the image to fill the screen and beyond to avoid edges during movement
                // The loop bounds are expanded to cover potential screen movement
                for (
                    let x = startX - imgWidth;
                    x <
                    startX + canvas.width / (1 - parallaxFactor) + imgWidth * 2;
                    x += imgWidth
                ) {
                    for (
                        let y = startY - imgHeight;
                        y <
                        startY +
                            canvas.height / (1 - parallaxFactor) +
                            imgHeight * 2;
                        y += imgHeight
                    ) {
                        ctx.drawImage(bgImg, x, y, imgWidth, imgHeight);
                    }
                }
                ctx.restore();
            } else {
                ctx.fillStyle = systemData.fallbackColor || "#010205"; // Use a fallback if image not loaded
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        } else {
            // Default very dark blue if no system-specific background
            ctx.fillStyle = "#000003";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        this.drawParallaxStars(); // Draw stars on top of the background image
    },

    drawParallaxStars() {
        const camX = gameState.camera.x;
        const camY = gameState.camera.y;

        PARALLAX_LAYERS.forEach((layer) => {
            ctx.beginPath();
            layer.stars.forEach((star) => {
                // Calculate screen position with parallax and wrapping
                const parallaxX = star.x - camX * layer.speed;
                const parallaxY = star.y - camY * layer.speed;

                // Wrap stars around the screen width/height to create an infinite effect
                // The effective size for wrapping should be larger than the canvas to avoid pop-in
                const wrapWidth = canvas.width + canvas.width / layer.speed; // Effective width for star wrapping
                const wrapHeight = canvas.height + canvas.height / layer.speed; // Effective height

                let screenX = parallaxX % wrapWidth;
                if (screenX < 0) screenX += wrapWidth;
                screenX %= canvas.width; // Final position on canvas

                let screenY = parallaxY % wrapHeight;
                if (screenY < 0) screenY += wrapHeight;
                screenY %= canvas.height; // Final position on canvas

                ctx.moveTo(screenX + star.radius, screenY); // moveTo before arc
                ctx.arc(screenX, screenY, star.radius, 0, Math.PI * 2);
            });
            ctx.fillStyle = `rgba(255, 255, 240, ${layer.opacity})`;
            ctx.fill();
        });
    },

    draw() {
        if (!ctx || !initialized) return;
        if (!gameState.myShip) {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }

        this.drawSystemBackground();

        ctx.save();
        ctx.translate(-gameState.camera.x, -gameState.camera.y);

        if (gameState.myShip.system !== undefined) {
            const currentSystemData =
                gameState.clientGameData.systems[gameState.myShip.system];
            if (currentSystemData && currentSystemData.planets) {
                currentSystemData.planets.forEach((p) => this.drawPlanet(p));
            }

            const now = Date.now();
            gameState.projectiles = gameState.projectiles.filter(
                (p) => now - (p.time || 0) < PROJECTILE_LIFESPAN_MS,
            );
            gameState.projectiles.forEach((p) => this.drawProjectile(p));

            for (const id in gameState.allShips) {
                const ship = gameState.allShips[id];
                if (!ship || ship.system !== gameState.myShip.system) continue;
                this.drawShip(ship);

                if (
                    id !== gameState.myId &&
                    !ship.destroyed &&
                    ship.type !== undefined
                ) {
                    const shipDef =
                        gameState.clientGameData.shipTypes[ship.type];
                    const shipRenderScale = shipDef.scale || 1.0;
                    const labelOffset =
                        shipDef && shipDef.imgHeight
                            ? (shipDef.imgHeight / 2) * shipRenderScale + 10
                            : 25;
                    ctx.fillStyle = ship.color || "#0f0";
                    ctx.font = "12px monospace";
                    ctx.textAlign = "center";
                    const displayName = ship.username || id.substring(0, 6);
                    ctx.fillText(displayName, ship.x, ship.y - labelOffset);
                    ctx.textAlign = "left";
                }
            }
        }
        ctx.restore();
        this.drawHUD();
        // Minimap is drawn on demand when panel is shown/updated by UIManager
    },

    drawPlanet(planet) {
        const img = gameState.loadedImages[planet.imageFile];
        const BASE_PLANET_RENDER_SIZE = 128;
        const scale = planet.planetImageScale || 1.0;
        const renderSize = BASE_PLANET_RENDER_SIZE * scale;

        if (img) {
            ctx.save();
            ctx.drawImage(
                img,
                planet.x - renderSize / 2,
                planet.y - renderSize / 2,
                renderSize,
                renderSize,
            );
            // Atmospheric glow effect
            ctx.globalCompositeOperation = "lighter"; // Additive blending for glow
            const glowRadius = renderSize * 0.65; // Slightly larger than planet
            const gradient = ctx.createRadialGradient(
                planet.x,
                planet.y,
                renderSize * 0.48, // Inner radius slightly smaller than planet
                planet.x,
                planet.y,
                glowRadius, // Outer radius for glow extent
            );
            gradient.addColorStop(0, `rgba(120, 170, 255, 0.25)`); // Brighter at planet edge
            gradient.addColorStop(0.7, `rgba(120, 170, 255, 0.1)`);
            gradient.addColorStop(1, `rgba(120, 170, 255, 0)`); // Fade to transparent
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = "source-over"; // Reset blending mode
            ctx.restore();
        } else {
            ctx.fillStyle = planet.fallbackColor || "#335577";
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, renderSize / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = "#E0E8FF";
        ctx.font = `${Math.max(10, 12 * scale)}px monospace`; // Scale font size with planet
        ctx.textAlign = "center";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 2;
        ctx.fillText(
            planet.name,
            planet.x,
            planet.y + renderSize / 2 + Math.max(12, 15 * scale), // Position name below planet
        );
        ctx.shadowBlur = 0;
        ctx.textAlign = "left";
    },

    drawShip(ship) {
        if (ship.destroyed || ship.type === undefined) return;
        const shipTypeDefinition =
            gameState.clientGameData.shipTypes[ship.type];
        if (!shipTypeDefinition) return;

        const img = gameState.loadedImages[shipTypeDefinition.imageFile];
        const shipScale = shipTypeDefinition.scale || 1.0;

        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        if (img) {
            const w = (shipTypeDefinition.imgWidth || img.width) * shipScale;
            const h = (shipTypeDefinition.imgHeight || img.height) * shipScale;
            ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
            // Fallback drawing if image not loaded
            ctx.fillStyle = ship.color || "#0f0";
            ctx.beginPath();
            ctx.moveTo(15 * shipScale, 0);
            ctx.lineTo(-10 * shipScale, 8 * shipScale);
            ctx.lineTo(-10 * shipScale, -8 * shipScale);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    },

    drawProjectile(p) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(p.range / 4, 0); // Draw projectile as a short line
        ctx.shadowColor = p.color; // Glow effect for projectile
        ctx.shadowBlur = 5;
        ctx.stroke();
        ctx.restore();
    },

    drawHUD() {
        ctx.font = "14px monospace";
        ctx.fillStyle = "#00FF00";

        // Display hyperjump denied message if present and not charging
        if (
            gameState.hyperjumpDeniedMessage &&
            !gameState.isChargingHyperjump
        ) {
            ctx.fillStyle = "red";
            ctx.font = "16px monospace";
            const messageWidth = ctx.measureText(
                gameState.hyperjumpDeniedMessage,
            ).width;
            ctx.fillText(
                gameState.hyperjumpDeniedMessage,
                canvas.width / 2 - messageWidth / 2,
                canvas.height - 60,
            );
            ctx.fillStyle = "#00FF00"; // Reset color
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            ctx.fillStyle = "red";
            ctx.font = "24px monospace";
            const msg = "SHIP DESTROYED - AWAITING RESPAWN";
            ctx.textAlign = "center";
            ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = "left";
            return;
        }

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return; // Should not happen if myShip.type is valid

        let cargoCount =
            myShip.cargo && myShip.cargo.length > 0
                ? myShip.cargo.reduce((s, v) => s + v, 0)
                : 0;

        const hudPadding = 15;
        ctx.textAlign = "left";
        ctx.fillText(
            `Pilot: ${gameState.currentUser.username}`,
            hudPadding,
            hudPadding + 14,
        );
        ctx.fillText(
            `Credits: $${myShip.credits.toLocaleString()}`,
            hudPadding,
            hudPadding + 32,
        );
        ctx.fillText(
            `Health: ${myShip.health || 0}/${myShip.maxHealth || 0}`,
            hudPadding,
            hudPadding + 50,
        );
        ctx.fillText(
            `Cargo: ${cargoCount}/${currentShipDef.maxCargo}`,
            hudPadding,
            hudPadding + 68,
        );

        const systemName =
            gameState.clientGameData.systems[myShip.system]?.name ||
            "Unknown System";
        ctx.fillText(`System: ${systemName}`, hudPadding, hudPadding + 86);

        if (myShip.activeWeapon) {
            const weaponDisplayName =
                gameState.clientGameData.weapons[myShip.activeWeapon]?.name ||
                myShip.activeWeapon;
            ctx.fillText(
                `Weapon: ${weaponDisplayName}`,
                hudPadding,
                hudPadding + 104,
            );
        }

        // Active Missions (simplified for main HUD)
        let hudNextY = hudPadding + 138;
        if (myShip.activeMissions && myShip.activeMissions.length > 0) {
            ctx.fillText("Active Missions:", hudPadding, hudNextY);
            hudNextY += 18;
            myShip.activeMissions.slice(0, 3).forEach((mission) => {
                // Show top 3
                let missionText =
                    mission.title.length > 40
                        ? mission.title.substring(0, 37) + "..."
                        : mission.title;
                if (
                    mission.type ===
                    gameState.clientGameData.MISSION_TYPES.BOUNTY
                ) {
                    missionText += ` (${mission.targetsDestroyed || 0}/${mission.targetsRequired})`;
                }
                const timeRemainingMin = Math.max(
                    0,
                    Math.round((mission.timeLimit - Date.now()) / 60000),
                );
                missionText += ` (${timeRemainingMin}m)`;
                ctx.fillText(`- ${missionText}`, hudPadding + 5, hudNextY);
                hudNextY += 18;
            });
        }

        // Hyperjump Charge Bar
        if (
            gameState.isChargingHyperjump &&
            gameState.hyperjumpChargeStartTime
        ) {
            const chargeProgress = Math.min(
                1,
                (Date.now() - gameState.hyperjumpChargeStartTime) /
                    HYPERJUMP_CHARGE_TIME_MS,
            );
            ctx.fillStyle = "#0af";
            ctx.font = "18px monospace";
            const chargeText = `Hyperdrive Charging: ${Math.round(chargeProgress * 100)}%`;
            const textWidth = ctx.measureText(chargeText).width;
            ctx.textAlign = "center";
            ctx.fillText(chargeText, canvas.width / 2, canvas.height - 80);

            const barWidth = 250;
            const barHeight = 15;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height - 60;

            ctx.strokeStyle = "#0af";
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.fillRect(
                barX + 2,
                barY + 2,
                (barWidth - 4) * chargeProgress,
                barHeight - 4,
            );
            ctx.fillStyle = "#00FF00"; // Reset color
            ctx.lineWidth = 1; // Reset line width
            ctx.textAlign = "left"; // Reset alignment
        }

        // === ROUTE AND DOCKING MESSAGES (NEW/MODIFIED) ===
        let messageDisplayedAtBottom = false; // Flag to prevent overlapping messages

        // Route Message
        if (
            gameState.plannedRoute.length > 0 &&
            gameState.currentRouteLegIndex !== -1 &&
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            if (
                gameState.currentRouteLegIndex < gameState.plannedRoute.length
            ) {
                const nextDestSystemIndex =
                    gameState.plannedRoute[gameState.currentRouteLegIndex];
                const nextDestSystem =
                    gameState.clientGameData.systems[nextDestSystemIndex];
                if (nextDestSystem) {
                    ctx.font = "16px monospace";
                    ctx.fillStyle = "#FFA500"; // Orange, like route lines
                    const routeMsg = `Next Jump (J): ${nextDestSystem.name}`;
                    ctx.textAlign = "center";
                    ctx.fillText(
                        routeMsg,
                        canvas.width / 2,
                        canvas.height - 30,
                    );
                    messageDisplayedAtBottom = true;
                }
            } else {
                // Route finished, awaiting clear
                ctx.font = "16px monospace";
                ctx.fillStyle = "#00FF00";
                const routeMsg =
                    "Route complete. Press J to clear or plot new.";
                ctx.textAlign = "center";
                ctx.fillText(routeMsg, canvas.width / 2, canvas.height - 30);
                messageDisplayedAtBottom = true;
            }
            ctx.textAlign = "left";
            ctx.fillStyle = "#00FF00";
        }

        // Docking Message (only if no route message and other conditions met)
        if (
            !messageDisplayedAtBottom &&
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            const planets =
                gameState.clientGameData.systems[myShip.system]?.planets;
            let canDock = false,
                dockPlanetName = "";
            if (planets) {
                planets.forEach((p) => {
                    const interactionRadiusSq =
                        DOCKING_DISTANCE_SQUARED *
                        Math.pow(p.planetImageScale || 1.0, 2) *
                        2;
                    if (
                        (myShip.x - p.x) ** 2 + (myShip.y - p.y) ** 2 <
                        interactionRadiusSq
                    ) {
                        canDock = true;
                        dockPlanetName = p.name;
                    }
                });
            }
            if (canDock) {
                ctx.font = "16px monospace";
                const dockMsg = `Press 'D' to dock at ${dockPlanetName}`;
                ctx.textAlign = "center";
                ctx.fillText(dockMsg, canvas.width / 2, canvas.height - 30);
                messageDisplayedAtBottom = true; // Though it's the last one here
            }
            ctx.textAlign = "left"; // Reset alignment
        }
        // === END OF ROUTE AND DOCKING MESSAGES ===
    },

    drawMinimap() {
        if (
            !minimapCtx ||
            !minimapCanvas ||
            !gameState.myShip ||
            gameState.myShip.system === undefined
        ) {
            if (minimapCtx) {
                // Clear if context exists but cannot draw
                minimapCtx.fillStyle = "#05080a";
                minimapCtx.fillRect(
                    0,
                    0,
                    minimapCanvas.width,
                    minimapCanvas.height,
                );
            }
            return;
        }

        minimapCtx.fillStyle = "#05080a"; // Very dark background
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

        const currentSystemData =
            gameState.clientGameData.systems[gameState.myShip.system];
        if (!currentSystemData || !currentSystemData.planets) return;

        // Determine bounds of the current system to scale to minimap
        let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
        currentSystemData.planets.forEach((p) => {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
        });
        // Include player ship in bounds calculation for dynamic centering
        if (gameState.myShip.x < minX) minX = gameState.myShip.x;
        if (gameState.myShip.x > maxX) maxX = gameState.myShip.x;
        if (gameState.myShip.y < minY) minY = gameState.myShip.y;
        if (gameState.myShip.y > maxY) maxY = gameState.myShip.y;

        const systemWidth = Math.max(500, maxX - minX); // Ensure a minimum extent
        const systemHeight = Math.max(500, maxY - minY);
        const systemCenterX = minX + systemWidth / 2;
        const systemCenterY = minY + systemHeight / 2;

        const mapPadding = 10; // Padding inside the minimap canvas
        const mapDrawableWidth = minimapCanvas.width - 2 * mapPadding;
        const mapDrawableHeight = minimapCanvas.height - 2 * mapPadding;

        const scaleX = mapDrawableWidth / systemWidth;
        const scaleY = mapDrawableHeight / systemHeight;
        const scale = Math.min(scaleX, scaleY) * 0.9; // Use 90% of the smallest scale to ensure fit

        minimapCtx.save();
        minimapCtx.translate(minimapCanvas.width / 2, minimapCanvas.height / 2); // Center the drawing origin

        // Draw planets
        currentSystemData.planets.forEach((p) => {
            const mapX = (p.x - systemCenterX) * scale;
            const mapY = (p.y - systemCenterY) * scale;
            const planetRadius = (p.planetImageScale || 1.0) * 3 * scale + 2; // Scaled radius

            minimapCtx.fillStyle = p.fallbackColor || "#557799";
            minimapCtx.beginPath();
            minimapCtx.arc(
                mapX,
                mapY,
                Math.max(2, planetRadius),
                0,
                Math.PI * 2,
            );
            minimapCtx.fill();

            minimapCtx.fillStyle = "#ccc";
            minimapCtx.font = `${Math.max(6, 8 * scale)}px monospace`;
            minimapCtx.textAlign = "center";
            minimapCtx.fillText(
                p.name.substring(0, 3),
                mapX,
                mapY + planetRadius + 8 * scale,
            );
        });

        // Draw player ship
        const playerMapX = (gameState.myShip.x - systemCenterX) * scale;
        const playerMapY = (gameState.myShip.y - systemCenterY) * scale;
        minimapCtx.fillStyle = "#00FF00"; // Player color
        minimapCtx.save();
        minimapCtx.translate(playerMapX, playerMapY);
        minimapCtx.rotate(gameState.myShip.angle);
        // Draw as a small triangle
        const playerSize = Math.max(2, 4 * scale);
        minimapCtx.beginPath();
        minimapCtx.moveTo(playerSize, 0);
        minimapCtx.lineTo(-playerSize / 2, -playerSize / 1.5);
        minimapCtx.lineTo(-playerSize / 2, playerSize / 1.5);
        minimapCtx.closePath();
        minimapCtx.fill();
        minimapCtx.restore();

        minimapCtx.restore(); // Restore main transform
    },
};


/* ===== END: hypernova/client/js/renderer.js ===== */


/* ===== START: hypernova/client/js/ui_manager.js ===== */
// client/js/ui_manager.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";
import { Renderer } from "./renderer.js"; // Import Renderer

let uiContainer = null;
let dockMenuElement = null; // This is the container for the main station UI and sub-menus
let rightHudPanel = null;
let shipStatsContentDiv = null;
let activeMissionsListUl = null;

export const UIManager = {
    init(containerElement) {
        uiContainer = containerElement;
        rightHudPanel = document.getElementById("right-hud-panel");
        shipStatsContentDiv = document.getElementById("ship-stats-content");
        activeMissionsListUl = document.getElementById("active-missions-list");
    },

    isMenuOpen() {
        // This now refers to the docked station menu, not the HUD panel
        return gameState.isMenuOpen;
    },

    openDockMenu() {
        // This is for the main station interaction UI
        if (dockMenuElement && dockMenuElement.parentNode === uiContainer) {
            uiContainer.removeChild(dockMenuElement);
        }

        gameState.isMenuOpen = true; // Docked station menu is open
        gameState.activeSubMenu = null;
        document.body.classList.add("no-scroll");

        dockMenuElement = document.createElement("div");
        uiContainer.appendChild(dockMenuElement);

        this.renderDockedStationInterface();
        // Right HUD panel is already visible, but we might want to refresh its content
        this.updateShipStatsPanel();
        this.updateActiveMissionsPanel();
        Renderer.drawMinimap();
    },

    closeDockMenu() {
        // Closes the main station interaction UI
        if (dockMenuElement && dockMenuElement.parentNode === uiContainer) {
            dockMenuElement.innerHTML = "";
            uiContainer.removeChild(dockMenuElement);
        }
        dockMenuElement = null;
        gameState.isMenuOpen = false; // Docked station menu is closed
        gameState.activeSubMenu = null;
        gameState.selectedTradeIndex = 0;
        gameState.selectedWeaponKey = null;
        gameState.selectedShipIndex = 0;
        gameState.selectedMissionIndex = 0;
        document.body.classList.remove("no-scroll");
        // Right HUD panel remains visible
    },

    undockCleanup() {
        gameState.docked = false;
        gameState.dockedAtDetails = null;
        this.closeDockMenu();
        // Right HUD panel remains visible. Ensure its content reflects undocked state.
        this.updateShipStatsPanel();
        this.updateActiveMissionsPanel();
        // Minimap will be updated by Renderer.draw()
    },

    showRightHudPanel() {
        if (rightHudPanel) {
            rightHudPanel.classList.remove("hidden");
            this.updateShipStatsPanel();
            this.updateActiveMissionsPanel();
            // Renderer.drawMinimap() will be called by the main render loop
        }
    },

    // hideRightHudPanel() is no longer needed if the panel is always visible
    // hideRightHudPanel() {
    //     if (rightHudPanel) {
    //         rightHudPanel.classList.add("hidden");
    //     }
    // },

    updateShipStatsPanel() {
        if (!shipStatsContentDiv || !gameState.myShip || !gameState.currentUser)
            return;

        const myShip = gameState.myShip;
        const shipType = gameState.clientGameData.shipTypes[myShip.type || 0];
        const shipTypeName = shipType ? shipType.name : "Unknown";
        const cargoCount = myShip.cargo
            ? myShip.cargo.reduce((s, v) => s + v, 0)
            : 0;
        const maxCargo = shipType ? shipType.maxCargo : myShip.maxCargo || 0;

        shipStatsContentDiv.innerHTML = `
            <div><span>Pilot:</span> ${gameState.currentUser.username}</div>
            <div><span>Ship:</span> ${shipTypeName}</div>
            <div><span>Credits:</span> $${myShip.credits.toLocaleString()}</div>
            <div><span>Health:</span> ${myShip.health || 0} / ${myShip.maxHealth || 0}</div>
            <div><span>Cargo:</span> ${cargoCount} / ${maxCargo}</div>
        `;
    },

    updateActiveMissionsPanel() {
        if (!activeMissionsListUl || !gameState.myShip) return;

        activeMissionsListUl.innerHTML = "";

        if (
            gameState.myShip.activeMissions &&
            gameState.myShip.activeMissions.length > 0
        ) {
            gameState.myShip.activeMissions.slice(0, 5).forEach((mission) => {
                // Show top 5 or so
                const li = document.createElement("li");
                let missionText = `<strong>${mission.title}</strong>`;
                if (
                    mission.type ===
                    gameState.clientGameData.MISSION_TYPES.BOUNTY
                ) {
                    missionText += ` (${mission.targetsDestroyed || 0}/${mission.targetsRequired})`;
                }
                const timeRemainingMs = mission.timeLimit - Date.now();
                let timeRemainingText = "";
                if (timeRemainingMs <= 0) {
                    timeRemainingText = "(Expired)";
                } else {
                    const timeRemainingMin = Math.max(
                        0,
                        Math.round(timeRemainingMs / 60000),
                    );
                    timeRemainingText = `(${timeRemainingMin}m left)`;
                }
                missionText += ` ${timeRemainingText}`;
                li.innerHTML = missionText;
                activeMissionsListUl.appendChild(li);
            });
        } else {
            activeMissionsListUl.innerHTML = "<li>No active missions.</li>";
        }
    },

    _prepareSubMenuHost() {
        if (!dockMenuElement) {
            console.error(
                "Dock menu element does not exist. Cannot prepare sub-menu host.",
            );
            this.openDockMenu(); // Attempt to create it if called erroneously
            if (!dockMenuElement) return null;
        }
        let stationUI = dockMenuElement.querySelector("#docked-station-ui");
        if (!stationUI) {
            this.renderDockedStationInterface(); // Re-render main dock UI if needed
            stationUI = dockMenuElement.querySelector("#docked-station-ui");
            if (!stationUI) {
                // Should not happen if renderDockedStationInterface works
                console.error(
                    "Failed to create #docked-station-ui for sub-menu.",
                );
                return null;
            }
        }

        stationUI.classList.add("submenu-active");
        const contentHost = stationUI.querySelector(".station-content-area");
        if (!contentHost) {
            console.error(
                ".station-content-area not found within #docked-station-ui",
            );
            return null;
        }
        contentHost.innerHTML = ""; // Clear previous sub-menu content
        return contentHost;
    },

    renderDockedStationInterface() {
        if (!dockMenuElement) {
            if (uiContainer) {
                dockMenuElement = document.createElement("div");
                uiContainer.appendChild(dockMenuElement);
            } else {
                console.error(
                    "UIManager: uiContainer not initialized, cannot create dockMenuElement.",
                );
                return;
            }
        }
        if (!gameState.dockedAtDetails || !gameState.myShip) {
            // This can happen if undockCleanup runs before this render is complete
            // or if somehow this is called when not docked.
            this.closeDockMenu(); // Ensure dock menu is closed if state is inconsistent
            return;
        }

        gameState.activeSubMenu = null; // Reset sub-menu selection
        dockMenuElement.innerHTML = ""; // Clear previous content

        const planetName = gameState.dockedAtDetails.planetName;
        const systemName = gameState.dockedAtDetails.systemName;
        // Dummy descriptions, replace with actual data source if available
        const planetDescriptions = {
            /* ... same as before ... */
            Alpha: "A bustling trade hub in the Greek system, known for its agricultural surplus.",
            Delta: "Rich in mineral wealth, Delta is a key mining outpost.",
            Sol: "The cradle of humanity in the Roman system, a political and cultural center.",
            Mars: "A rugged, terraformed world, primarily exporting raw ores.",
            Beta: "A temperate planet in Nordic space, balancing agriculture and mining.",
            Nile: "An arid world in the Egyptian system with surprisingly fertile river valleys.",
            Giza: "Known for its ancient alien ruins and valuable ore deposits.",
            Tara: "A verdant, spiritual center in the Celtic system, specializing in advanced medicines.",
            Avalon: "A technologically advanced world, famous for its electronics manufacturing.",
        };
        const description =
            planetDescriptions[planetName] ||
            "No detailed information available for this planet.";

        const html = `
            <div id="docked-station-ui">
                <div class="station-viewscreen">
                    Docked at ${planetName} Station Control<br/>
                    System: ${systemName}
                </div>
                <div class="station-dialogue-area">
                    <p>Welcome to ${planetName}, Captain ${gameState.currentUser.username}. All systems nominal. Please select an option from the terminal.</p>
                    <button id="station-dialogue-okay">Okay</button>
                </div>
                <div class="station-content-area">
                    <div class="station-button-column">
                        <button id="station-bar-btn" class="station-action-button">Bar</button>
                        <button id="station-missions-btn" class="station-action-button">Mission BBS</button>
                        <button id="station-trade-btn" class="station-action-button">Trade Center</button>
                    </div>
                    <div class="station-planet-info">
                        <h3>${planetName} - ${systemName}</h3>
                        <p>${description}</p>
                        <p>Credits: $${gameState.myShip.credits.toLocaleString()}</p>
                    </div>
                    <div class="station-button-column">
                        <button id="station-shipyard-btn" class="station-action-button">Shipyard</button>
                        <button id="station-outfitter-btn" class="station-action-button">Outfitter</button>
                        <button id="station-recharge-btn" class="station-action-button">Recharge</button>
                        <button id="station-leave-btn" class="station-action-button">Leave</button>
                    </div>
                </div>
                <div class="station-footer-text main-footer">HyperNova Secure Terminal v2.7.4</div>
            </div>
        `;
        dockMenuElement.innerHTML = html;

        // Add event listeners for the main docked station buttons
        document
            .getElementById("station-dialogue-okay")
            ?.addEventListener("click", () => {
                const dialogueBox = dockMenuElement.querySelector(
                    ".station-dialogue-area",
                );
                if (dialogueBox) dialogueBox.style.display = "none";
            });
        document
            .getElementById("station-bar-btn")
            ?.addEventListener("click", () => alert("Bar: Not implemented."));
        document
            .getElementById("station-recharge-btn")
            ?.addEventListener("click", () =>
                alert("Recharge: Not implemented."),
            );
        document
            .getElementById("station-leave-btn")
            ?.addEventListener("click", () => Network.undock());

        document
            .getElementById("station-trade-btn")
            ?.addEventListener("click", () => {
                gameState.activeSubMenu = "trade";
                gameState.selectedTradeIndex = 0;
                this.renderTradeMenu();
            });
        document
            .getElementById("station-shipyard-btn")
            ?.addEventListener("click", () => {
                gameState.activeSubMenu = "shipyard";
                gameState.selectedShipIndex = 0;
                this.renderShipyardMenu();
            });
        document
            .getElementById("station-outfitter-btn")
            ?.addEventListener("click", () => {
                gameState.activeSubMenu = "outfitter";
                const weaponKeysList = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (
                    !gameState.selectedWeaponKey ||
                    !weaponKeysList.includes(gameState.selectedWeaponKey)
                ) {
                    gameState.selectedWeaponKey = weaponKeysList[0] || null;
                }
                this.renderOutfitterMenu();
            });
        document
            .getElementById("station-missions-btn")
            ?.addEventListener("click", () => {
                gameState.activeSubMenu = "missions";
                gameState.selectedMissionIndex = 0;
                gameState.availableMissionsForCurrentPlanet = []; // Clear before requesting
                this.renderMissionsMenu(); // Render skeleton
                if (gameState.dockedAtDetails) {
                    // Request new missions
                    Network.requestMissions(
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
            });
    },

    renderTradeMenu() {
        const host = this._prepareSubMenuHost();
        if (!host || !gameState.dockedAtDetails || !gameState.myShip) return;

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return; // Should have ship definition
        const cargoCount = myShip.cargo
            ? myShip.cargo.reduce((s, v) => s + v, 0)
            : 0;
        const planetEco = gameState.dockedAtDetails; // This should have current prices/stock

        let itemsHtml = `<div class="station-submenu-header">
                            <span class="station-submenu-col col-name">Good</span>
                            <span class="station-submenu-col col-qty">Qty</span>
                            <span class="station-submenu-col col-price">Buy</span>
                            <span class="station-submenu-col col-price">Sell</span>
                            <span class="station-submenu-col col-stock">Stock</span>
                         </div>`;

        if (
            !planetEco ||
            !planetEco.buyPrices ||
            !planetEco.sellPrices ||
            !planetEco.stock
        ) {
            itemsHtml +=
                "<div class='station-submenu-item'>Loading prices...</div>";
        } else {
            gameState.clientGameData.tradeGoods.forEach((g, i) => {
                const buyP =
                    planetEco.buyPrices[g.name] !== undefined
                        ? planetEco.buyPrices[g.name]
                        : "N/A";
                const sellP =
                    planetEco.sellPrices[g.name] !== undefined
                        ? planetEco.sellPrices[g.name]
                        : "N/A";
                const stockVal =
                    planetEco.stock[g.name] !== undefined
                        ? planetEco.stock[g.name]
                        : 0;
                const selectedClass =
                    i === gameState.selectedTradeIndex ? "selected" : "";
                itemsHtml += `
                    <div class="station-submenu-item ${selectedClass}" data-index="${i}">
                        <span class="station-submenu-col col-name">${g.name}</span>
                        <span class="station-submenu-col col-qty">${myShip.cargo[i]}</span>
                        <span class="station-submenu-col col-price">$${buyP}</span>
                        <span class="station-submenu-col col-price">$${sellP}</span>
                        <span class="station-submenu-col col-stock">${stockVal}</span>
                    </div>`;
            });
        }

        host.innerHTML = `
            <div class="station-submenu-content">
                <h3>Trade Center - ${planetEco.planetName}</h3>
                <div>Credits: $${myShip.credits.toLocaleString()} | Cargo: ${cargoCount}/${currentShipDef.maxCargo}</div>
                <div class="station-submenu-item-list">${itemsHtml}</div>
                <div class="station-submenu-actions">
                    <button id="submenu-buy-btn" class="station-action-button">Buy (B)</button>
                    <button id="submenu-sell-btn" class="station-action-button">Sell (S)</button>
                    <button id="submenu-back-btn" class="station-action-button">Back (Esc)</button>
                </div>
            </div>`;

        document
            .getElementById("submenu-buy-btn")
            ?.addEventListener("click", () =>
                Network.buyGood(gameState.selectedTradeIndex),
            );
        document
            .getElementById("submenu-sell-btn")
            ?.addEventListener("click", () =>
                Network.sellGood(gameState.selectedTradeIndex),
            );
        document
            .getElementById("submenu-back-btn")
            ?.addEventListener("click", () =>
                this.renderDockedStationInterface(),
            );
    },

    renderOutfitterMenu() {
        const host = this._prepareSubMenuHost();
        if (!host || !gameState.myShip || !gameState.clientGameData.weapons)
            return;

        const myShip = gameState.myShip;
        let itemsHtml = `<div class="station-submenu-header">
                            <span class="station-submenu-col col-name">Weapon</span>
                            <span class="station-submenu-col col-price">Price</span>
                            <span class="station-submenu-col col-qty">Dmg</span>
                            <span class="station-submenu-col col-owned">Owned</span>
                         </div>`;

        const weaponKeys = Object.keys(gameState.clientGameData.weapons);
        if (weaponKeys.length === 0) {
            itemsHtml +=
                "<div class='station-submenu-item'>(No weapons available)</div>";
        } else {
            if (
                !gameState.selectedWeaponKey ||
                !weaponKeys.includes(gameState.selectedWeaponKey)
            ) {
                gameState.selectedWeaponKey = weaponKeys[0] || null;
            }
            weaponKeys.forEach((wKey) => {
                const wDef = gameState.clientGameData.weapons[wKey];
                const owned =
                    myShip.weapons && myShip.weapons.includes(wKey)
                        ? "Yes"
                        : "No";
                const selectedClass =
                    wKey === gameState.selectedWeaponKey ? "selected" : "";
                itemsHtml += `
                    <div class="station-submenu-item ${selectedClass}" data-key="${wKey}">
                        <span class="station-submenu-col col-name">${wDef.name}</span>
                        <span class="station-submenu-col col-price">$${wDef.price.toLocaleString()}</span>
                        <span class="station-submenu-col col-qty">${wDef.damage}</span>
                        <span class="station-submenu-col col-owned">${owned}</span>
                    </div>`;
            });
        }

        host.innerHTML = `
            <div class="station-submenu-content">
                <h3>Outfitter</h3>
                <div>Credits: $${myShip.credits.toLocaleString()}</div>
                <div class="station-submenu-item-list">${itemsHtml}</div>
                <div class="station-submenu-actions">
                    <button id="submenu-buyequip-btn" class="station-action-button">Buy/Equip (B)</button>
                    <button id="submenu-back-btn" class="station-action-button">Back (Esc)</button>
                </div>
            </div>`;

        document
            .getElementById("submenu-buyequip-btn")
            ?.addEventListener("click", () => {
                if (gameState.selectedWeaponKey)
                    Network.equipWeapon(gameState.selectedWeaponKey);
            });
        document
            .getElementById("submenu-back-btn")
            ?.addEventListener("click", () =>
                this.renderDockedStationInterface(),
            );
    },

    renderShipyardMenu() {
        const host = this._prepareSubMenuHost();
        if (!host || !gameState.myShip) return;

        const myShip = gameState.myShip;
        let itemsHtml = `<div class="station-submenu-header">
                            <span class="station-submenu-col col-name">Ship</span>
                            <span class="station-submenu-col col-price">Price</span>
                            <span class="station-submenu-col col-cargo">Cargo</span>
                            <span class="station-submenu-col col-current">Current</span>
                         </div>`;

        if (gameState.clientGameData.shipTypes.length === 0) {
            itemsHtml +=
                "<div class='station-submenu-item'>(No ships available)</div>";
        } else {
            gameState.clientGameData.shipTypes.forEach((s, i) => {
                const cur = myShip.type === i ? "Yes" : "No";
                const selectedClass =
                    i === gameState.selectedShipIndex ? "selected" : "";
                itemsHtml += `
                    <div class="station-submenu-item ${selectedClass}" data-index="${i}">
                        <span class="station-submenu-col col-name">${s.name}</span>
                        <span class="station-submenu-col col-price">$${s.price.toLocaleString()}</span>
                        <span class="station-submenu-col col-cargo">${s.maxCargo}</span>
                        <span class="station-submenu-col col-current">${cur}</span>
                    </div>`;
            });
        }

        host.innerHTML = `
            <div class="station-submenu-content">
                <h3>Shipyard</h3>
                <div>Credits: $${myShip.credits.toLocaleString()}</div>
                <div class="station-submenu-item-list">${itemsHtml}</div>
                <div class="station-submenu-actions">
                    <button id="submenu-buy-btn" class="station-action-button">Buy Ship (B)</button>
                    <button id="submenu-back-btn" class="station-action-button">Back (Esc)</button>
                </div>
            </div>`;
        document
            .getElementById("submenu-buy-btn")
            ?.addEventListener("click", () =>
                Network.buyShip(gameState.selectedShipIndex),
            );
        document
            .getElementById("submenu-back-btn")
            ?.addEventListener("click", () =>
                this.renderDockedStationInterface(),
            );
    },

    renderMissionsMenu() {
        const host = this._prepareSubMenuHost();
        if (!host || !gameState.dockedAtDetails || !gameState.myShip) return;

        let itemsHtml = `<div class="station-submenu-header">
                            <span class="station-submenu-col col-name" style="flex-basis: 70%;">Title</span>
                            <span class="station-submenu-col col-reward">Reward</span>
                         </div>`;

        if (gameState.availableMissionsForCurrentPlanet.length === 0) {
            itemsHtml +=
                "<div class='station-submenu-item'>(No missions currently available)</div>";
        } else {
            if (
                gameState.selectedMissionIndex >=
                gameState.availableMissionsForCurrentPlanet.length
            ) {
                gameState.selectedMissionIndex = Math.max(
                    0,
                    gameState.availableMissionsForCurrentPlanet.length - 1,
                );
            }

            gameState.availableMissionsForCurrentPlanet.forEach((m, i) => {
                const selectedClass =
                    i === gameState.selectedMissionIndex ? "selected" : "";
                let titleDisplay =
                    m.title.length > 60
                        ? m.title.substring(0, 57) + "..."
                        : m.title;
                itemsHtml += `
                    <div class="station-submenu-item ${selectedClass}" data-index="${i}">
                        <span class="station-submenu-col col-name" style="flex-basis: 70%;">${titleDisplay}</span>
                        <span class="station-submenu-col col-reward">$${m.rewardCredits.toLocaleString()}</span>
                    </div>`;
                if (i === gameState.selectedMissionIndex) {
                    // Show details for selected mission
                    const timeLeftMs = m.timeLimit - Date.now();
                    const timeLeftMin = Math.max(
                        0,
                        Math.round(timeLeftMs / 60000),
                    );
                    itemsHtml += `<div class="mission-details-section">
                                    <p><strong>Description:</strong> ${m.description}</p>
                                    <p><strong>Time Limit:</strong> ${timeLeftMin} min | <strong>Penalty:</strong> $${m.penaltyCredits.toLocaleString()}</p>`;
                    if (
                        m.type ===
                        gameState.clientGameData.MISSION_TYPES.CARGO_DELIVERY
                    ) {
                        itemsHtml += `<p><strong>Deliver:</strong> ${m.cargoQuantity} ${m.cargoGoodName}</p>`;
                    } else if (
                        m.type === gameState.clientGameData.MISSION_TYPES.BOUNTY
                    ) {
                        const targetSysName =
                            gameState.clientGameData.systems[
                                m.targetSystemIndex
                            ]?.name || "Unknown System";
                        itemsHtml += `<p><strong>Target:</strong> ${m.targetsRequired} ${m.targetShipName}(s) in ${targetSysName}</p>`;
                    }
                    itemsHtml += `</div>`;
                }
            });
        }

        host.innerHTML = `
            <div class="station-submenu-content">
                <h3>Mission BBS - ${gameState.dockedAtDetails.planetName}</h3>
                <div>Credits: $${gameState.myShip.credits.toLocaleString()}</div>
                <div class="station-submenu-item-list">${itemsHtml}</div>
                <div class="station-submenu-actions">
                    <button id="submenu-accept-btn" class="station-action-button">Accept (A)</button>
                    <button id="submenu-back-btn" class="station-action-button">Back (Esc)</button>
                </div>
            </div>`;

        document
            .getElementById("submenu-accept-btn")
            ?.addEventListener("click", () => {
                if (
                    gameState.availableMissionsForCurrentPlanet.length > 0 &&
                    gameState.availableMissionsForCurrentPlanet[
                        gameState.selectedMissionIndex
                    ]
                ) {
                    const missionToAccept =
                        gameState.availableMissionsForCurrentPlanet[
                            gameState.selectedMissionIndex
                        ];
                    Network.acceptMission(
                        missionToAccept.id,
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
            });
        document
            .getElementById("submenu-back-btn")
            ?.addEventListener("click", () =>
                this.renderDockedStationInterface(),
            );
    },
};


/* ===== END: hypernova/client/js/ui_manager.js ===== */


/* ===== START: hypernova/server/server.js ===== */
// hypernova/server/server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const path = require("path");
const fs = require("fs").promises; // Use promises for async file operations
const bodyParser = require("body-parser"); // To parse JSON request bodies

const gameConfig = require("./config/game_config");
const DataLoader = require("./utils/data_loader");

const PlayerManager = require("./modules/player_manager");
const WorldManager = require("./modules/world_manager");
const EconomyManager = require("./modules/economy_manager");
const MissionManager = require("./modules/mission_manager");
const CombatManager = require("./modules/combat_manager");

const app = express();
const serverHttp = http.createServer(app);
const io = new Server(serverHttp, {
    cors: {
        origin: "*", // Be more restrictive in production
        methods: ["GET", "POST"],
    },
});

app.use(bodyParser.json()); // Middleware to parse JSON request bodies
app.use(express.static(path.join(__dirname, "../client")));

app.get("/socket.io/socket.io.js", (req, res) => {
    res.sendFile(
        path.join(
            __dirname,
            "../../node_modules/socket.io/client-dist/socket.io.js",
        ),
    );
});

const USERS_DIR = path.join(__dirname, "data/users");

async function ensureUsersDir() {
    try {
        await fs.mkdir(USERS_DIR, { recursive: true });
        console.log("Users directory ensured:", USERS_DIR);
    } catch (error) {
        console.error("Failed to create users directory:", error);
    }
}
ensureUsersDir(); // Call this to ensure directory exists on server startup

// --- Authentication and User Data ---
async function findUser(username) {
    const filePath = path.join(USERS_DIR, `${username}.json`);
    try {
        const data = await fs.readFile(filePath, "utf-8");
        return JSON.parse(data);
    } catch (error) {
        if (error.code === "ENOENT") return null; // User file not found
        console.error(`Error reading user file for ${username}:`, error);
        throw error; // Re-throw other errors
    }
}

async function createUser(username, password) {
    // WARNING: Storing plain text passwords is a major security risk!
    // Use bcrypt.hashSync(password, saltRounds) in a real app.
    const userFilePath = path.join(USERS_DIR, `${username}.json`);
    const userData = {
        username,
        password /* In a real app, store HASHED password */,
    };
    try {
        await fs.writeFile(userFilePath, JSON.stringify(userData, null, 2));
        console.log(`User ${username} created.`);
        return userData;
    } catch (err) {
        console.error(`Error creating user ${username}:`, err);
        return null; // Indicate failure
    }
}

app.post("/login", async (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) {
        return res.status(400).json({
            success: false,
            message: "Username and password are required.",
        });
    }

    try {
        let user = await findUser(username);
        if (!user) {
            // Simplified: Auto-register if user not found
            console.log(`User ${username} not found. Registering...`);
            user = await createUser(username, password);
            if (!user) {
                return res.status(500).json({
                    success: false,
                    message: "Failed to register user.",
                });
            }
            // Security note: Do not send password back, even in registration success
            return res.json({
                success: true,
                username: user.username,
                message: "Registration successful. Logged in.",
            });
        }

        // WARNING: Plain text password comparison. Insecure!
        // In a real app: const match = await bcrypt.compare(password, user.hashedPassword);
        if (user.password !== password) {
            return res
                .status(401)
                .json({ success: false, message: "Invalid password." });
        }
        // Security note: Do not send password back
        res.json({
            success: true,
            username: user.username,
            message: "Login successful",
        });
    } catch (error) {
        console.error("Login error:", error);
        res.status(500).json({
            success: false,
            message: "Server error during login.",
        });
    }
});

// --- Progress Saving and Loading ---
app.post("/save-progress", async (req, res) => {
    // In a real app, authenticate user here (e.g., check session token from request headers)
    const { username, shipData, dockedAtDetails } = req.body;
    if (!username) {
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }
    if (!shipData) {
        return res.status(400).json({
            success: false,
            message: "Ship data required for saving progress.",
        });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    const progress = {
        username,
        lastSaved: new Date().toISOString(),
        shipData,
        dockedAtDetails, // Can be null if not docked
    };

    try {
        await fs.writeFile(progressFilePath, JSON.stringify(progress, null, 2));
        res.json({ success: true, message: "Progress saved." });
    } catch (error) {
        console.error(`Error saving progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error saving progress.",
        });
    }
});

app.get("/load-progress", async (req, res) => {
    // In a real app, authenticate user here
    const { username } = req.query;
    if (!username) {
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    try {
        const data = await fs.readFile(progressFilePath, "utf-8");
        res.json(JSON.parse(data)); // Send the progress data back
    } catch (error) {
        if (error.code === "ENOENT") {
            // It's not an error if a user has no saved progress yet
            return res.status(200).json(null); // Send null or an empty object, client should handle this
        }
        console.error(`Error loading progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error loading progress.",
        });
    }
});

async function startServer() {
    const staticData = await DataLoader.loadAllData();
    gameConfig.staticWeaponsData = staticData.weapons;

    const worldManager = new WorldManager(
        io,
        staticData.systemsBase,
        staticData.tradeGoods,
        gameConfig,
    );

    const playerManager = new PlayerManager(
        io,
        staticData.shipTypes,
        staticData.tradeGoods,
        gameConfig,
        worldManager,
    );

    const economyManager = new EconomyManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const missionManager = new MissionManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const combatManager = new CombatManager(
        io,
        playerManager,
        missionManager,
        staticData.weapons,
        gameConfig,
    );

    worldManager.initialize(economyManager, missionManager);

    setInterval(
        () => economyManager.updateAllPlanetEconomies(),
        gameConfig.ECONOMY_UPDATE_INTERVAL_MS,
    );
    setInterval(
        () => missionManager.populateAllPlanetMissions(),
        gameConfig.MISSION_GENERATION_INTERVAL_MS,
    );
    setInterval(
        () => playerManager.checkAllPlayerMissionTimeouts(missionManager),
        gameConfig.PLAYER_MISSION_CHECK_INTERVAL_MS,
    );

    io.on("connection", (socket) => {
        const initialWorldData = {
            systems: worldManager.getSystemsForClient(), // This now includes universe map data
            economies: worldManager.getEconomiesForClient(),
        };
        playerManager.handleConnection(socket, initialWorldData);

        economyManager.registerSocketHandlers(socket);
        missionManager.registerSocketHandlers(socket);
        combatManager.registerSocketHandlers(socket);
        worldManager.registerSocketHandlers(socket, playerManager);

        socket.on("disconnect", () => {
            playerManager.handleDisconnect(socket);
        });
    });

    serverHttp.listen(gameConfig.PORT, () =>
        console.log(
            `Server structured and listening on port ${gameConfig.PORT}`,
        ),
    );
}

startServer().catch((error) => {
    console.error("Failed to start server:", error);
    process.exit(1);
});


/* ===== END: hypernova/server/server.js ===== */


/* ===== START: hypernova/server/config/game_config.js ===== */
module.exports = {
    PORT: 3000,
    MISSION_TYPES: {
        CARGO_DELIVERY: "CARGO_DELIVERY",
        BOUNTY: "BOUNTY",
    },
    MAX_MISSIONS_PER_PLANET: 3,
    MISSION_GENERATION_INTERVAL_MS: 2 * 60 * 1000, // 2 minutes
    MISSION_TIME_LIMIT_BASE_MS: 5 * 60 * 1000, // 5 minutes
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS: 1 * 60 * 1000, // 1 minute

    ECONOMY_UPDATE_INTERVAL_MS: 1 * 60 * 1000, // 1 minute
    PLAYER_MISSION_CHECK_INTERVAL_MS: 30 * 1000, // 30 seconds

    INITIAL_STOCK_BASE: 1000,
    STOCK_PRODUCED_MULTIPLIER: 2.0,
    STOCK_CONSUMED_MULTIPLIER: 0.5,
    PRICE_SUPPLY_FACTOR_LOW: 0.7,
    PRICE_DEMAND_FACTOR_HIGH: 1.4,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER: 0.5,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER: 2.5,
    PLANET_PROFIT_MARGIN: 0.05,

    DEFAULT_PLAYER_CREDITS: 1000,
    DEFAULT_PLAYER_SHIP_TYPE_INDEX: 0, // Scout
    PLAYER_SPAWN_X: 400,
    PLAYER_SPAWN_Y: 300,

    // Hyperjump configuration
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED: 22500, // (150px)^2
    HYPERJUMP_CHARGE_TIME_MS: 3000, // 3 seconds
    // MAP_WIDTH: 800, // Example, if needed for arrival points
    // MAP_HEIGHT: 600, // Example
};


/* ===== END: hypernova/server/config/game_config.js ===== */


/* ===== START: hypernova/server/data/ship_types.json ===== */
[
    {
        "name": "Scout",
        "price": 0,
        "speedMult": 1.1,
        "rotMult": 1.5,
        "revMult": 2.5,
        "maxCargo": 10,
        "maxHealth": 100,
        "imageFile": "scout_ship.png",
        "imgWidth": 32,
        "imgHeight": 32
    },
    {
        "name": "Trader",
        "price": 2000,
        "speedMult": 1.0,
        "rotMult": 1.0,
        "revMult": 2.0,
        "maxCargo": 30,
        "maxHealth": 100
    },
    {
        "name": "Freighter",
        "price": 5000,
        "speedMult": 0.7,
        "rotMult": 0.7,
        "revMult": 1.5,
        "maxCargo": 60,
        "maxHealth": 100
    },
    {
        "name": "Interceptor",
        "price": 1500,
        "speedMult": 1.8,
        "rotMult": 1.8,
        "revMult": 2.2,
        "maxCargo": 5,
        "maxHealth": 120
    },
    {
        "name": "Heavy Freighter",
        "price": 10000,
        "speedMult": 0.5,
        "rotMult": 0.5,
        "revMult": 1.0,
        "maxCargo": 100,
        "maxHealth": 150
    }
]


/* ===== END: hypernova/server/data/ship_types.json ===== */


/* ===== START: hypernova/server/data/systems_init.json ===== */
[
    {
        "name": "George's World (THX-1138)",
        "universeX": 80,
        "universeY": 150,
        "connections": [1, 5],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Planet Alpha",
                "x": 300,
                "y": 300,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.0,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Satori",
        "universeX": 200,
        "universeY": 150,
        "connections": [0, 2, 4],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Satoria Prime",
                "x": 250,
                "y": 400,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 0.9,
                "produces": ["Ore"],
                "consumes": ["Medicine"]
            }
        ]
    },
    {
        "name": "Persephone",
        "universeX": 300,
        "universeY": 120,
        "connections": [1, 3, 16, 17],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Persephone II",
                "x": 400,
                "y": 200,
                "imageFile": "planet_lush_green.png",
                "planetImageScale": 1.1,
                "produces": ["Medicine"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Zaphod",
        "universeX": 350,
        "universeY": 200,
        "connections": [2, 4, 8, 15],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Zaphod Beeblebrox",
                "x": 500,
                "y": 350,
                "imageFile": "planet_cityscape_advanced.png",
                "planetImageScale": 1.2,
                "produces": ["Electronics"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Alkaid",
        "universeX": 280,
        "universeY": 250,
        "connections": [1, 3, 5, 7],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Alkaid VII",
                "x": 300,
                "y": 500,
                "imageFile": "planet_ice.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Clotho",
        "universeX": 200,
        "universeY": 280,
        "connections": [0, 4, 6],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Clotho's Thread",
                "x": 150,
                "y": 300,
                "imageFile": "planet_desert_oasis.png",
                "planetImageScale": 0.9,
                "produces": ["Food"],
                "consumes": ["Medicine"]
            }
        ]
    },
    {
        "name": "Orion",
        "universeX": 250,
        "universeY": 350,
        "connections": [5, 7, 9],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Orion Nebula Port",
                "x": 400,
                "y": 400,
                "imageFile": "planet_terran.png",
                "planetImageScale": 1.1,
                "produces": ["Medicine", "Food"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Curzon",
        "universeX": 350,
        "universeY": 320,
        "connections": [4, 6, 8, 11],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Dax Station",
                "x": 550,
                "y": 250,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Risa",
        "universeX": 380,
        "universeY": 280,
        "connections": [3, 7, 14],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Pleasure Planet",
                "x": 600,
                "y": 450,
                "imageFile": "planet_lush_green.png",
                "planetImageScale": 1.3,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Atropos",
        "universeX": 150,
        "universeY": 400,
        "connections": [6, 10],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Atropos Prime",
                "x": 200,
                "y": 200,
                "imageFile": "planet_barren_ancient.png",
                "planetImageScale": 0.8,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Darven",
        "universeX": 300,
        "universeY": 420,
        "connections": [9, 11, 29],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Darven's Pass",
                "x": 350,
                "y": 350,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.0,
                "produces": ["Food", "Medicine"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Propus",
        "universeX": 450,
        "universeY": 380,
        "connections": [7, 10, 12, 28],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Propus Major",
                "x": 500,
                "y": 500,
                "imageFile": "planet_red_desert.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Polaris",
        "universeX": 500,
        "universeY": 350,
        "connections": [11, 13, 14, 43],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "North Star Port",
                "x": 600,
                "y": 200,
                "imageFile": "planet_ice.png",
                "planetImageScale": 1.1,
                "produces": ["Electronics"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Rigel",
        "universeX": 600,
        "universeY": 350,
        "connections": [12, 22, 23, 43],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Rigel Kentaurus",
                "x": 700,
                "y": 300,
                "imageFile": "planet_terran.png",
                "planetImageScale": 1.2,
                "produces": ["Food", "Medicine"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Matar",
        "universeX": 550,
        "universeY": 300,
        "connections": [8, 12, 15, 19],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Matar IV",
                "x": 400,
                "y": 550,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 0.9,
                "produces": ["Ore"],
                "consumes": ["Electronics", "Medicine"]
            }
        ]
    },
    {
        "name": "Yemuro",
        "universeX": 500,
        "universeY": 250,
        "connections": [3, 14, 16, 18],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Yemuro Station",
                "x": 300,
                "y": 150,
                "imageFile": "planet_cityscape_advanced.png",
                "planetImageScale": 1.1,
                "produces": ["Electronics"],
                "consumes": ["Food", "Ore"]
            }
        ]
    },
    {
        "name": "Turin",
        "universeX": 500,
        "universeY": 150,
        "connections": [2, 15, 17, 18],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Turin's Shroud",
                "x": 450,
                "y": 250,
                "imageFile": "planet_ice.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Cygnus",
        "universeX": 550,
        "universeY": 100,
        "connections": [2, 16, 41, 42],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Cygnus X-1",
                "x": 600,
                "y": 100,
                "imageFile": "planet_barren_ancient.png",
                "planetImageScale": 0.9,
                "produces": ["Electronics"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Kathoon",
        "universeX": 600,
        "universeY": 180,
        "connections": [15, 16, 19, 20],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Kathoon Prime",
                "x": 700,
                "y": 200,
                "imageFile": "planet_desert_oasis.png",
                "planetImageScale": 1.0,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Levo",
        "universeX": 650,
        "universeY": 300,
        "connections": [14, 18, 21, 22],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Levo System",
                "x": 800,
                "y": 400,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.1,
                "produces": ["Medicine", "Food"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Spica",
        "universeX": 700,
        "universeY": 200,
        "connections": [18, 21, 41],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Spica Colony",
                "x": 900,
                "y": 150,
                "imageFile": "planet_lush_green.png",
                "planetImageScale": 1.2,
                "produces": ["Food"],
                "consumes": ["Electronics", "Medicine"]
            }
        ]
    },
    {
        "name": "Vulcan",
        "universeX": 750,
        "universeY": 300,
        "connections": [19, 20, 22, 40],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Vulcanis",
                "x": 850,
                "y": 350,
                "imageFile": "planet_red_desert.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Food", "Electronics"]
            }
        ]
    },
    {
        "name": "Capella",
        "universeX": 700,
        "universeY": 400,
        "connections": [13, 19, 21, 23, 24, 39],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Capella IV",
                "x": 800,
                "y": 500,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 0.9,
                "produces": ["Ore", "Electronics"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Centauri",
        "universeX": 600,
        "universeY": 450,
        "connections": [13, 22, 24, 28, 29],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Alpha Centauri",
                "x": 700,
                "y": 600,
                "imageFile": "planet_terran.png",
                "planetImageScale": 1.1,
                "produces": ["Food", "Medicine", "Electronics"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Barnard",
        "universeX": 680,
        "universeY": 480,
        "connections": [22, 23, 25, 39],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Barnard's Star",
                "x": 750,
                "y": 700,
                "imageFile": "planet_ice.png",
                "planetImageScale": 0.8,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Eridani",
        "universeX": 700,
        "universeY": 520,
        "connections": [24, 26, 27, 39],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Epsilon Eridani",
                "x": 850,
                "y": 650,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.0,
                "produces": ["Food"],
                "consumes": ["Electronics", "Medicine"]
            }
        ]
    },
    {
        "name": "Procyon",
        "universeX": 700,
        "universeY": 600,
        "connections": [25, 27, 31, 37],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Procyon B",
                "x": 800,
                "y": 800,
                "imageFile": "planet_cityscape_advanced.png",
                "planetImageScale": 1.2,
                "produces": ["Electronics"],
                "consumes": ["Ore", "Food"]
            }
        ]
    },
    {
        "name": "Sol",
        "universeX": 600,
        "universeY": 550,
        "connections": [25, 26, 28, 30, 31],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Terra",
                "x": 700,
                "y": 750,
                "imageFile": "planet_terran.png",
                "planetImageScale": 1.3,
                "produces": ["Medicine", "Electronics", "Food"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "Sirius",
        "universeX": 550,
        "universeY": 500,
        "connections": [11, 23, 27, 29, 30],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Sirius A",
                "x": 650,
                "y": 650,
                "imageFile": "planet_barren_ancient.png",
                "planetImageScale": 0.9,
                "produces": ["Ore"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Altair",
        "universeX": 500,
        "universeY": 450,
        "connections": [10, 11, 23, 28, 43],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Altair IV Outpost",
                "x": 550,
                "y": 550,
                "imageFile": "planet_desert_oasis.png",
                "planetImageScale": 1.0,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Diphidia",
        "universeX": 500,
        "universeY": 600,
        "connections": [27, 28, 31, 32, 34],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Diphidia Mining",
                "x": 600,
                "y": 700,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Tau Ceti",
        "universeX": 600,
        "universeY": 620,
        "connections": [26, 27, 30, 32, 35],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Tau Ceti e",
                "x": 750,
                "y": 850,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.1,
                "produces": ["Food", "Medicine"],
                "consumes": ["Electronics", "Ore"]
            }
        ]
    },
    {
        "name": "Antares",
        "universeX": 550,
        "universeY": 650,
        "connections": [30, 31, 33, 34, 35],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Antares Trade Hub",
                "x": 650,
                "y": 900,
                "imageFile": "planet_cityscape_advanced.png",
                "planetImageScale": 1.2,
                "produces": ["Electronics"],
                "consumes": ["Food", "Ore"]
            }
        ]
    },
    {
        "name": "Mentos",
        "universeX": 480,
        "universeY": 680,
        "connections": [32, 34, 44],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Mentos Prime",
                "x": 500,
                "y": 800,
                "imageFile": "planet_ice.png",
                "planetImageScale": 0.9,
                "produces": ["Ore"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Canopus",
        "universeX": 400,
        "universeY": 700,
        "connections": [30, 32, 33, 36, 38],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Canopus Station",
                "x": 450,
                "y": 950,
                "imageFile": "planet_terran.png",
                "planetImageScale": 1.0,
                "produces": ["Food", "Medicine"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Pollux",
        "universeX": 600,
        "universeY": 720,
        "connections": [31, 32, 36, 37, 45],
        "backgroundFile": "green_nebula_background.png",
        "planets": [
            {
                "name": "Pollux IV",
                "x": 700,
                "y": 900,
                "imageFile": "planet_lush_green.png",
                "planetImageScale": 1.1,
                "produces": ["Food"],
                "consumes": ["Ore", "Electronics"]
            }
        ]
    },
    {
        "name": "Castor",
        "universeX": 550,
        "universeY": 750,
        "connections": [34, 35, 45],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Gemini Port (Castor)",
                "x": 600,
                "y": 850,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    },
    {
        "name": "Vega",
        "universeX": 700,
        "universeY": 700,
        "connections": [26, 35, 39, 46],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Vega Colony",
                "x": 800,
                "y": 750,
                "imageFile": "planet_temperate.png",
                "planetImageScale": 1.1,
                "produces": ["Food", "Medicine"],
                "consumes": ["Electronics"]
            }
        ]
    },
    {
        "name": "Olympus",
        "universeX": 300,
        "universeY": 750,
        "connections": [34, 47],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Mount Olympus Base",
                "x": 350,
                "y": 900,
                "imageFile": "planet_barren_ancient.png",
                "planetImageScale": 0.9,
                "produces": ["Ore"],
                "consumes": ["Food", "Electronics"]
            }
        ]
    },
    {
        "name": "Tiber",
        "universeX": 450,
        "universeY": 780,
        "connections": [34, 38, 45],
        "backgroundFile": "deep_space_blue.png",
        "planets": [
            {
                "name": "Tiberium Mines",
                "x": 500,
                "y": 900,
                "imageFile": "planet_red_desert.png",
                "planetImageScale": 1.0,
                "produces": ["Ore"],
                "consumes": ["Medicine"]
            }
        ]
    },
    {
        "name": "NGC-5465",
        "universeX": 650,
        "universeY": 150,
        "connections": [17, 18, 20, 42],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "NGC-5465 Outpost",
                "x": 750,
                "y": 100,
                "imageFile": "planet_ice.png",
                "planetImageScale": 0.8,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "NGC-1023",
        "universeX": 480,
        "universeY": 80,
        "connections": [2, 17, 42],
        "backgroundFile": "ice_field_background.png",
        "planets": [
            {
                "name": "Listening Array 1023",
                "x": 400,
                "y": 50,
                "imageFile": "planet_cityscape_advanced.png",
                "planetImageScale": 0.7,
                "produces": ["Electronics"],
                "consumes": ["Ore"]
            }
        ]
    },
    {
        "name": "NGC-6484",
        "universeX": 50,
        "universeY": 450,
        "connections": [9],
        "backgroundFile": "purple_nebula_stars.png",
        "planets": [
            {
                "name": "Deep Space 6484",
                "x": 100,
                "y": 400,
                "imageFile": "planet_rocky.png",
                "planetImageScale": 0.7,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Altair",
        "universeX": 500,
        "universeY": 450,
        "connections": [11, 12, 23, 28, 29],
        "backgroundFile": "gold_nebula_background.png",
        "planets": [
            {
                "name": "Altair IV",
                "x": 550,
                "y": 550,
                "imageFile": "planet_desert_oasis.png",
                "planetImageScale": 1,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            }
        ]
    }
]


/* ===== END: hypernova/server/data/systems_init.json ===== */


/* ===== START: hypernova/server/data/trade_goods.json ===== */
[
    { "name": "Food", "basePrice": 10, "mass": 1 },
    { "name": "Ore", "basePrice": 50, "mass": 1 },
    { "name": "Medicine", "basePrice": 100, "mass": 1 },
    { "name": "Electronics", "basePrice": 200, "mass": 1 }
]


/* ===== END: hypernova/server/data/trade_goods.json ===== */


/* ===== START: hypernova/server/data/weapons.json ===== */
{
    "Laser": {
        "name": "Laser",
        "price": 500,
        "damage": 10,
        "range": 140,
        "rpm": 300,
        "color": "#f00",
        "beam": 0.3
    },
    "Plasma": {
        "name": "Plasma",
        "price": 1500,
        "damage": 25,
        "range": 200,
        "rpm": 180,
        "color": "#0ff",
        "beam": 0.3
    },
    "Railgun": {
        "name": "Railgun",
        "price": 3000,
        "damage": 40,
        "range": 280,
        "rpm": 120,
        "color": "#ff0",
        "beam": 0.2
    },
    "FusionGun": {
        "name": "FusionGun",
        "price": 8000,
        "damage": 70,
        "range": 350,
        "rpm": 60,
        "color": "#f0f",
        "beam": 0.15
    }
}



/* ===== END: hypernova/server/data/weapons.json ===== */


/* ===== START: hypernova/server/modules/combat_manager.js ===== */
// server/modules/combat_manager.js
class CombatManager {
    constructor(io, playerManager, missionManager, weaponsData, gameConfig) {
        this.io = io;
        this.playerManager = playerManager;
        this.missionManager = missionManager;
        this.weaponsData = weaponsData;
        this.gameConfig = gameConfig;
    }

    registerSocketHandlers(socket) {
        socket.on("fire", () => {
            const attacker = this.playerManager.getPlayer(socket.id);
            if (
                !attacker ||
                !attacker.activeWeapon ||
                attacker.destroyed ||
                attacker.dockedAtPlanetIdentifier ||
                attacker.hyperjumpState === "charging"
            ) {
                if (attacker && attacker.hyperjumpState === "charging") {
                    socket.emit("actionFailed", {
                        message:
                            "Cannot fire weapons while hyperdrive is charging.",
                    });
                }
                return;
            }

            const weaponStats = this.weaponsData[attacker.activeWeapon];
            if (!weaponStats) return;

            const fwdX = Math.cos(attacker.angle);
            const fwdY = Math.sin(attacker.angle);
            const cosHalfBeam = Math.cos(weaponStats.beam * 0.5);

            const allPlayers = this.playerManager.getAllPlayers();

            for (const targetId in allPlayers) {
                if (targetId === socket.id) continue;

                const target = allPlayers[targetId];
                if (
                    !target ||
                    target.system !== attacker.system ||
                    target.destroyed ||
                    target.dockedAtPlanetIdentifier
                )
                    continue;

                const dx = target.x - attacker.x;
                const dy = target.y - attacker.y;
                const dist = Math.hypot(dx, dy);

                if (dist === 0 || dist > weaponStats.range) continue;

                const dirToTargetX = dx / dist;
                const dirToTargetY = dy / dist;
                const dotProduct = fwdX * dirToTargetX + fwdY * dirToTargetY;

                if (dotProduct < cosHalfBeam) continue;

                target.health -= weaponStats.damage;
                let targetDestroyedThisShot = false;

                if (target.health > 0 && target.hyperjumpState === "charging") {
                    this.playerManager.handlePlayerHitDuringHyperjumpCharge(
                        target.id,
                    );
                }

                if (target.health <= 0) {
                    target.health = 0;
                    target.destroyed = true;
                    targetDestroyedThisShot = true;

                    if (
                        target.hyperjumpState === "charging" &&
                        target.hyperjumpChargeTimeoutId
                    ) {
                        clearTimeout(target.hyperjumpChargeTimeoutId);
                        target.hyperjumpChargeTimeoutId = null;
                        target.hyperjumpState = "idle";
                        console.log(
                            `Hyperjump charge for destroyed player ${target.id} cleared.`,
                        );
                    }
                    console.log(
                        `Player ${target.id} destroyed by ${attacker.id}`,
                    );
                }

                this.playerManager.updatePlayerState(target.id, {
                    // Changed to updatePlayerState for broader sync
                    health: target.health,
                    destroyed: target.destroyed,
                    hyperjumpState: target.hyperjumpState, // ensure hyperjump state is also synced if changed
                });

                if (targetDestroyedThisShot) {
                    this.missionManager.handleTargetDestroyed(attacker, target);
                }
                break;
            }

            // Emit projectile to all players in the attacker's system
            const systemPlayers = Object.values(allPlayers).filter(
                (p) => p.system === attacker.system,
            );
            systemPlayers.forEach((p) => {
                this.io.to(p.id).emit("projectile", {
                    x: attacker.x,
                    y: attacker.y,
                    angle: attacker.angle,
                    color: weaponStats.color,
                    range: weaponStats.range,
                    shooterId: attacker.id,
                });
            });
        });
    }
}

module.exports = CombatManager;


/* ===== END: hypernova/server/modules/combat_manager.js ===== */


/* ===== START: hypernova/server/modules/economy_manager.js ===== */
// server/modules/economy_manager.js
const {
    INITIAL_STOCK_BASE,
    STOCK_PRODUCED_MULTIPLIER,
    STOCK_CONSUMED_MULTIPLIER,
    PRICE_SUPPLY_FACTOR_LOW,
    PRICE_DEMAND_FACTOR_HIGH,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER,
    PLANET_PROFIT_MARGIN,
} = require("../config/game_config");

class EconomyManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager; // To get/update planet data
        this.playerManager = playerManager; // To update player credits/cargo
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
    }

    getTradeGoodByName(goodName) {
        return this.tradeGoods.find((g) => g.name === goodName);
    }

    calculatePricesForGoodOnPlanet(planet, goodName) {
        const good = this.getTradeGoodByName(goodName);
        if (!good) return;

        let baseValuation = good.basePrice;
        if (planet.produces.includes(goodName))
            baseValuation *= PRICE_SUPPLY_FACTOR_LOW;
        else if (planet.consumes.includes(goodName))
            baseValuation *= PRICE_DEMAND_FACTOR_HIGH;

        let targetStock = INITIAL_STOCK_BASE;
        if (planet.produces.includes(goodName))
            targetStock *= STOCK_PRODUCED_MULTIPLIER;
        if (planet.consumes.includes(goodName))
            targetStock *= STOCK_CONSUMED_MULTIPLIER;
        targetStock = Math.max(1, targetStock);

        let stockEffectMultiplier = 1.0;
        if (planet.stock[goodName] > 0) {
            stockEffectMultiplier = targetStock / planet.stock[goodName];
        } else {
            stockEffectMultiplier = PRICE_STOCK_MAX_EFFECT_MULTIPLIER * 2; // High price if no stock
        }
        stockEffectMultiplier = Math.max(
            PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
            Math.min(PRICE_STOCK_MAX_EFFECT_MULTIPLIER, stockEffectMultiplier),
        );

        const planetInternalValue = Math.round(
            baseValuation * stockEffectMultiplier,
        );
        planet.buyPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 + PLANET_PROFIT_MARGIN)),
        );
        planet.sellPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 - PLANET_PROFIT_MARGIN)),
        );

        if (planet.buyPrices[goodName] <= planet.sellPrices[goodName]) {
            planet.buyPrices[goodName] = planet.sellPrices[goodName] + 1;
        }
        if (planet.sellPrices[goodName] <= 0) planet.sellPrices[goodName] = 1;
    }

    initializeAllPlanetEconomies(systems) {
        // `systems` is the live array from WorldManager
        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let initialStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        initialStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        initialStock *= STOCK_CONSUMED_MULTIPLIER;
                    planet.stock[good.name] = Math.floor(
                        Math.max(10, initialStock),
                    );
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });
        console.log("Planet economies initialized by EconomyManager.");
    }

    updateAllPlanetEconomies() {
        // Called by interval in server.js
        const systems = this.worldManager.systems; // Get live systems data
        if (!systems || systems.length === 0) return;

        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let targetStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        targetStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        targetStock *= STOCK_CONSUMED_MULTIPLIER;
                    targetStock = Math.max(1, targetStock);

                    const currentStock = planet.stock[good.name] || 0;
                    const diff = targetStock - currentStock;
                    let change = Math.round(diff * 0.02); // Slow adjustment
                    if (change === 0 && diff !== 0) change = diff > 0 ? 1 : -1;

                    planet.stock[good.name] = currentStock + change;
                    planet.stock[good.name] = Math.max(
                        0,
                        Math.min(planet.stock[good.name], targetStock * 5),
                    ); // Cap stock
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });

        this.io.emit(
            "updatePlanetEconomies",
            this.worldManager.getEconomiesForClient(),
        );
        // console.log("Planet economies updated and broadcasted.");
    }

    notifyPlanetEconomyUpdate(systemIndex, planetIndex) {
        const planet = this.worldManager.getPlanet(systemIndex, planetIndex);
        if (planet) {
            this.io.emit("planetEconomyUpdate", {
                systemIndex,
                planetIndex,
                name: planet.name, // Though client might not use name here
                buyPrices: planet.buyPrices,
                sellPrices: planet.sellPrices,
                stock: planet.stock,
            });
        }
    }

    registerSocketHandlers(socket) {
        socket.on(
            "buyGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.buyPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not sold here.",
                    });
                const totalCost = pricePerUnit * quantity;

                const currentCargoMass = player.cargo.reduce(
                    (sum, val, idx) => sum + this.tradeGoods[idx].mass * val,
                    0,
                );
                const newGoodMass = goodInfo.mass * quantity;

                if (player.credits < totalCost)
                    return socket.emit("tradeError", {
                        message: "Not enough credits.",
                    });
                if (currentCargoMass + newGoodMass > player.maxCargo)
                    return socket.emit("tradeError", {
                        message: "Not enough cargo space.",
                    });
                if (
                    !planet.stock[goodName] ||
                    planet.stock[goodName] < quantity
                )
                    return socket.emit("tradeError", {
                        message: "Planet out of stock.",
                    });

                player.credits -= totalCost;
                player.cargo[goodIdx] += quantity;
                planet.stock[goodName] -= quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        // For immediate UI update on client
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );

        socket.on(
            "sellGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }
                if (player.cargo[goodIdx] < quantity)
                    return socket.emit("tradeError", {
                        message: "Not enough goods to sell.",
                    });

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.sellPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not bought here.",
                    });

                const totalGain = pricePerUnit * quantity;

                player.credits += totalGain;
                player.cargo[goodIdx] -= quantity;
                planet.stock[goodName] += quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );
    }
}

module.exports = EconomyManager;


/* ===== END: hypernova/server/modules/economy_manager.js ===== */


/* ===== START: hypernova/server/modules/mission_manager.js ===== */
// server/modules/mission_manager.js
const { generateMissionId, getSystemDistance } = require("../utils/helpers");
const {
    MISSION_TYPES,
    MAX_MISSIONS_PER_PLANET,
    MISSION_TIME_LIMIT_BASE_MS,
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS,
} = require("../config/game_config");

class MissionManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager;
        this.playerManager = playerManager;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig; // For other mission params if any
    }

    generateCargoDeliveryMission(
        originSystemIndex,
        originPlanetIndex,
        systems,
    ) {
        const numSystems = systems.length;
        if (
            numSystems === 0 ||
            (numSystems === 1 && systems[0].planets.length < 2)
        )
            return null;

        let destSystemIndex, destPlanetIndex;
        let attempts = 0;
        const originSystem = systems[originSystemIndex];
        const originPlanet = originSystem.planets[originPlanetIndex];

        do {
            destSystemIndex = Math.floor(Math.random() * numSystems);
            const destSystem = systems[destSystemIndex];
            if (!destSystem || destSystem.planets.length === 0) {
                attempts++;
                continue;
            }
            destPlanetIndex = Math.floor(
                Math.random() * destSystem.planets.length,
            );
            attempts++;
        } while (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex &&
            numSystems > 1 &&
            systems[destSystemIndex].planets.length > 1 && // only try again if there are other options
            attempts < 20
        );

        // If still same after attempts (e.g. only one planet in one system, or two planets total)
        if (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex
        )
            return null;

        const goodIndex = Math.floor(Math.random() * this.tradeGoods.length);
        const goodToDeliver = this.tradeGoods[goodIndex];
        const quantity = Math.floor(Math.random() * 5) + 2; // 2 to 6 units

        const distance = getSystemDistance(
            originSystemIndex,
            destSystemIndex,
            numSystems,
        );
        const rewardCredits =
            goodToDeliver.basePrice * quantity * 1.5 + distance * 150 + 100;
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const destPlanet = systems[destSystemIndex].planets[destPlanetIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.CARGO_DELIVERY,
            title: `Deliver ${quantity} ${goodToDeliver.name} to ${destPlanet.name} (${systems[destSystemIndex].name})`,
            description: `Transport ${quantity} units of ${goodToDeliver.name} from ${originPlanet.name} (${originSystem.name}) to ${destPlanet.name} (${systems[destSystemIndex].name}).`,
            originSystemIndex,
            originPlanetIndex,
            destinationSystemIndex: destSystemIndex,
            destinationPlanetIndex: destPlanetIndex,
            cargoGoodName: goodToDeliver.name,
            cargoQuantity: quantity,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.3),
            timeLimit: timeLimit,
            status: "AVAILABLE", // Initial status
        };
    }

    generateBountyMission(originSystemIndex, originPlanetIndex, systems) {
        const numSystems = systems.length;
        if (numSystems === 0) return null;
        let targetSystemIndex;

        if (numSystems > 1) {
            do {
                targetSystemIndex = Math.floor(Math.random() * numSystems);
            } while (targetSystemIndex === originSystemIndex && numSystems > 1); // Ensure different system if possible
        } else {
            targetSystemIndex = originSystemIndex;
        }

        const numTargets = Math.floor(Math.random() * 2) + 1; // 1 to 2 pirates
        const distance = getSystemDistance(
            originSystemIndex,
            targetSystemIndex,
            numSystems,
        );
        const rewardCredits = numTargets * 500 + distance * 100; // Base reward + distance bonus
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const originPlanet =
            systems[originSystemIndex].planets[originPlanetIndex];
        const originSystem = systems[originSystemIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.BOUNTY,
            title: `Bounty: ${numTargets} Pirate${numTargets > 1 ? "s" : ""} in ${systems[targetSystemIndex].name}`,
            description: `Hostile elements reported in ${systems[targetSystemIndex].name} system. Originated near ${originPlanet.name} (${originSystem.name}). Eliminate ${numTargets} of them.`,
            originSystemIndex,
            originPlanetIndex,
            targetSystemIndex: targetSystemIndex,
            targetShipName: "Pirate", // Generic for now
            targetsRequired: numTargets,
            targetsDestroyed: 0,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.2),
            timeLimit: timeLimit,
            status: "AVAILABLE",
        };
    }

    populateAllPlanetMissions() {
        // Called by interval
        const systems = this.worldManager.systems;
        if (!systems) return;

        systems.forEach((system, sysIdx) => {
            system.planets.forEach((planet, pIdx) => {
                // Filter out expired or already taken missions (though 'taken' is handled on accept)
                planet.availableMissions = planet.availableMissions.filter(
                    (m) => m.status === "AVAILABLE" && m.timeLimit > Date.now(),
                );

                while (
                    planet.availableMissions.length < MAX_MISSIONS_PER_PLANET
                ) {
                    let newMission = null;
                    const missionTypeRoll = Math.random();
                    if (missionTypeRoll < 0.7) {
                        // 70% chance for cargo
                        newMission = this.generateCargoDeliveryMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    } else {
                        newMission = this.generateBountyMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    }
                    if (newMission) {
                        planet.availableMissions.push(newMission);
                    } else {
                        break; // Stop if no mission could be generated (e.g., single planet system for cargo)
                    }
                }
            });
        });
        // console.log("Planet missions populated.");
    }

    checkPlayerMissionTimeouts(player) {
        // player object directly modified
        let missionsChanged = false;
        const completedOrFailed = [];

        player.activeMissions.forEach((mission) => {
            if (
                mission.status === "ACCEPTED" &&
                Date.now() > mission.timeLimit
            ) {
                mission.status = "FAILED_TIME";
                player.credits -= mission.penaltyCredits;
                player.credits = Math.max(0, player.credits);
                missionsChanged = true;
                completedOrFailed.push({
                    missionId: mission.id,
                    status: mission.status,
                    reason: "Time expired.",
                    penalty: mission.penaltyCredits,
                });
            }
        });

        if (missionsChanged) {
            player.activeMissions = player.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
        }
        return { changed: missionsChanged, completedOrFailed };
    }

    checkCargoMissionCompletionOnDock(player, systemIndex, planetIndex) {
        let cargoChanged = false;
        let creditsChanged = false;
        let missionsChanged = false;

        if (player.activeMissions) {
            const remainingMissions = [];
            player.activeMissions.forEach((mission) => {
                if (
                    mission.type === MISSION_TYPES.CARGO_DELIVERY &&
                    mission.status === "ACCEPTED" &&
                    mission.destinationSystemIndex === systemIndex &&
                    mission.destinationPlanetIndex === planetIndex
                ) {
                    const goodIdx = this.tradeGoods.findIndex(
                        (g) => g.name === mission.cargoGoodName,
                    );
                    if (
                        goodIdx !== -1 &&
                        player.cargo[goodIdx] >= mission.cargoQuantity
                    ) {
                        player.cargo[goodIdx] -= mission.cargoQuantity;
                        player.credits += mission.rewardCredits;
                        mission.status = "COMPLETED"; // Mark for removal / notification
                        cargoChanged = true;
                        creditsChanged = true;
                        missionsChanged = true;

                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "COMPLETED",
                            reward: mission.rewardCredits,
                            message: `Delivered ${mission.cargoQuantity} ${mission.cargoGoodName}.`,
                        });
                    } else {
                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "INFO",
                            message: `Need ${mission.cargoQuantity} ${mission.cargoGoodName} to complete. You have ${player.cargo[goodIdx] || 0}.`,
                        });
                        remainingMissions.push(mission); // Keep mission
                    }
                } else {
                    remainingMissions.push(mission); // Keep other missions
                }
            });
            if (missionsChanged) player.activeMissions = remainingMissions;
        }
        return { cargoChanged, creditsChanged, missionsChanged };
    }

    // Called by CombatManager when a target is destroyed
    handleTargetDestroyed(attackerPlayer, destroyedTargetPlayer) {
        let missionsUpdated = false;
        const completedBountiesForNotification = [];
        const attacker = this.playerManager.getPlayer(attackerPlayer.id); // Get live player object
        if (!attacker || !attacker.activeMissions) return;

        attacker.activeMissions.forEach((mission) => {
            if (
                mission.type === MISSION_TYPES.BOUNTY &&
                mission.status === "ACCEPTED" &&
                mission.targetSystemIndex === attacker.system
            ) {
                // Check if in correct system

                // For now, any player kill in the target system counts for "Pirate" bounty
                // Later, you might check `destroyedTargetPlayer.type` or if it's an NPC
                mission.targetsDestroyed = (mission.targetsDestroyed || 0) + 1;
                missionsUpdated = true;

                if (mission.targetsDestroyed >= mission.targetsRequired) {
                    mission.status = "COMPLETED";
                    attacker.credits += mission.rewardCredits;
                    completedBountiesForNotification.push({
                        missionId: mission.id,
                        status: "COMPLETED",
                        reward: mission.rewardCredits,
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                        message: "Bounty completed!",
                    });
                } else {
                    // Send progress update
                    this.io.to(attacker.id).emit("missionUpdate", {
                        missionId: mission.id,
                        status: "ACCEPTED", // Still accepted, just progress
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                    });
                }
            }
        });

        if (missionsUpdated) {
            completedBountiesForNotification.forEach((update) =>
                this.io.to(attacker.id).emit("missionUpdate", update),
            );

            const oldMissionCount = attacker.activeMissions.length;
            attacker.activeMissions = attacker.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
            const newMissionCount = attacker.activeMissions.length;

            const playerUpdates = { credits: attacker.credits };
            if (oldMissionCount !== newMissionCount) {
                playerUpdates.activeMissions = attacker.activeMissions;
            }
            this.playerManager.updatePlayerState(attacker.id, playerUpdates);
        }
    }

    registerSocketHandlers(socket) {
        socket.on("requestMissions", ({ systemIndex, planetIndex }) => {
            const player = this.playerManager.getPlayer(socket.id);
            const planet = this.worldManager.getPlanet(
                systemIndex,
                planetIndex,
            );

            if (!player || !planet) {
                return socket.emit("actionFailed", {
                    message: "Invalid location for missions.",
                });
            }

            const availableMissions = planet.availableMissions.filter(
                (m) =>
                    m.timeLimit > Date.now() && // Not expired
                    (!player.activeMissions ||
                        !player.activeMissions.find((pm) => pm.id === m.id)), // Not already active for player
            );
            socket.emit("availableMissionsList", {
                systemIndex,
                planetIndex,
                missions: availableMissions,
            });
        });

        socket.on(
            "acceptMission",
            ({ missionId, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );

                if (!player || !planet) {
                    return socket.emit("actionFailed", {
                        message: "Cannot accept mission from this location.",
                    });
                }

                const missionIndex = planet.availableMissions.findIndex(
                    (m) => m.id === missionId,
                );
                if (missionIndex === -1) {
                    return socket.emit("actionFailed", {
                        message: "Mission not available or already taken.",
                    });
                }

                const missionToAccept = planet.availableMissions[missionIndex];

                if (missionToAccept.timeLimit < Date.now()) {
                    planet.availableMissions.splice(missionIndex, 1); // Remove expired
                    return socket.emit("actionFailed", {
                        message: "Mission has expired.",
                    });
                }
                if (player.activeMissions.length >= 5) {
                    // Max active missions limit
                    return socket.emit("actionFailed", {
                        message: "Too many active missions.",
                    });
                }

                missionToAccept.status = "ACCEPTED";
                if (
                    !missionToAccept.targetsDestroyed &&
                    missionToAccept.type === MISSION_TYPES.BOUNTY
                ) {
                    missionToAccept.targetsDestroyed = 0; // Ensure bounty missions start with 0 destroyed
                }
                player.activeMissions.push({ ...missionToAccept }); // Add a copy to player
                planet.availableMissions.splice(missionIndex, 1); // Remove from planet's available list

                socket.emit("missionAccepted", { mission: missionToAccept });
                this.playerManager.updatePlayerState(socket.id, {
                    activeMissions: player.activeMissions,
                });
            },
        );
    }
}

module.exports = MissionManager;


/* ===== END: hypernova/server/modules/mission_manager.js ===== */


/* ===== START: hypernova/server/modules/player_manager.js ===== */
// server/modules/player_manager.js
const { MISSION_TYPES } = require("../config/game_config");

class PlayerManager {
    constructor(
        io,
        shipTypes,
        tradeGoods,
        gameConfigInstance,
        worldManagerInstance,
    ) {
        this.io = io;
        this.shipTypes = shipTypes;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfigInstance;
        this.players = {};
        this.worldManager = worldManagerInstance;
    }

    handleConnection(socket, initialWorldData = {}) {
        const defaultShipType =
            this.shipTypes[this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX] ||
            this.shipTypes[0];
        this.players[socket.id] = {
            id: socket.id,
            x: this.gameConfig.PLAYER_SPAWN_X || 400,
            y: this.gameConfig.PLAYER_SPAWN_Y || 300,
            angle: 0,
            vx: 0,
            vy: 0,
            type: this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX,
            credits: this.gameConfig.DEFAULT_PLAYER_CREDITS,
            cargo: new Array(this.tradeGoods.length).fill(0),
            maxCargo: defaultShipType.maxCargo,
            health: defaultShipType.maxHealth || 100,
            maxHealth: defaultShipType.maxHealth || 100,
            weapons: [],
            activeMissions: [],
            activeWeapon: null,
            lastShot: 0,
            system: 0,
            dockedAtPlanetIdentifier: null,
            destroyed: false,
            color:
                "#" +
                Math.floor(Math.random() * 0xffffff)
                    .toString(16)
                    .padStart(6, "0"),
            hyperjumpState: "idle", // idle, charging, jumping, cooldown
            hyperjumpChargeTimeoutId: null,
        };

        console.log(
            `Player ${socket.id} connected. Initial ship: ${defaultShipType.name}. Initial credits: ${this.players[socket.id].credits}`,
        );

        socket.emit("init", {
            id: socket.id,
            ships: this.players, // Send all current players
            gameData: {
                ...initialWorldData, // Will include systems with universeX,Y,connections
                tradeGoods: this.tradeGoods,
                weapons: this.gameConfig.staticWeaponsData,
                shipTypes: this.shipTypes,
                MISSION_TYPES: this.gameConfig.MISSION_TYPES,
            },
        });

        socket.broadcast.emit("playerJoined", {
            id: socket.id,
            ship: this.players[socket.id],
        });

        this.registerSocketHandlers(socket);

        socket.on("clientLoadedDockedState", (receivedSyncData) => {
            console.log(
                `PlayerManager: Received 'clientLoadedDockedState' from ${socket.id}.`,
            );
            const player = this.players[socket.id];

            if (player && receivedSyncData) {
                if (receivedSyncData.credits !== undefined)
                    player.credits = receivedSyncData.credits;
                if (receivedSyncData.cargo !== undefined)
                    player.cargo = receivedSyncData.cargo;
                if (receivedSyncData.weapons !== undefined)
                    player.weapons = receivedSyncData.weapons;
                if (receivedSyncData.activeWeapon !== undefined)
                    player.activeWeapon = receivedSyncData.activeWeapon;
                if (receivedSyncData.health !== undefined)
                    player.health = receivedSyncData.health;
                if (receivedSyncData.activeMissions !== undefined)
                    player.activeMissions = receivedSyncData.activeMissions;

                if (receivedSyncData.type !== undefined) {
                    player.type = receivedSyncData.type;
                    const shipTypeDef = this.shipTypes[player.type];
                    if (shipTypeDef) {
                        player.maxCargo = shipTypeDef.maxCargo;
                        player.maxHealth = shipTypeDef.maxHealth;
                        if (player.health > player.maxHealth)
                            player.health = player.maxHealth;
                    }
                }

                player.hyperjumpState = "idle";
                if (player.hyperjumpChargeTimeoutId) {
                    clearTimeout(player.hyperjumpChargeTimeoutId);
                    player.hyperjumpChargeTimeoutId = null;
                }

                if (
                    receivedSyncData.dockedAtDetails &&
                    receivedSyncData.dockedAtDetails.systemIndex !== undefined
                ) {
                    player.dockedAtPlanetIdentifier = {
                        systemIndex:
                            receivedSyncData.dockedAtDetails.systemIndex,
                        planetIndex:
                            receivedSyncData.dockedAtDetails.planetIndex,
                    };
                    player.system =
                        receivedSyncData.dockedAtDetails.systemIndex;
                    const planet = this.worldManager.getPlanet(
                        player.system,
                        player.dockedAtPlanetIdentifier.planetIndex,
                    );
                    if (planet) {
                        player.x = planet.x;
                        player.y = planet.y;
                    }
                    player.vx = 0;
                    player.vy = 0;
                    this.worldManager.playerDockedAtPlanet(
                        player,
                        player.system,
                        player.dockedAtPlanetIdentifier.planetIndex,
                    );
                    console.log(
                        `PlayerManager: ${socket.id} DOCKED at system ${player.system}, planet ${player.dockedAtPlanetIdentifier.planetIndex}.`,
                    );
                } else {
                    player.dockedAtPlanetIdentifier = null;
                    if (receivedSyncData.x !== undefined)
                        player.x = receivedSyncData.x;
                    if (receivedSyncData.y !== undefined)
                        player.y = receivedSyncData.y;
                    if (receivedSyncData.angle !== undefined)
                        player.angle = receivedSyncData.angle;
                    if (receivedSyncData.vx !== undefined)
                        player.vx = receivedSyncData.vx;
                    if (receivedSyncData.vy !== undefined)
                        player.vy = receivedSyncData.vy;
                    if (receivedSyncData.system !== undefined)
                        player.system = receivedSyncData.system;
                    console.log(
                        `PlayerManager: ${socket.id} UNDOCKED in system ${player.system}.`,
                    );
                }
                this.broadcastPlayerState(socket.id, this.players[socket.id]);
            }
        });
    }

    handleDisconnect(socket) {
        const player = this.getPlayer(socket.id);
        if (player) {
            if (player.dockedAtPlanetIdentifier) {
                this.worldManager.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
            if (player.hyperjumpChargeTimeoutId) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
            }
        }
        console.log(`Player ${socket.id} disconnected.`);
        delete this.players[socket.id];
        this.io.emit("playerLeft", socket.id);
    }

    getPlayer(playerId) {
        return this.players[playerId];
    }

    getAllPlayers() {
        return this.players;
    }

    updatePlayerState(playerId, updates) {
        if (this.players[playerId]) {
            Object.assign(this.players[playerId], updates);
            this.io.emit("state", { [playerId]: updates });
        }
    }

    broadcastPlayerState(playerId, fullPlayerData) {
        if (this.players[playerId]) {
            this.io.emit("state", { [playerId]: fullPlayerData });
        }
    }

    registerSocketHandlers(socket) {
        socket.on("control", (data) => {
            const player = this.getPlayer(socket.id);
            if (
                !player ||
                player.dockedAtPlanetIdentifier ||
                player.hyperjumpState === "charging"
            )
                return;

            player.x = data.x;
            player.y = data.y;
            player.vx = data.vx;
            player.vy = data.vy;
            player.angle = data.angle;

            const minimalUpdate = {
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                angle: player.angle,
            };
            socket.broadcast.emit("state", { [socket.id]: minimalUpdate });
        });

        socket.on("requestHyperjump", (data) => {
            // data = { targetSystemIndex: number | null }
            const player = this.getPlayer(socket.id);
            if (!player || player.destroyed) return;

            const targetSystemIndex = data ? data.targetSystemIndex : null;

            if (player.dockedAtPlanetIdentifier) {
                return socket.emit("hyperjumpDenied", {
                    message: "Cannot engage hyperdrive while docked.",
                });
            }
            if (player.hyperjumpState !== "idle") {
                return socket.emit("hyperjumpDenied", {
                    message: "Hyperdrive already engaged or cooling down.",
                });
            }

            const currentSystemDataForProxCheck = this.worldManager.getSystem(
                player.system,
            );
            if (
                currentSystemDataForProxCheck &&
                currentSystemDataForProxCheck.planets
            ) {
                for (const planet of currentSystemDataForProxCheck.planets) {
                    if (!planet) continue;
                    const distSq =
                        (player.x - planet.x) ** 2 + (player.y - planet.y) ** 2;
                    const planetScale = planet.planetImageScale || 1.0; // Use actual scale from planet data
                    const minSafeDistSq =
                        (this.gameConfig
                            .MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED ||
                            22500) *
                        Math.pow(planetScale, 2) *
                        1.5;
                    if (distSq < minSafeDistSq) {
                        return socket.emit("hyperjumpDenied", {
                            message: "Too close to a celestial body.",
                        });
                    }
                }
            }

            if (targetSystemIndex === null || targetSystemIndex === undefined) {
                return socket.emit("hyperjumpDenied", {
                    message: "Target system not specified.",
                });
            }
            if (
                targetSystemIndex < 0 ||
                targetSystemIndex >= this.worldManager.systems.length
            ) {
                return socket.emit("hyperjumpDenied", {
                    message: "Invalid target system index.",
                });
            }
            const currentSystemData = this.worldManager.getSystem(
                player.system,
            ); // Renamed to avoid conflict
            if (
                !currentSystemData ||
                !currentSystemData.connections ||
                !currentSystemData.connections.includes(targetSystemIndex)
            ) {
                return socket.emit("hyperjumpDenied", {
                    message: "No direct hyperlane to the target system.",
                });
            }
            if (targetSystemIndex === player.system) {
                return socket.emit("hyperjumpDenied", {
                    message: "Already in the target system.",
                });
            }

            player.hyperjumpState = "charging";
            this.updatePlayerState(socket.id, { hyperjumpState: "charging" });
            socket.emit("hyperjumpChargeStarted", {
                chargeTime: this.gameConfig.HYPERJUMP_CHARGE_TIME_MS,
            });
            console.log(
                `Player ${socket.id} starting hyperjump charge to system ${targetSystemIndex}.`,
            );

            player.hyperjumpChargeTimeoutId = setTimeout(() => {
                if (player.hyperjumpState !== "charging" || player.destroyed) {
                    player.hyperjumpChargeTimeoutId = null;
                    if (
                        player.hyperjumpState === "charging" &&
                        !player.destroyed
                    ) {
                        player.hyperjumpState = "idle";
                        this.updatePlayerState(socket.id, {
                            hyperjumpState: "idle",
                        });
                    }
                    return;
                }

                player.hyperjumpState = "idle";
                player.hyperjumpChargeTimeoutId = null;

                const oldSystem = player.system;
                player.system = targetSystemIndex;

                let newX,
                    newY,
                    newAngle = 0;
                const arrivalSystemData = this.worldManager.getSystem(
                    player.system,
                );
                const originSystemData = this.worldManager.getSystem(oldSystem);

                newX =
                    (this.gameConfig.PLAYER_SPAWN_X || 400) +
                    (Math.random() * 200 - 100);
                newY =
                    (this.gameConfig.PLAYER_SPAWN_Y || 300) +
                    (Math.random() * 200 - 100);

                if (arrivalSystemData) {
                    if (
                        originSystemData &&
                        originSystemData.universeX !== undefined &&
                        arrivalSystemData.universeX !== undefined &&
                        originSystemData.universeY !== undefined &&
                        arrivalSystemData.universeY !== undefined
                    ) {
                        const dx =
                            arrivalSystemData.universeX -
                            originSystemData.universeX;
                        const dy =
                            arrivalSystemData.universeY -
                            originSystemData.universeY;
                        const dist = Math.hypot(dx, dy);
                        const arrivalOffsetFromCenter =
                            350 + Math.random() * 100;

                        if (dist > 0) {
                            const firstPlanetInArrival =
                                arrivalSystemData.planets[0];
                            const systemCenterX = firstPlanetInArrival
                                ? firstPlanetInArrival.x -
                                  (Math.random() * 100 - 50)
                                : this.gameConfig.PLAYER_SPAWN_X || 400; // A rough center
                            const systemCenterY = firstPlanetInArrival
                                ? firstPlanetInArrival.y -
                                  (Math.random() * 100 - 50)
                                : this.gameConfig.PLAYER_SPAWN_Y || 300;

                            newX =
                                systemCenterX -
                                (dx / dist) * arrivalOffsetFromCenter;
                            newY =
                                systemCenterY -
                                (dy / dist) * arrivalOffsetFromCenter;
                            newAngle = Math.atan2(dy, dx) + Math.PI;
                        } else {
                            const firstPlanet = arrivalSystemData.planets[0];
                            newX =
                                (firstPlanet
                                    ? firstPlanet.x
                                    : this.gameConfig.PLAYER_SPAWN_X || 400) -
                                (200 + Math.random() * 100);
                            newY =
                                (firstPlanet
                                    ? firstPlanet.y
                                    : this.gameConfig.PLAYER_SPAWN_Y || 300) +
                                (Math.random() * 100 - 50);
                            newAngle = 0;
                        }
                    } else {
                        const firstPlanet = arrivalSystemData.planets[0];
                        newX =
                            (firstPlanet
                                ? firstPlanet.x
                                : this.gameConfig.PLAYER_SPAWN_X || 400) - 250;
                        newY = firstPlanet
                            ? firstPlanet.y
                            : this.gameConfig.PLAYER_SPAWN_Y || 300;
                        newAngle = 0;
                    }
                }

                player.x = newX;
                player.y = newY;
                player.vx = 0;
                player.vy = 0;
                player.angle = newAngle;
                player.dockedAtPlanetIdentifier = null;

                console.log(
                    `Player ${socket.id} hyperjump complete. Old system: ${oldSystem}, New system: ${player.system}. Arrived at ${player.x.toFixed(0)},${player.y.toFixed(0)}.`,
                );

                socket.emit("hyperjumpComplete", {
                    newSystem: player.system,
                    newX: player.x,
                    newY: player.y,
                    newAngle: player.angle,
                });

                this.broadcastPlayerState(socket.id, player);
            }, this.gameConfig.HYPERJUMP_CHARGE_TIME_MS);
        });

        socket.on("cancelHyperjump", () => {
            const player = this.getPlayer(socket.id);
            if (
                player &&
                player.hyperjumpState === "charging" &&
                player.hyperjumpChargeTimeoutId
            ) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
                player.hyperjumpState = "idle";
                this.updatePlayerState(socket.id, { hyperjumpState: "idle" });
                socket.emit("hyperjumpCancelled", {
                    message: "Hyperjump cancelled by player.",
                });
                console.log(`Player ${socket.id} cancelled hyperjump charge.`);
            }
        });

        socket.on("equipWeapon", ({ weapon: weaponName }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message:
                        "Cannot modify equipment while hyperdrive is active.",
                });
            }
            const weaponData = this.gameConfig.staticWeaponsData[weaponName];
            if (!weaponData)
                return socket.emit("actionFailed", {
                    message: "Invalid weapon.",
                });

            if (!player.weapons.includes(weaponName)) {
                if (player.credits >= weaponData.price) {
                    player.credits -= weaponData.price;
                    player.weapons.push(weaponName);
                    player.activeWeapon = weaponName;
                    this.updatePlayerState(socket.id, {
                        credits: player.credits,
                        weapons: player.weapons,
                        activeWeapon: player.activeWeapon,
                    });
                    socket.emit("actionSuccess", {
                        message: `Purchased and equipped ${weaponName}.`,
                    });
                } else {
                    return socket.emit("actionFailed", {
                        message: "Not enough credits.",
                    });
                }
            } else {
                player.activeWeapon = weaponName;
                this.updatePlayerState(socket.id, {
                    activeWeapon: player.activeWeapon,
                });
                socket.emit("actionSuccess", {
                    message: `Equipped ${weaponName}.`,
                });
            }
        });

        socket.on("buyShip", ({ shipTypeIndex }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot buy ship while hyperdrive is active.",
                });
            }
            if (shipTypeIndex < 0 || shipTypeIndex >= this.shipTypes.length) {
                return socket.emit("actionFailed", {
                    message: "Invalid ship type.",
                });
            }
            const newShipType = this.shipTypes[shipTypeIndex];
            if (player.credits < newShipType.price) {
                return socket.emit("actionFailed", {
                    message: "Not enough credits.",
                });
            }
            player.credits -= newShipType.price;
            player.type = shipTypeIndex;
            player.maxCargo = newShipType.maxCargo;
            player.cargo = new Array(this.tradeGoods.length).fill(0);
            player.maxHealth = newShipType.maxHealth || 100;
            player.health = player.maxHealth;
            player.weapons = [];
            player.activeWeapon = null;

            this.updatePlayerState(socket.id, {
                credits: player.credits,
                type: player.type,
                maxCargo: player.maxCargo,
                cargo: player.cargo,
                maxHealth: player.maxHealth,
                health: player.health,
                weapons: player.weapons,
                activeWeapon: player.activeWeapon,
            });
            socket.emit("actionSuccess", {
                message: `Successfully purchased ${newShipType.name}.`,
            });
        });
    }

    checkAllPlayerMissionTimeouts(missionManager) {
        Object.values(this.players).forEach((player) => {
            if (
                player &&
                !player.destroyed &&
                player.activeMissions.length > 0
            ) {
                const { changed, completedOrFailed } =
                    missionManager.checkPlayerMissionTimeouts(player);
                if (changed) {
                    completedOrFailed.forEach((update) =>
                        this.io.to(player.id).emit("missionUpdate", update),
                    );
                    this.updatePlayerState(player.id, {
                        credits: player.credits,
                        activeMissions: player.activeMissions,
                    });
                }
            }
        });
    }

    handlePlayerHitDuringHyperjumpCharge(playerId) {
        const player = this.getPlayer(playerId);
        if (
            player &&
            player.hyperjumpState === "charging" &&
            player.hyperjumpChargeTimeoutId
        ) {
            clearTimeout(player.hyperjumpChargeTimeoutId);
            player.hyperjumpChargeTimeoutId = null;
            player.hyperjumpState = "idle";
            this.updatePlayerState(playerId, { hyperjumpState: "idle" });
            this.io
                .to(playerId)
                .emit("hyperjumpCancelled", {
                    message: "Hyperjump disrupted by enemy fire!",
                });
            console.log(
                `Player ${playerId} hyperjump charge disrupted by damage.`,
            );
        }
    }
}

module.exports = PlayerManager;

/* ===== END: hypernova/server/modules/player_manager.js ===== */


/* ===== START: hypernova/server/modules/world_manager.js ===== */
// server/modules/world_manager.js
class WorldManager {
    constructor(io, systemsBase, tradeGoods, gameConfig) {
        this.io = io;
        this.systemsBase = systemsBase;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
        this.systems = [];
        this.economyManager = null;
        this.missionManager = null;
    }

    initialize(economyManager, missionManager) {
        this.economyManager = economyManager;
        this.missionManager = missionManager;
        this.systems = JSON.parse(JSON.stringify(this.systemsBase));

        this.systems.forEach((system) => {
            // Ensure new fields exist if not in base JSON (though we added them)
            if (system.universeX === undefined)
                system.universeX = Math.random() * 1000;
            if (system.universeY === undefined)
                system.universeY = Math.random() * 1000;
            if (!system.connections) system.connections = [];

            system.planets.forEach((planet) => {
                planet.stock = {};
                planet.buyPrices = {};
                planet.sellPrices = {};
                planet.availableMissions = [];
                planet.dockedShipId = null;
            });
        });

        this.economyManager.initializeAllPlanetEconomies(this.systems);
        this.missionManager.populateAllPlanetMissions(this.systems); // Pass systems here if needed by populate

        console.log("WorldManager initialized, systems processed.");
    }

    getSystem(systemIndex) {
        return this.systems[systemIndex];
    }

    getPlanet(systemIndex, planetIndex) {
        const system = this.getSystem(systemIndex);
        return system ? system.planets[planetIndex] : null;
    }

    getPlanetDetailsForDocking(systemIndex, planetIndex) {
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (planet) {
            return { x: planet.x, y: planet.y, name: planet.name };
        }
        return null;
    }

    playerDockedAtPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            console.error(
                "WorldManager.playerDockedAtPlanet: Player object is null/undefined.",
            );
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            console.error(
                `WorldManager.playerDockedAtPlanet: Planet ${planetIndex} in system ${systemIndex} not found.`,
            );
            return false;
        }

        if (planet.dockedShipId && planet.dockedShipId !== player.id) {
            console.warn(
                `WorldManager.playerDockedAtPlanet: Planet ${planet.name} is already occupied by ${planet.dockedShipId}. Player ${player.id} cannot dock.`,
            );
            return false;
        }

        if (player.dockedAtPlanetIdentifier) {
            if (
                player.dockedAtPlanetIdentifier.systemIndex !== systemIndex ||
                player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
            ) {
                this.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
        }

        planet.dockedShipId = player.id;
        console.log(
            `WorldManager: Player ${player.id} server-side DOCKED at ${planet.name} (System: ${this.systems[systemIndex].name}).`,
        );
        return true;
    }

    playerUndockedFromPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            return false;
        }

        if (planet.dockedShipId === player.id) {
            planet.dockedShipId = null;
            console.log(
                `WorldManager: Player ${player.id} server-side UNDOCKED from ${planet.name}.`,
            );
            return true;
        }
        return false;
    }

    getSystemsForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            // Pass new universe map data
            universeX: s.universeX,
            universeY: s.universeY,
            connections: s.connections,
            // Existing planet data for in-system view
            planets: s.planets.map((p) => ({
                name: p.name,
                x: p.x,
                y: p.y,
                imageFile: p.imageFile,
                planetImageScale: p.planetImageScale,
            })),
            backgroundFile: s.backgroundFile, // Make sure backgroundFile is also passed
        }));
    }

    getEconomiesForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            planets: s.planets.map((p) => ({
                name: p.name,
                stock: p.stock,
                buyPrices: p.buyPrices,
                sellPrices: p.sellPrices,
            })),
        }));
    }

    registerSocketHandlers(socket, playerManager) {
        socket.on("dock", ({ systemIndex, planetIndex }) => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });

            if (player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot dock while hyperdrive is charging.",
                });
            }

            if (player.system !== systemIndex) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Wrong system.",
                });
            }
            const planet = this.getPlanet(systemIndex, planetIndex);
            if (!planet) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Planet not found.",
                });
            }

            if (this.playerDockedAtPlanet(player, systemIndex, planetIndex)) {
                player.dockedAtPlanetIdentifier = { systemIndex, planetIndex };
                player.vx = 0;
                player.vy = 0;
                player.x = planet.x;
                player.y = planet.y;

                const missionCompletionResult =
                    this.missionManager.checkCargoMissionCompletionOnDock(
                        player,
                        systemIndex,
                        planetIndex,
                    );

                socket.emit("dockConfirmed", {
                    systemIndex,
                    planetIndex,
                    planetName: planet.name,
                    systemName: this.systems[systemIndex].name,
                    buyPrices: planet.buyPrices,
                    sellPrices: planet.sellPrices,
                    stock: planet.stock,
                    playerX: player.x,
                    playerY: player.y,
                });

                const updatesForPlayer = {
                    dockedAtPlanetIdentifier: player.dockedAtPlanetIdentifier,
                    vx: 0,
                    vy: 0,
                    x: player.x,
                    y: player.y,
                };
                if (missionCompletionResult.creditsChanged)
                    updatesForPlayer.credits = player.credits;
                if (missionCompletionResult.cargoChanged)
                    updatesForPlayer.cargo = player.cargo;
                if (missionCompletionResult.missionsChanged)
                    updatesForPlayer.activeMissions = player.activeMissions;

                playerManager.updatePlayerState(socket.id, updatesForPlayer);
            } else {
                socket.emit("actionFailed", {
                    message: "Docking failed. Planet may be occupied.",
                });
            }
        });

        socket.on("undock", () => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });
            if (!player.dockedAtPlanetIdentifier) {
                return socket.emit("actionFailed", {
                    message: "Not docked (according to server).",
                });
            }
            const { systemIndex, planetIndex } =
                player.dockedAtPlanetIdentifier;
            if (
                this.playerUndockedFromPlanet(player, systemIndex, planetIndex)
            ) {
                player.dockedAtPlanetIdentifier = null;
                socket.emit("undockConfirmed");
                playerManager.updatePlayerState(socket.id, {
                    dockedAtPlanetIdentifier: null,
                });
            } else {
                socket.emit("actionFailed", {
                    message: "Server undocking failed.",
                });
            }
        });
    }
}

module.exports = WorldManager;


/* ===== END: hypernova/server/modules/world_manager.js ===== */


/* ===== START: hypernova/server/utils/data_loader.js ===== */
const fs = require("fs").promises;
const path = require("path");

const dataDir = path.join(__dirname, "../data");

async function loadJson(filename) {
    const filePath = path.join(dataDir, filename);
    try {
        const fileContent = await fs.readFile(filePath, "utf-8");
        return JSON.parse(fileContent);
    } catch (error) {
        console.error(`Error loading data file ${filename}:`, error);
        throw error; // Or return null/empty object depending on desired error handling
    }
}

async function loadAllData() {
    try {
        const [tradeGoods, weapons, systemsBase, shipTypes] = await Promise.all(
            [
                loadJson("trade_goods.json"),
                loadJson("weapons.json"),
                loadJson("systems_init.json"),
                loadJson("ship_types.json"),
            ],
        );
        return { tradeGoods, weapons, systemsBase, shipTypes };
    } catch (error) {
        console.error("Failed to load critical game data. Exiting.", error);
        process.exit(1);
    }
}

module.exports = {
    loadAllData,
};


/* ===== END: hypernova/server/utils/data_loader.js ===== */


/* ===== START: hypernova/server/utils/helpers.js ===== */
function generateMissionId() {
    return `mission_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// Note: systemsData is the live systems array from WorldManager
function getSystemDistance(systemIndex1, systemIndex2, numSystems) {
    if (numSystems === 0) return 0;
    const diff = Math.abs(systemIndex1 - systemIndex2);
    return Math.min(diff, numSystems - diff);
}

module.exports = {
    generateMissionId,
    getSystemDistance,
};


/* ===== END: hypernova/server/utils/helpers.js ===== */


/* ===== START: hypernova/client/js/universe_map_renderer.js ===== */
// hypernova/client/js/universe_map_renderer.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";

let mapCanvas = null;
let mapCtx = null;
let initialized = false;

// Map display constants
const SYSTEM_RADIUS_ON_SCREEN = 8;
const SYSTEM_NAME_FONT = "12px Courier New"; // Base size, scaled later
const SYSTEM_NAME_COLOR = "#99FFFF";
const CONNECTION_LINE_COLOR = "rgba(100, 100, 200, 0.4)";
const CONNECTION_LINE_WIDTH = 1.5; // Base width, scaled later
const PLAYER_SYSTEM_COLOR = "#00FF00";
const SELECTED_SYSTEM_COLOR = "#FFFF00"; // For manual jump target
const ROUTE_SYSTEM_COLOR = "#FFA500"; // Orange for systems in route
const ROUTE_LINE_COLOR = "rgba(255, 165, 0, 0.8)";
const ROUTE_LINE_WIDTH = 2.5; // Base width, scaled later
const INVALID_JUMP_TARGET_COLOR = "#FF6666"; // For manual jump if invalid

// Button properties (drawn on canvas)
const BUTTON_WIDTH = 170; // Adjusted for longer text
const BUTTON_HEIGHT = 35;
const BUTTON_MARGIN = 20;
const BUTTON_BG_COLOR = "rgba(0, 80, 120, 0.9)";
const BUTTON_BORDER_COLOR = "rgba(0, 150, 200, 1)";
const BUTTON_TEXT_COLOR = "#CCFFFF";
const BUTTON_FONT = "bold 14px Courier New";

let mapButtons = []; // To store button rects and actions

export const UniverseMapRenderer = {
    init(canvasElement) {
        mapCanvas = canvasElement;
        if (!mapCanvas) {
            console.error(
                "UniverseMapCanvas element not found for renderer init.",
            );
            return;
        }
        mapCtx = mapCanvas.getContext("2d");
        this.resizeMap(); // Set initial size
        initialized = true;
        console.log("UniverseMapRenderer initialized.");

        mapCanvas.addEventListener("click", (e) => this.handleMapClick(e));
    },

    resizeMap() {
        if (!mapCanvas) return;
        mapCanvas.width = window.innerWidth;
        mapCanvas.height = window.innerHeight;
        this.prepareButtons();
        if (gameState.isMapOpen) this.draw();
    },

    prepareButtons() {
        mapButtons = [];
        const topY = BUTTON_MARGIN;
        const secondY = topY + BUTTON_HEIGHT + BUTTON_MARGIN / 2;
        const thirdY = secondY + BUTTON_HEIGHT + BUTTON_MARGIN / 2;

        mapButtons.push({
            id: "closeButton",
            text: "Close Map (M/Esc)",
            x: mapCanvas.width - BUTTON_WIDTH - BUTTON_MARGIN,
            y: topY,
            width: BUTTON_WIDTH,
            height: BUTTON_HEIGHT,
            action: () => UniverseMapManager.closeMap(),
        });

        mapButtons.push({
            id: "jumpButton", // This is for manual single jump
            text: "Manual Hyperjump",
            x: mapCanvas.width - BUTTON_WIDTH - BUTTON_MARGIN,
            y: secondY,
            width: BUTTON_WIDTH,
            height: BUTTON_HEIGHT,
            action: () => {
                if (
                    gameState.mapSelectedSystemIndex !== null &&
                    gameState.myShip &&
                    !gameState.isChargingHyperjump // Check if already charging
                ) {
                    const currentSystemData =
                        gameState.clientGameData.systems[
                            gameState.myShip.system
                        ];
                    const targetSystemData =
                        gameState.clientGameData.systems[
                            gameState.mapSelectedSystemIndex
                        ];
                    if (
                        currentSystemData &&
                        targetSystemData &&
                        currentSystemData.connections &&
                        currentSystemData.connections.includes(
                            gameState.mapSelectedSystemIndex,
                        ) &&
                        gameState.mapSelectedSystemIndex !==
                            gameState.myShip.system
                    ) {
                        Network.requestHyperjump(
                            gameState.mapSelectedSystemIndex,
                        );
                        // If a route was active, clear it because this is a manual override
                        if (gameState.plannedRoute.length > 0) {
                            gameState.plannedRoute = [];
                            gameState.currentRouteLegIndex = -1;
                            console.log("Route cleared due to manual jump.");
                        }
                        UniverseMapManager.closeMap();
                    } else {
                        alert(
                            "Cannot jump: Target system is not directly connected or is current system.",
                        );
                    }
                } else if (gameState.isChargingHyperjump) {
                    alert("Hyperdrive is already charging!");
                }
            },
        });

        mapButtons.push({
            id: "clearRouteButton",
            text: "Clear Route",
            x: mapCanvas.width - BUTTON_WIDTH - BUTTON_MARGIN,
            y: thirdY,
            width: BUTTON_WIDTH,
            height: BUTTON_HEIGHT,
            action: () => {
                gameState.plannedRoute = [];
                gameState.currentRouteLegIndex = -1;
                UniverseMapRenderer.draw(); // Redraw to reflect cleared route
            },
        });
    },

    draw() {
        if (!mapCtx || !initialized || !gameState.isMapOpen) return;

        mapCtx.fillStyle = "rgba(0, 5, 10, 0.97)";
        mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

        const systems = gameState.clientGameData.systems;
        if (!systems || systems.length === 0) {
            mapCtx.fillStyle = SYSTEM_NAME_COLOR;
            mapCtx.font = "16px Courier New";
            mapCtx.textAlign = "center";
            mapCtx.fillText(
                "No system data available.",
                mapCanvas.width / 2,
                mapCanvas.height / 2,
            );
            this.drawButtons();
            return;
        }

        let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
        systems.forEach((sys) => {
            if (sys.universeX === undefined) return;
            if (sys.universeX < minX) minX = sys.universeX;
            if (sys.universeX > maxX) maxX = sys.universeX;
            if (sys.universeY < minY) minY = sys.universeY;
            if (sys.universeY > maxY) maxY = sys.universeY;
        });

        if (minX === Infinity) {
            // No systems with coordinates
            mapCtx.fillStyle = SYSTEM_NAME_COLOR;
            mapCtx.font = "16px Courier New";
            mapCtx.textAlign = "center";
            mapCtx.fillText(
                "System coordinate data missing.",
                mapCanvas.width / 2,
                mapCanvas.height / 2,
            );
            this.drawButtons();
            return;
        }

        const dataWidth = Math.max(1, maxX - minX);
        const dataHeight = Math.max(1, maxY - minY);
        const dataCenterX = minX + dataWidth / 2;
        const dataCenterY = minY + dataHeight / 2;

        const padding = 60;
        const availableWidth = mapCanvas.width - 2 * padding;
        const availableHeight = mapCanvas.height - 2 * padding;

        let scale = 1;
        if (dataWidth > 0 && dataHeight > 0) {
            scale = Math.min(
                availableWidth / dataWidth,
                availableHeight / dataHeight,
            );
        } else if (dataWidth > 0) {
            scale = availableWidth / dataWidth;
        } else if (dataHeight > 0) {
            scale = availableHeight / dataHeight;
        }
        scale = Math.min(scale, 2.5);
        scale = Math.max(scale, 0.2);

        const viewCenterX = mapCanvas.width / 2;
        const viewCenterY = mapCanvas.height / 2;
        const offsetX = viewCenterX - dataCenterX * scale;
        const offsetY = viewCenterY - dataCenterY * scale;

        mapCtx.save();
        mapCtx.translate(offsetX, offsetY);
        mapCtx.scale(scale, scale);

        // Draw connections
        mapCtx.strokeStyle = CONNECTION_LINE_COLOR;
        mapCtx.lineWidth = CONNECTION_LINE_WIDTH / scale;
        systems.forEach((sys, i) => {
            if (sys.universeX === undefined || !sys.connections) return;
            sys.connections.forEach((targetIndex) => {
                if (
                    targetIndex < systems.length &&
                    systems[targetIndex].universeX !== undefined
                ) {
                    const targetSys = systems[targetIndex];
                    mapCtx.beginPath();
                    mapCtx.moveTo(sys.universeX, sys.universeY);
                    mapCtx.lineTo(targetSys.universeX, targetSys.universeY);
                    mapCtx.stroke();
                }
            });
        });

        // Draw planned route lines
        if (gameState.plannedRoute.length > 1) {
            mapCtx.strokeStyle = ROUTE_LINE_COLOR;
            mapCtx.lineWidth = ROUTE_LINE_WIDTH / scale;
            mapCtx.beginPath();
            const firstSystemInRoute = systems[gameState.plannedRoute[0]];
            if (
                firstSystemInRoute &&
                firstSystemInRoute.universeX !== undefined
            ) {
                mapCtx.moveTo(
                    firstSystemInRoute.universeX,
                    firstSystemInRoute.universeY,
                );
                for (let i = 1; i < gameState.plannedRoute.length; i++) {
                    const nextSystemInRoute =
                        systems[gameState.plannedRoute[i]];
                    if (
                        nextSystemInRoute &&
                        nextSystemInRoute.universeX !== undefined
                    ) {
                        mapCtx.lineTo(
                            nextSystemInRoute.universeX,
                            nextSystemInRoute.universeY,
                        );
                    }
                }
                mapCtx.stroke();
            }
        }

        // Draw systems
        systems.forEach((sys, i) => {
            if (sys.universeX === undefined) return;
            const screenRadius = SYSTEM_RADIUS_ON_SCREEN / scale;
            mapCtx.beginPath();
            mapCtx.arc(
                sys.universeX,
                sys.universeY,
                screenRadius,
                0,
                Math.PI * 2,
            );

            let systemFillColor = SYSTEM_NAME_COLOR; // Default
            if (gameState.plannedRoute.includes(i)) {
                systemFillColor = ROUTE_SYSTEM_COLOR;
                if (
                    gameState.currentRouteLegIndex !== -1 &&
                    gameState.plannedRoute[gameState.currentRouteLegIndex] === i
                ) {
                    systemFillColor = PLAYER_SYSTEM_COLOR; // Highlight next target in route
                }
            } else if (gameState.myShip && gameState.myShip.system === i) {
                systemFillColor = PLAYER_SYSTEM_COLOR;
            } else if (gameState.mapSelectedSystemIndex === i) {
                // For manual jump
                const currentSystemData =
                    gameState.clientGameData.systems[gameState.myShip.system];
                if (
                    currentSystemData &&
                    currentSystemData.connections &&
                    currentSystemData.connections.includes(i)
                ) {
                    systemFillColor = SELECTED_SYSTEM_COLOR;
                } else {
                    systemFillColor = INVALID_JUMP_TARGET_COLOR;
                }
            }
            mapCtx.fillStyle = systemFillColor;
            mapCtx.fill();
            mapCtx.strokeStyle = systemFillColor;
            mapCtx.lineWidth = CONNECTION_LINE_WIDTH / 2 / scale;
            mapCtx.stroke();

            mapCtx.fillStyle = SYSTEM_NAME_COLOR;
            mapCtx.font = `${SYSTEM_NAME_FONT.split(" ")[0].replace("px", "")}px ${SYSTEM_NAME_FONT.split(" ").slice(1).join(" ")}`; // Apply scale to font size
            mapCtx.textAlign = "center";
            mapCtx.textBaseline = "bottom";
            mapCtx.fillText(
                sys.name,
                sys.universeX,
                sys.universeY - (screenRadius + 5 / scale),
            );
        });
        mapCtx.restore();

        this.drawButtons();
    },

    drawButtons() {
        mapButtons.forEach((button) => {
            let currentButtonBgColor = BUTTON_BG_COLOR;
            let currentButtonTextColor = BUTTON_TEXT_COLOR;
            let buttonIsEnabled = true;

            if (button.id === "jumpButton") {
                // Manual jump button
                buttonIsEnabled =
                    !gameState.isChargingHyperjump &&
                    gameState.mapSelectedSystemIndex !== null &&
                    gameState.myShip &&
                    gameState.mapSelectedSystemIndex !==
                        gameState.myShip.system;
                if (buttonIsEnabled) {
                    // Further check for connection
                    const currentSystemData =
                        gameState.clientGameData.systems[
                            gameState.myShip.system
                        ];
                    const targetSystemData =
                        gameState.clientGameData.systems[
                            gameState.mapSelectedSystemIndex
                        ];
                    buttonIsEnabled =
                        currentSystemData &&
                        targetSystemData &&
                        currentSystemData.connections &&
                        currentSystemData.connections.includes(
                            gameState.mapSelectedSystemIndex,
                        );
                }
            } else if (button.id === "clearRouteButton") {
                buttonIsEnabled = gameState.plannedRoute.length > 0;
            }

            mapCtx.globalAlpha = buttonIsEnabled ? 1.0 : 0.5;
            currentButtonBgColor = buttonIsEnabled
                ? BUTTON_BG_COLOR
                : "rgba(80, 80, 80, 0.8)";

            mapCtx.fillStyle = currentButtonBgColor;
            mapCtx.strokeStyle = BUTTON_BORDER_COLOR;
            mapCtx.lineWidth = 1;
            mapCtx.fillRect(button.x, button.y, button.width, button.height);
            mapCtx.strokeRect(button.x, button.y, button.width, button.height);

            mapCtx.fillStyle = buttonIsEnabled
                ? BUTTON_TEXT_COLOR
                : "rgba(150,150,150,1)";
            mapCtx.font = BUTTON_FONT;
            mapCtx.textAlign = "center";
            mapCtx.textBaseline = "middle";
            mapCtx.fillText(
                button.text,
                button.x + button.width / 2,
                button.y + button.height / 2,
            );

            mapCtx.globalAlpha = 1.0;
        });
        mapCtx.textAlign = "left";
        mapCtx.textBaseline = "alphabetic";
    },

    handleMapClick(event) {
        if (!mapCanvas || !initialized || !gameState.isMapOpen) return;

        const rect = mapCanvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickY = event.clientY - rect.top;

        let buttonClicked = false;
        for (const button of mapButtons) {
            if (
                clickX >= button.x &&
                clickX <= button.x + button.width &&
                clickY >= button.y &&
                clickY <= button.y + button.height
            ) {
                let canExecuteButton = true;
                if (button.id === "jumpButton") {
                    canExecuteButton =
                        !gameState.isChargingHyperjump &&
                        gameState.mapSelectedSystemIndex !== null &&
                        gameState.myShip &&
                        gameState.mapSelectedSystemIndex !==
                            gameState.myShip.system;
                    if (canExecuteButton) {
                        const currentSystemData =
                            gameState.clientGameData.systems[
                                gameState.myShip.system
                            ];
                        const targetSystemData =
                            gameState.clientGameData.systems[
                                gameState.mapSelectedSystemIndex
                            ];
                        canExecuteButton =
                            currentSystemData &&
                            targetSystemData &&
                            currentSystemData.connections &&
                            currentSystemData.connections.includes(
                                gameState.mapSelectedSystemIndex,
                            );
                    }
                } else if (button.id === "clearRouteButton") {
                    canExecuteButton = gameState.plannedRoute.length > 0;
                }

                if (canExecuteButton) {
                    button.action();
                }
                buttonClicked = true;
                break;
            }
        }
        if (buttonClicked) {
            if (gameState.isMapOpen) this.draw();
            return;
        }

        const systems = gameState.clientGameData.systems;
        if (!systems || systems.length === 0) return;

        let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
        systems.forEach((sys) => {
            if (sys.universeX === undefined) return;
            if (sys.universeX < minX) minX = sys.universeX;
            if (sys.universeX > maxX) maxX = sys.universeX;
            if (sys.universeY < minY) minY = sys.universeY;
            if (sys.universeY > maxY) maxY = sys.universeY;
        });
        if (minX === Infinity) return;

        const dataWidth = Math.max(1, maxX - minX);
        const dataHeight = Math.max(1, maxY - minY);
        const dataCenterX = minX + dataWidth / 2;
        const dataCenterY = minY + dataHeight / 2;
        const padding = 60;
        const availableWidth = mapCanvas.width - 2 * padding;
        const availableHeight = mapCanvas.height - 2 * padding;
        let scale = 1;
        if (dataWidth > 0 && dataHeight > 0) {
            scale = Math.min(
                availableWidth / dataWidth,
                availableHeight / dataHeight,
            );
        } else if (dataWidth > 0) {
            scale = availableWidth / dataWidth;
        } else if (dataHeight > 0) {
            scale = availableHeight / dataHeight;
        }
        scale = Math.min(scale, 2.5);
        scale = Math.max(scale, 0.2);

        const viewCenterX = mapCanvas.width / 2;
        const viewCenterY = mapCanvas.height / 2;
        const offsetX = viewCenterX - dataCenterX * scale;
        const offsetY = viewCenterY - dataCenterY * scale;

        const mapClickX = (clickX - offsetX) / scale;
        const mapClickY = (clickY - offsetY) / scale;

        let clickedSystemIndex = -1;
        let closestDistSq = ((SYSTEM_RADIUS_ON_SCREEN / scale) * 1.5) ** 2;

        for (let i = 0; i < systems.length; i++) {
            const sys = systems[i];
            if (sys.universeX === undefined) continue;
            const distSq =
                (mapClickX - sys.universeX) ** 2 +
                (mapClickY - sys.universeY) ** 2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                clickedSystemIndex = i;
            }
        }

        if (clickedSystemIndex !== -1) {
            if (event.shiftKey) {
                // Route planning
                if (
                    gameState.myShip &&
                    clickedSystemIndex === gameState.myShip.system &&
                    gameState.plannedRoute.length === 0
                ) {
                    // Prevent starting route in current system if route is empty
                    alert("Cannot start route in your current system.");
                } else if (gameState.plannedRoute.length === 0) {
                    gameState.plannedRoute.push(clickedSystemIndex);
                    gameState.currentRouteLegIndex = 0;
                } else {
                    const lastSystemInRouteIndex =
                        gameState.plannedRoute[
                            gameState.plannedRoute.length - 1
                        ];
                    if (clickedSystemIndex === lastSystemInRouteIndex) {
                        // Clicked last system again: remove it (undo)
                        gameState.plannedRoute.pop();
                        if (gameState.plannedRoute.length === 0) {
                            gameState.currentRouteLegIndex = -1;
                        }
                        // currentRouteLegIndex remains same or becomes -1
                    } else if (
                        !gameState.plannedRoute.includes(clickedSystemIndex)
                    ) {
                        // Not already in route (except for extending)
                        const lastSystemData = systems[lastSystemInRouteIndex];
                        if (
                            lastSystemData &&
                            lastSystemData.connections &&
                            lastSystemData.connections.includes(
                                clickedSystemIndex,
                            )
                        ) {
                            gameState.plannedRoute.push(clickedSystemIndex);
                            // currentRouteLegIndex doesn't change until a jump is made
                        } else {
                            alert(
                                "Cannot add system to route: Not connected to the previous system.",
                            );
                        }
                    } else {
                        alert("System already in route or invalid selection.");
                    }
                }
            } else {
                // Normal click: select for manual jump
                gameState.mapSelectedSystemIndex = clickedSystemIndex;
            }
        }
        this.draw();
    },
};

export const UniverseMapManager = {
    mapContainer: null,

    init() {
        this.mapContainer = document.getElementById("universe-map-container");
        const canvasEl = document.getElementById("universeMapCanvas");
        if (this.mapContainer && canvasEl) {
            UniverseMapRenderer.init(canvasEl);
            window.addEventListener("resize", () =>
                UniverseMapRenderer.resizeMap(),
            );
        } else {
            console.error(
                "Universe map container or canvas not found for UniverseMapManager init.",
            );
        }
    },
    openMap() {
        if (!gameState.myShip) return;
        if (gameState.docked) {
            alert("Cannot open map while docked.");
            return;
        }
        if (gameState.isChargingHyperjump) {
            alert("Cannot open map while hyperdrive is charging.");
            return;
        }
        gameState.isMapOpen = true;
        if (this.mapContainer) this.mapContainer.classList.remove("hidden");
        // Reset manual selection when opening map, but keep route
        gameState.mapSelectedSystemIndex = null;
        UniverseMapRenderer.resizeMap(); // This calls draw
    },
    closeMap() {
        gameState.isMapOpen = false;
        if (this.mapContainer) this.mapContainer.classList.add("hidden");
        // gameState.mapSelectedSystemIndex = null; // Keep selection for now, route persists
    },
    toggleMap() {
        if (gameState.isMapOpen) {
            this.closeMap();
        } else {
            this.openMap();
        }
    },
};

/* ===== END: hypernova/client/js/universe_map_renderer.js ===== */
