

/* ===== START: hypernova/client/index.html ===== */
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HyperNova OS Boot</title>
        <link rel="stylesheet" href="css/style.css" />
        <!-- <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet"> -->
    </head>
    <body>
        <div id="login-screen">
            <canvas id="login-background-canvas"></canvas>

            <div id="login-vfx-container">
                <div class="scanline"></div>
            </div>
            <div class="login-form-container">
                <h2 class="glitch" data-text="SYSTEM ACCESS">SYSTEM ACCESS</h2>
                <form id="login-form">
                    <div>
                        <label for="username">PILOT ID:</label>
                        <input
                            type="text"
                            id="username"
                            name="username"
                            required
                            placeholder="Enter Callsign"
                        />
                    </div>
                    <div>
                        <label for="password">PASSCODE:</label>
                        <input
                            type="password"
                            id="password"
                            name="password"
                            required
                            placeholder="Enter Secure Key"
                        />
                    </div>
                    <!-- Button structure remains similar, CSS will target .cybr-btn -->
                    <button type="submit" class="cybr-btn">
                        Engage
                        <!-- These spans are repurposed by the new CSS for border/shimmer effects -->
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </button>
                </form>
                <p id="login-error" class="login-feedback"></p>
                <p id="login-message" class="login-feedback"></p>
                <div class="footer-text">HyperNova Secure Terminal v2.7.3</div>
            </div>
        </div>

        <div id="game-container" class="hidden">
            <canvas id="gameCanvas"></canvas>
            <div id="ui"></div>
        </div>

        <audio id="login-music" loop>
            <source
                src="assets/audio/upbeat-space-theme.mp3"
                type="audio/mpeg"
            />
            Your browser does not support the audio element.
        </audio>

        <script src="/socket.io/socket.io.js"></script>
        <script type="module" src="js/main.js"></script>
    </body>
</html>

/* ===== END: hypernova/client/index.html ===== */


/* ===== START: hypernova/client/css/style.css ===== */
/* Existing styles from your file */
body {
  margin: 0;
  background-color: #000;
  color: #00FF00; /* Main text color for the game */
  font-family: 'Courier New', Courier, monospace; /* Default monospace font */
  overflow: hidden;
}

/* Optional: If you use a specific sci-fi font like Orbitron */
/*
body, input, button, label, h2 {
  font-family: 'Orbitron', sans-serif;
}
*/

#gameCanvas {
  display: block;
  background: #111; /* Dark background for the game canvas itself */
}
#ui {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
.panel {
  position: absolute;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid #0f0;
  padding: 10px;
  max-width: 480px;
  pointer-events: auto;
  color: #0f0;
  font-family: inherit; /* Inherit from body */
}

/* Default button style (used in game UI panels, not login) */
button { 
  background: #000;
  color: #0f0;
  border: 1px solid #0f0;
  padding: 5px;
  margin: 2px;
  pointer-events: auto;
  font-family: inherit;
}

::selection {
  background: #0f0;
  color: #000;
}
.trade-item-selected {
  background-color: #030;
}
.menu-item {
  padding: 2px 0;
}
.menu-item div {
  padding: 1px 0;
}
body.no-scroll {
  overflow: hidden;
}

/* ===== HYPER COOL SCI-FI LOGIN SCREEN STYLES ===== */

#login-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'Courier New', Courier, monospace; /* Or your chosen sci-fi font */
    overflow: hidden; /* Important for VFX container */
    background-color: #000000; /* Absolute darkest fallback */
    color: #00FF00; /* Primary text color */
}

/* Dynamic Background Canvas */
#login-background-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0; /* Behind everything else on the login screen */
}


/* VFX Container for background effects like scanlines or particles */
#login-vfx-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Doesn't interfere with clicks */
    z-index: 1; /* Above background canvas, below form */
}

/* Scanline effect */
.scanline {
    width: 100%;
    height: 100px; /* Adjust thickness of scanline group */
    position: absolute;
    top: -100px; /* Start off-screen */
    left: 0;
    background: linear-gradient(
        to bottom,
        rgba(20, 100, 200, 0), /* Transparent start */
        rgba(50, 150, 255, 0.08) 40%, /* Faint blueish glow */
        rgba(50, 150, 255, 0.12) 50%,
        rgba(50, 150, 255, 0.08) 60%,
        rgba(20, 100, 200, 0) /* Transparent end */
    );
    animation: scan 7s linear infinite;
    opacity: 0.6;
}

@keyframes scan {
    0% { top: -100px; }
    100% { top: 100%; }
}

/* Login Form Container - The actual box for the form */
.login-form-container {
    position: relative; /* For z-index stacking above VFX */
    z-index: 2; /* Above background and VFX */
    background: rgba(5, 15, 30, 0.85); /* Dark, slightly transparent */
    padding: 30px 40px;
    border-radius: 8px;
    border: 1px solid rgba(0, 255, 255, 0.3); /* Cyan border */
    box-shadow: 0 0 25px rgba(0, 200, 255, 0.3), 
                inset 0 0 15px rgba(0, 150, 200, 0.2);
    text-align: center;
    width: 380px; /* Fixed width for the form */
    animation: fadeInForm 1s ease-out forwards;
}

@keyframes fadeInForm {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

#login-screen h2 { /* This targets the H2 inside login-form-container */
    font-size: 2em;
    color: #66FFFF; /* Bright Cyan */
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 30px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    padding-bottom: 15px;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}

/* Glitch effect for H2 */
.glitch {
    position: relative;
    color: #66FFFF;
    text-shadow: 0 0 5px #66FFFF, 0 0 10px #66FFFF;
}
.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: inherit; /* Inherit background from .login-form-container */
    overflow: hidden;
}
.glitch::before {
    left: 2px;
    text-shadow: -1px 0 red;
    animation: glitch-anim-1 2s infinite linear alternate-reverse;
}
.glitch::after {
    left: -2px;
    text-shadow: -1px 0 blue, 2px 2px yellow;
    animation: glitch-anim-2 2s infinite linear alternate-reverse;
}

@keyframes glitch-anim-1 {
    0% { clip: rect(35px, 9999px, 92px, 0); }
    25% { clip: rect(32px, 9999px, 1px, 0); }
    50% { clip: rect(45px, 9999px, 36px, 0); }
    75% { clip: rect(11px, 9999px, 5px, 0); }
    100% { clip: rect(62px, 9999px, 77px, 0); }
}
@keyframes glitch-anim-2 {
    0% { clip: rect(70px, 9999px, 10px, 0); }
    25% { clip: rect(3px, 9999px, 48px, 0); }
    50% { clip: rect(90px, 9999px, 50px, 0); }
    75% { clip: rect(22px, 9999px, 79px, 0); }
    100% { clip: rect(5px, 9999px, 60px, 0); }
}


#login-form div {
    margin-bottom: 20px;
    display: flex;
    flex-direction: column; /* Stack label above input */
    align-items: flex-start; /* Align label to the left */
}

#login-form label {
    display: block; /* Make label take full width available */
    width: auto; /* Override previous fixed width */
    margin-right: 0;
    margin-bottom: 8px; /* Space between label and input */
    color: #00AACC; /* Medium Cyan */
    font-size: 0.9em;
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: left;
}

#login-form input[type="text"],
#login-form input[type="password"] {
    background-color: rgba(0, 50, 70, 0.5); /* Darker, more transparent input */
    border: 1px solid #007799; /* Darker Cyan border */
    color: #99FFFF; /* Lighter Cyan text */
    padding: 12px 15px;
    font-family: inherit;
    border-radius: 4px;
    width: calc(100% - 30px); /* Full width minus padding */
    box-shadow: inset 0 0 8px rgba(0, 100, 150, 0.3);
    transition: border-color 0.3s, box-shadow 0.3s;
    caret-color: #66FFFF; /* Cursor color */
}

#login-form input[type="text"]::placeholder,
#login-form input[type="password"]::placeholder {
    color: #007799;
    opacity: 0.7;
}

#login-form input[type="text"]:focus,
#login-form input[type="password"]:focus {
    outline: none;
    border-color: #66FFFF; /* Bright Cyan on focus */
    box-shadow: 0 0 10px rgba(102, 255, 255, 0.5), 
                inset 0 0 10px rgba(102, 255, 255, 0.3);
}

/* ===== NEW FANCY SCI-FI ENGAGE BUTTON ===== */
/* This replaces the previous .cybr-btn styles */
.cybr-btn {
    --btn-color-primary: #00f2ea; /* Bright Teal/Cyan */
    --btn-color-secondary: #7DF9FF; /* Electric Blue / Lighter Cyan */
    --btn-glow-color: rgba(0, 242, 234, 0.5);
    --btn-bg-color: rgba(10, 30, 50, 0.6); /* Slightly transparent dark blue */
    --btn-border-size: 2px;

    position: relative;
    padding: 12px 30px;
    margin-top: 25px; /* Space above button */
    font-family: 'Courier New', Courier, monospace; /* Or your preferred sci-fi font */
    font-size: 1.1em;
    font-weight: bold;
    color: var(--btn-color-primary);
    background-color: var(--btn-bg-color);
    border: var(--btn-border-size) solid var(--btn-color-primary);
    border-radius: 5px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    cursor: pointer;
    outline: none;
    overflow: hidden; /* Important for pseudo-elements */
    transition: color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    z-index: 1; /* Ensure it's above other elements if needed */
}

/* Animated top/bottom border lines */
.cybr-btn::before,
.cybr-btn::after {
    content: '';
    position: absolute;
    width: 0;
    height: var(--btn-border-size);
    background-color: var(--btn-color-secondary);
    transition: width 0.4s ease-out;
    z-index: -1; /* Behind the text */
}

.cybr-btn::before { /* Top line */
    top: 0;
    left: 50%; 
    transform: translateX(-50%);
}

.cybr-btn::after { /* Bottom line */
    bottom: 0;
    right: 50%; 
    transform: translateX(50%);
}

.cybr-btn:hover::before,
.cybr-btn:hover::after {
    width: 105%; 
}

/* Side border shimmer elements (repurposing the spans from HTML) */
.cybr-btn span[aria-hidden="true"] {
    display: block;
    position: absolute;
    width: var(--btn-border-size);
    height: 0%;
    background-color: var(--btn-color-secondary);
    opacity: 0;
    transition: height 0.4s ease-out 0.2s, opacity 0.3s ease-out 0.2s; /* Delayed start */
}

/* Left shimmer (targets the first span) */
.cybr-btn span[aria-hidden="true"]:first-of-type {
    top: 50%;
    left: 0;
    transform: translateY(-50%);
}

/* Right shimmer (targets the second span) */
.cybr-btn span[aria-hidden="true"]:nth-of-type(2) {
    bottom: 50%; /* Start from bottom, animates upwards */
    right: 0;
    transform: translateY(50%);
}

.cybr-btn:hover span[aria-hidden="true"] {
    height: 105%; /* Animate to full height + a bit more */
    opacity: 1;
}

.cybr-btn:hover {
    color: #ffffff; /* White text on hover */
    background-color: rgba(0, 242, 234, 0.15); /* More intense background glow */
    border-color: var(--btn-color-secondary);
    box-shadow: 0 0 15px var(--btn-glow-color), 0 0 25px var(--btn-glow-color);
}

.cybr-btn:active {
    color: var(--btn-color-primary);
    background-color: rgba(0, 242, 234, 0.25);
    box-shadow: 0 0 5px var(--btn-glow-color), inset 0 0 10px var(--btn-glow-color);
    transform: translateY(1px); /* Slight press effect */
}
/* ===== END OF NEW BUTTON STYLES ===== */


#login-error, #login-message {
    margin-top: 20px;
    min-height: 1.2em;
    font-size: 0.9em;
    letter-spacing: 0.5px;
}
#login-error {
    color: #FF6666; /* Softer Red */
    text-shadow: 0 0 5px #FF6666;
}
#login-message {
    color: #66FF99; /* Softer Green */
    text-shadow: 0 0 5px #66FF99;
}
.login-feedback { /* Common styling for error/message */
    opacity: 0;
    transition: opacity 0.5s;
}
.login-feedback:not(:empty) { /* Show if not empty */
    opacity: 1;
}


.footer-text {
    margin-top: 30px;
    font-size: 0.75em;
    color: rgba(0, 255, 255, 0.4); /* Dim Cyan */
    letter-spacing: 1px;
}


.hidden {
    display: none !important;
}

/* Ensure game container takes full space when visible */
#game-container {
    width: 100%;
    height: 100%;
}

/* Universe Map Specific (if ever HTML based, good to have a placeholder) */
.universe-map-container {
    /* Styles if the map were an HTML overlay */
}
.system-entry {
    /* Styles for individual system entries if HTML */
}
/* ===== END: hypernova/client/css/style.css ===== */


/* ===== START: hypernova/client/js/client_config.js ===== */
// client/js/client_config.js
export const BASE_THRUST = 0.1;
export const BASE_ROTATION_SPEED = 0.07;
export const DAMPING = 0.99;
export const PROJECTILE_LIFESPAN_MS = 400; // ms
export const DOCKING_DISTANCE_SQUARED = 400; // (20px)^2
export const MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED = 22500; // (150px)^2 - adjust as needed
export const HYPERJUMP_CHARGE_TIME_MS = 3000; // 3 seconds
export const HYPERJUMP_DENIED_MESSAGE_DURATION_MS = 3000; // 3 seconds

/* ===== END: hypernova/client/js/client_config.js ===== */


/* ===== START: hypernova/client/js/game_state.js ===== */
// hypernova/client/js/game_state.js
export const gameState = {
    currentUser: null, // NEW: Will store { username: "string" } after login
    socket: null, // Will be set by network.js
    myId: null,
    allShips: {}, // Store all ship objects, including myShip
    get myShip() {
        // Getter for convenience
        return this.allShips[this.myId];
    },
    projectiles: [],
    loadedImages: {}, // To store Image objects: { 'filename.png': ImageElement }
    imagePathsToLoad: [], // To collect all image paths

    // Game data received from server
    clientGameData: {
        systems: [],
        tradeGoods: [],
        weapons: {},
        shipTypes: [],
        MISSION_TYPES: {},
    },
    clientPlanetEconomies: [],

    // UI related state
    docked: false,
    dockedAtDetails: null,
    isMenuOpen: false,
    activeSubMenu: null,

    // Selection indices for menus
    selectedTradeIndex: 0,
    selectedWeaponKey: null,
    selectedShipIndex: 0,
    selectedMissionIndex: 0,
    availableMissionsForCurrentPlanet: [],

    // Input state
    weaponCycleIdx: 0,
    controls: {
        rotatingLeft: false,
        rotatingRight: false,
        accelerating: false,
        decelerating: false,
    },

    // Hyperjump state
    isChargingHyperjump: false,
    hyperjumpChargeStartTime: null,
    hyperjumpDeniedMessage: null,
    hyperjumpDeniedMessageTimeoutId: null,

    updateShipData(id, data) {
        // console.log(`game_state.js/updateShipData called for ID: ${id}, with data:`, JSON.stringify(data));
        if (!this.allShips[id]) {
            // console.log(`game_state.js/updateShipData: Ship ${id} not found, creating.`);
            this.allShips[id] = {};
        }
        Object.assign(this.allShips[id], data);
        // console.log(`game_state.js/updateShipData: Ship ${id} after assign:`, JSON.stringify(this.allShips[id]));

        if (this.allShips[id]) {
            // Ensure ship exists before calling defaultShipProps
            // console.log(`game_state.js/updateShipData: Calling defaultShipProps for ship ${id}. Current gameState.docked: ${this.docked}`);
            this.defaultShipProps(this.allShips[id]);
        }
    },

    defaultShipProps(ship) {
        if (!ship) {
            // console.warn("game_state.js/defaultShipProps: Called with null/undefined ship.");
            return;
        }
        // console.log(`game_state.js/defaultShipProps called for ship (type: ${ship.type}). Current ship state: ${JSON.stringify(ship)}. Current gameState.docked: ${this.docked}`);

        const currentShipTypeData =
            this.clientGameData.shipTypes &&
            ship.type !== undefined &&
            ship.type !== null
                ? this.clientGameData.shipTypes[ship.type]
                : null;
        // console.log("game_state.js/defaultShipProps: currentShipTypeData:", JSON.stringify(currentShipTypeData));

        if (ship.system === undefined) ship.system = 0;
        // dockedAtPlanetIdentifier is specific to the ship object, not the global gameState.docked
        if (ship.dockedAtPlanetIdentifier === undefined)
            ship.dockedAtPlanetIdentifier = null;

        if (currentShipTypeData) {
            if (ship.maxHealth === undefined)
                ship.maxHealth = currentShipTypeData.maxHealth || 100;
            if (ship.health === undefined || ship.health > ship.maxHealth)
                ship.health = ship.maxHealth;
            if (ship.maxCargo === undefined)
                ship.maxCargo = currentShipTypeData.maxCargo || 10;
        } else {
            // console.warn("game_state.js/defaultShipProps: No currentShipTypeData found for ship type:", ship.type, "Using generic defaults.");
            if (ship.maxHealth === undefined) ship.maxHealth = 100;
            if (ship.health === undefined) ship.health = 100;
            if (ship.maxCargo === undefined) ship.maxCargo = 10;
        }

        if (ship.credits === undefined) ship.credits = 0;

        if (
            this.clientGameData.tradeGoods &&
            this.clientGameData.tradeGoods.length > 0
        ) {
            if (
                !ship.cargo ||
                ship.cargo.length !== this.clientGameData.tradeGoods.length
            ) {
                // console.log("game_state.js/defaultShipProps: Initializing/resizing ship.cargo array.");
                ship.cargo = new Array(
                    this.clientGameData.tradeGoods.length,
                ).fill(0);
            }
        } else if (!ship.cargo) {
            // console.log("game_state.js/defaultShipProps: No trade goods data, initializing ship.cargo to empty array.");
            ship.cargo = [];
        }

        if (!ship.weapons) ship.weapons = [];
        if (!ship.activeWeapon && ship.weapons.length > 0)
            ship.activeWeapon = ship.weapons[0];
        if (!ship.activeMissions) ship.activeMissions = [];

        // console.log(`game_state.js/defaultShipProps finished for ship. Ship dockedAtPlanetIdentifier: ${ship.dockedAtPlanetIdentifier}. gameState.docked REMAINS: ${this.docked}`);
    },
};

/* ===== END: hypernova/client/js/game_state.js ===== */


/* ===== START: hypernova/client/js/input_handler.js ===== */
// client/js/input_handler.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js";
import { UIManager } from "./ui_manager.js";
import {
    BASE_THRUST,
    BASE_ROTATION_SPEED,
    DAMPING,
    DOCKING_DISTANCE_SQUARED,
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED,
    HYPERJUMP_DENIED_MESSAGE_DURATION_MS,
} from "./client_config.js";

function wrap(value, max) {
    return ((value % max) + max) % max; // Ensure positive result for negative inputs
}

export function initInputListeners(canvas) {
    window.addEventListener("keydown", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        const keyLower = e.key.toLowerCase();
        const gameSpecificKeys = [
            "arrowup",
            "arrowdown",
            "arrowleft",
            "arrowright",
            " ",
            "d",
            "h",
            "q",
            "e",
            "t",
            "y",
            "o",
            "m",
            "u",
            "b",
            "s",
            "a",
            "escape",
        ];

        if (gameSpecificKeys.includes(keyLower)) {
            e.preventDefault();
        }

        if (gameState.hyperjumpDeniedMessage && keyLower !== "h") {
            // Clear message on most key presses, but allow 'h' to re-attempt
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            return;
        }

        if (!gameState.docked) {
            // Flight controls
            if (e.code === "Space" && !gameState.isChargingHyperjump)
                Network.fireWeapon();
            switch (keyLower) {
                case "arrowup":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.accelerating = true;
                    break;
                case "arrowdown":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.decelerating = true;
                    break;
                case "arrowleft":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.rotatingLeft = true;
                    break;
                case "arrowright":
                    if (!gameState.isChargingHyperjump)
                        gameState.controls.rotatingRight = true;
                    break;
                case "d":
                    if (!gameState.isChargingHyperjump) tryDockAction(canvas);
                    break;
                case "h":
                    // No !isChargingHyperjump check here, hyperJumpAction handles its own state
                    hyperJumpAction(canvas);
                    break;
                case "q":
                    if (!gameState.isChargingHyperjump) cycleWeaponAction(-1);
                    break;
                case "e":
                    if (!gameState.isChargingHyperjump) cycleWeaponAction(1);
                    break;
            }
        } else {
            // Docked menu controls
            handleMenuKeyDown(keyLower);
        }
    });

    window.addEventListener("keyup", (e) => {
        const targetElement = e.target;
        const isInputFocused =
            targetElement &&
            (targetElement.tagName.toUpperCase() === "INPUT" ||
                targetElement.tagName.toUpperCase() === "TEXTAREA" ||
                targetElement.isContentEditable);

        if (isInputFocused) {
            return;
        }

        if (
            !gameState.myShip ||
            gameState.myShip.destroyed ||
            gameState.docked
        ) {
            // No need to check isChargingHyperjump here, as controls are already false if it was true during keydown
            gameState.controls.accelerating = false;
            gameState.controls.decelerating = false;
            gameState.controls.rotatingLeft = false;
            gameState.controls.rotatingRight = false;
            return;
        }
        const keyLower = e.key.toLowerCase();
        switch (keyLower) {
            case "arrowup":
                gameState.controls.accelerating = false;
                break;
            case "arrowdown":
                gameState.controls.decelerating = false;
                break;
            case "arrowleft":
                gameState.controls.rotatingLeft = false;
                break;
            case "arrowright":
                gameState.controls.rotatingRight = false;
                break;
        }
    });
}

function tryDockAction(canvas) {
    if (
        !gameState.myShip ||
        !gameState.clientGameData.systems[gameState.myShip.system]
    )
        return;
    const planetsInCurrentSystem =
        gameState.clientGameData.systems[gameState.myShip.system].planets;
    let nearestDistSq = Infinity,
        nearestPlanetIndex = -1;

    planetsInCurrentSystem.forEach((p, index) => {
        const d2 =
            (gameState.myShip.x - p.x) ** 2 + (gameState.myShip.y - p.y) ** 2;
        if (d2 < nearestDistSq) {
            nearestDistSq = d2;
            nearestPlanetIndex = index;
        }
    });

    if (nearestPlanetIndex !== -1 && nearestDistSq < DOCKING_DISTANCE_SQUARED) {
        Network.requestDock(gameState.myShip.system, nearestPlanetIndex);
    }
}

function hyperJumpAction(canvas) {
    if (
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.clientGameData.systems.length === 0 ||
        gameState.docked
    ) {
        return;
    }

    if (gameState.isChargingHyperjump) {
        // Optional: Allow canceling jump. For now, pressing H again does nothing if already charging.
        // If implementing cancel: Network.cancelHyperjump();
        console.log(
            "Hyperjump already charging. Pressing H again does nothing for now.",
        );
        return;
    }

    // Clear any previous denied message if player tries again
    if (gameState.hyperjumpDeniedMessage) {
        clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        gameState.hyperjumpDeniedMessage = null;
        gameState.hyperjumpDeniedMessageTimeoutId = null;
    }

    // Check distance from planets
    const currentSystemData =
        gameState.clientGameData.systems[gameState.myShip.system];
    if (currentSystemData && currentSystemData.planets) {
        for (const planet of currentSystemData.planets) {
            const distSq =
                (gameState.myShip.x - planet.x) ** 2 +
                (gameState.myShip.y - planet.y) ** 2;
            if (distSq < MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED) {
                gameState.hyperjumpDeniedMessage =
                    "Too close to a celestial body to engage hyperdrive.";
                if (gameState.hyperjumpDeniedMessageTimeoutId) {
                    clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
                }
                gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                    gameState.hyperjumpDeniedMessage = null;
                    gameState.hyperjumpDeniedMessageTimeoutId = null;
                }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
                return;
            }
        }
    }

    // If clear, request hyperjump from server
    console.log("Attempting to request hyperjump from server.");
    Network.requestHyperjump();
    // Client does NOT set charging state optimistically anymore. Server will inform via 'hyperjumpChargeStarted'.
}

function cycleWeaponAction(direction) {
    if (
        !gameState.myShip ||
        !gameState.myShip.weapons ||
        gameState.myShip.weapons.length === 0
    )
        return;
    gameState.weaponCycleIdx =
        (gameState.weaponCycleIdx +
            direction +
            gameState.myShip.weapons.length) %
        gameState.myShip.weapons.length;
    const weaponName = gameState.myShip.weapons[gameState.weaponCycleIdx];
    Network.equipWeapon(weaponName);
}

function handleMenuKeyDown(keyLower) {
    // ... (existing menu key down logic, ensure no conflicts if hyperjump state was relevant here, but it's for !docked state)
    if (!gameState.docked || !gameState.myShip) {
        gameState.activeSubMenu = null;
        return;
    }

    if (!gameState.activeSubMenu) {
        // Main dock menu
        switch (keyLower) {
            case "t":
                gameState.activeSubMenu = "trade";
                gameState.selectedTradeIndex = 0;
                UIManager.renderTradeMenu();
                break;
            case "y":
                gameState.activeSubMenu = "shipyard";
                gameState.selectedShipIndex = 0;
                UIManager.renderShipyardMenu();
                break;
            case "o":
                gameState.activeSubMenu = "outfitter";
                const weaponKeysList = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (
                    !gameState.selectedWeaponKey ||
                    !weaponKeysList.includes(gameState.selectedWeaponKey)
                ) {
                    gameState.selectedWeaponKey = weaponKeysList[0] || null;
                }
                UIManager.renderOutfitterMenu();
                break;
            case "m":
                gameState.activeSubMenu = "missions";
                gameState.selectedMissionIndex = 0;
                gameState.availableMissionsForCurrentPlanet = [];
                UIManager.renderMissionsMenu();
                if (gameState.dockedAtDetails) {
                    Network.requestMissions(
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                break;
            case "u":
                Network.undock();
                break;
        }
    } else {
        // In a sub-menu
        if (keyLower === "escape") {
            gameState.activeSubMenu = null;
            UIManager.renderMainMenu();
            return;
        }
        switch (gameState.activeSubMenu) {
            case "trade":
                const numTradeGoods =
                    gameState.clientGameData.tradeGoods.length;
                if (keyLower === "arrowup")
                    gameState.selectedTradeIndex = Math.max(
                        0,
                        gameState.selectedTradeIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedTradeIndex = Math.min(
                        numTradeGoods - 1,
                        gameState.selectedTradeIndex + 1,
                    );
                else if (keyLower === "b" && numTradeGoods > 0)
                    Network.buyGood(gameState.selectedTradeIndex);
                else if (keyLower === "s" && numTradeGoods > 0)
                    Network.sellGood(gameState.selectedTradeIndex);
                UIManager.renderTradeMenu();
                break;
            case "outfitter":
                const weaponKeys = Object.keys(
                    gameState.clientGameData.weapons,
                );
                if (weaponKeys.length > 0) {
                    let currentWKeyIndex = weaponKeys.indexOf(
                        gameState.selectedWeaponKey,
                    );
                    if (currentWKeyIndex === -1 && weaponKeys.length > 0)
                        currentWKeyIndex = 0;

                    if (keyLower === "arrowup")
                        currentWKeyIndex = Math.max(0, currentWKeyIndex - 1);
                    else if (keyLower === "arrowdown")
                        currentWKeyIndex = Math.min(
                            weaponKeys.length - 1,
                            currentWKeyIndex + 1,
                        );
                    gameState.selectedWeaponKey = weaponKeys[currentWKeyIndex];
                }
                if (keyLower === "b" && gameState.selectedWeaponKey)
                    Network.equipWeapon(gameState.selectedWeaponKey);
                UIManager.renderOutfitterMenu();
                break;
            case "shipyard":
                const numShipTypes = gameState.clientGameData.shipTypes.length;
                if (keyLower === "arrowup")
                    gameState.selectedShipIndex = Math.max(
                        0,
                        gameState.selectedShipIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedShipIndex = Math.min(
                        numShipTypes - 1,
                        gameState.selectedShipIndex + 1,
                    );
                else if (keyLower === "b" && numShipTypes > 0)
                    Network.buyShip(gameState.selectedShipIndex);
                UIManager.renderShipyardMenu();
                break;
            case "missions":
                const numMissions =
                    gameState.availableMissionsForCurrentPlanet.length;
                if (keyLower === "arrowup")
                    gameState.selectedMissionIndex = Math.max(
                        0,
                        gameState.selectedMissionIndex - 1,
                    );
                else if (keyLower === "arrowdown")
                    gameState.selectedMissionIndex = Math.min(
                        numMissions - 1,
                        gameState.selectedMissionIndex + 1,
                    );
                else if (
                    keyLower === "a" &&
                    numMissions > 0 &&
                    gameState.availableMissionsForCurrentPlanet[
                        gameState.selectedMissionIndex
                    ]
                ) {
                    const missionToAccept =
                        gameState.availableMissionsForCurrentPlanet[
                            gameState.selectedMissionIndex
                        ];
                    Network.acceptMission(
                        missionToAccept.id,
                        gameState.dockedAtDetails.systemIndex,
                        gameState.dockedAtDetails.planetIndex,
                    );
                }
                UIManager.renderMissionsMenu();
                break;
        }
    }
}

export function processInputs(canvas) {
    if (!gameState.myShip || gameState.myShip.destroyed || gameState.docked) {
        // If ship is just drifting while charging hyperjump, apply damping & update position
        if (
            gameState.myShip &&
            !gameState.myShip.destroyed &&
            gameState.isChargingHyperjump &&
            !gameState.docked
        ) {
            const myShip = gameState.myShip;
            myShip.vx *= DAMPING;
            myShip.vy *= DAMPING;
            myShip.x += myShip.vx;
            myShip.y += myShip.vy;
            myShip.x = wrap(myShip.x, canvas.width);
            myShip.y = wrap(myShip.y, canvas.height);
            Network.sendControls(); // Still send position updates from drift
        }
        // Reset controls if not accelerating/rotating due to being docked or destroyed.
        // If charging hyperjump, keydown handlers already prevent setting controls to true.
        gameState.controls.accelerating = false;
        gameState.controls.decelerating = false;
        gameState.controls.rotatingLeft = false;
        gameState.controls.rotatingRight = false;
        return;
    }

    // If execution reaches here, player is not docked, not destroyed, and not charging hyperjump.
    // So, normal input processing applies.

    const myShip = gameState.myShip;

    if (
        myShip.type === undefined ||
        myShip.type === null ||
        !gameState.clientGameData.shipTypes ||
        myShip.type >= gameState.clientGameData.shipTypes.length ||
        !gameState.clientGameData.shipTypes[myShip.type]
    ) {
        return;
    }
    const shipDef = gameState.clientGameData.shipTypes[myShip.type];

    const thrust = BASE_THRUST * shipDef.speedMult;
    const rotSpd = BASE_ROTATION_SPEED * shipDef.rotMult;
    const revThrust = thrust * shipDef.revMult;

    if (gameState.controls.rotatingLeft) myShip.angle -= rotSpd;
    if (gameState.controls.rotatingRight) myShip.angle += rotSpd;

    if (gameState.controls.accelerating) {
        myShip.vx += thrust * Math.cos(myShip.angle);
        myShip.vy += thrust * Math.sin(myShip.angle);
    }
    if (gameState.controls.decelerating) {
        myShip.vx -= revThrust * Math.cos(myShip.angle);
        myShip.vy -= revThrust * Math.sin(myShip.angle);
    }

    myShip.vx *= DAMPING;
    myShip.vy *= DAMPING;

    myShip.x += myShip.vx;
    myShip.y += myShip.vy;

    myShip.x = wrap(myShip.x, canvas.width);
    myShip.y = wrap(myShip.y, canvas.height);

    Network.sendControls();
}

/* ===== END: hypernova/client/js/input_handler.js ===== */


/* ===== START: hypernova/client/js/main.js ===== */
/* ===== START: hypernova/client/js/main.js ===== */
// hypernova/client/js/main.js

console.log("main.js script started");

import { gameState } from "./game_state.js";
window.gameState = gameState; // For debugging via console

import { initNetwork } from "./network.js";
import { Renderer } from "./renderer.js";
import { initInputListeners, processInputs } from "./input_handler.js";
import { UIManager } from "./ui_manager.js";

// --- DYNAMIC LOGIN BACKGROUND & MUSIC ---
let loginBgCanvas, loginBgCtx;
let stars = [];
let shootingStars = [];
let loginAnimationId = null;

const STAR_COLORS = ["#FFFFFF", "#FFFFE0", "#ADD8E6", "#FFDAB9"]; // White, LightYellow, LightBlue, PeachPuff
const SHOOTING_STAR_COLOR = "rgba(220, 220, 255, 0.8)"; // Bright white/blue for shooting stars

function getRandom(min, max) {
    return Math.random() * (max - min) + min;
}

class Star {
    constructor(x, y, radius, opacity) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.opacity = opacity;
        this.maxOpacity = opacity;
        this.minOpacity = Math.max(0.1, opacity - 0.5);
        this.opacitySpeed =
            getRandom(0.005, 0.015) * (Math.random() > 0.5 ? 1 : -1);
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        ctx.fill();
    }

    update() {
        this.opacity += this.opacitySpeed;
        if (this.opacity > this.maxOpacity || this.opacity < this.minOpacity) {
            this.opacitySpeed *= -1;
            this.opacity = Math.max(
                this.minOpacity,
                Math.min(this.maxOpacity, this.opacity),
            ); // Clamp
        }
    }
}

class ShootingStar {
    constructor() {
        this.reset();
    }

    reset() {
        this.active = true;
        this.x = Math.random() * loginBgCanvas.width;
        this.y = 0; // Start from top or side
        this.length = getRandom(150, 300);
        this.angle = getRandom(Math.PI * 0.35, Math.PI * 0.65); // Angle downwards
        this.speed = getRandom(300, 500); // pixels per second
        this.opacity = 1;
        this.life = 1; // 1 = full life, 0 = dead

        // Randomly start from top, left, or right
        const side = Math.random();
        if (side < 0.4) {
            // Top
            this.x = Math.random() * loginBgCanvas.width;
            this.y = -this.length; // Start just off screen
            this.angle = getRandom(Math.PI * 0.4, Math.PI * 0.6); // More downwards
        } else if (side < 0.7) {
            // Left
            this.x = -this.length;
            this.y = Math.random() * loginBgCanvas.height * 0.7; // Upper 70%
            this.angle = getRandom(Math.PI * 0.15, Math.PI * 0.35); // Towards right-down
        } else {
            // Right
            this.x = loginBgCanvas.width + this.length;
            this.y = Math.random() * loginBgCanvas.height * 0.7;
            this.angle = getRandom(Math.PI * 0.65, Math.PI * 0.85); // Towards left-down
        }

        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
    }

    update(deltaTime) {
        if (!this.active) return;

        this.x += this.vx * deltaTime;
        this.y += this.vy * deltaTime;
        this.life -= 0.5 * deltaTime; // Fades out over 2 seconds approx

        if (this.life <= 0) {
            this.active = false;
        }
    }

    draw(ctx) {
        if (!this.active) return;

        const tailX = this.x - Math.cos(this.angle) * this.length;
        const tailY = this.y - Math.sin(this.angle) * this.length;

        const gradient = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
        gradient.addColorStop(
            0,
            `rgba(220, 220, 255, ${this.opacity * this.life})`,
        ); // Head is brighter
        gradient.addColorStop(
            0.3,
            `rgba(200, 200, 255, ${this.opacity * this.life * 0.5})`,
        );
        gradient.addColorStop(1, `rgba(150, 150, 220, 0)`); // Tail fades out

        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tailX, tailY);
        ctx.strokeStyle = gradient;
        ctx.lineWidth = getRandom(1.5, 3);
        ctx.stroke();
    }
}

function createStars() {
    stars = [];
    const numStars = Math.floor(
        (loginBgCanvas.width * loginBgCanvas.height) / 6000,
    );
    for (let i = 0; i < numStars; i++) {
        const x = Math.random() * loginBgCanvas.width;
        const y = Math.random() * loginBgCanvas.height;
        const radius = getRandom(0.2, 1.2);
        const opacity = getRandom(0.2, 0.8);
        stars.push(new Star(x, y, radius, opacity));
    }
}

function animateLoginBackground() {
    loginAnimationId = requestAnimationFrame(animateLoginBackground);

    loginBgCtx.fillStyle = "#00000A"; // Very dark blue, almost black
    loginBgCtx.fillRect(0, 0, loginBgCanvas.width, loginBgCanvas.height);

    // Update and draw static twinkling stars
    stars.forEach((star) => {
        star.update();
        star.draw(loginBgCtx);
    });

    // Occasionally spawn a new shooting star
    if (Math.random() < 0.015) {
        // Adjust probability for more/less shooting stars
        let newShootingStar = shootingStars.find((s) => !s.active);
        if (newShootingStar) {
            newShootingStar.reset();
        } else if (shootingStars.length < 10) {
            // Max 10 active shooting stars
            shootingStars.push(new ShootingStar());
        }
    }

    // Update and draw shooting stars
    const now = performance.now(); // Or use a fixed deltaTime if vsync is an issue
    const deltaTime = (now - (animateLoginBackground.lastTime || now)) / 1000;
    animateLoginBackground.lastTime = now;

    shootingStars.forEach((ss) => {
        ss.update(deltaTime);
        ss.draw(loginBgCtx);
    });

    // Clean up inactive shooting stars (not strictly necessary if reusing)
    // shootingStars = shootingStars.filter(ss => ss.active);
}

function setupLoginMusic() {
    const music = document.getElementById("login-music");
    if (music) {
        music.volume = 0.3;
        music.play().catch((error) => {
            console.warn(
                "Login music autoplay was prevented by the browser:",
                error.message,
            );
            const playMusicOnClick = () => {
                music
                    .play()
                    .catch((e) =>
                        console.warn(
                            "Still couldn't play music after interaction:",
                            e.message,
                        ),
                    );
                document.body.removeEventListener("click", playMusicOnClick);
                document.body.removeEventListener("keydown", playMusicOnClick);
            };
            document.body.addEventListener("click", playMusicOnClick, {
                once: true,
            });
            document.body.addEventListener("keydown", playMusicOnClick, {
                once: true,
            });
        });
    } else {
        console.warn("Login music audio element not found.");
    }
}

function stopLoginScreenVisualsAndMusic() {
    if (loginAnimationId) {
        cancelAnimationFrame(loginAnimationId);
        loginAnimationId = null;
    }
    const music = document.getElementById("login-music");
    if (music) {
        music.pause();
        music.currentTime = 0;
    }
    window.removeEventListener("resize", handleLoginResize);
}

function handleLoginResize() {
    if (loginBgCanvas) {
        loginBgCanvas.width = window.innerWidth;
        loginBgCanvas.height = window.innerHeight;
        createStars(); // Re-create stars for new dimensions
        // Shooting stars will just continue or spawn according to new dimensions
    }
}

function initLoginScreenVisuals() {
    loginBgCanvas = document.getElementById("login-background-canvas");
    if (!loginBgCanvas) {
        console.error("Login background canvas not found!");
        return;
    }
    loginBgCtx = loginBgCanvas.getContext("2d");

    handleLoginResize(); // Initial setup of canvas size and stars
    animateLoginBackground.lastTime = performance.now(); // Initialize for deltaTime
    animateLoginBackground();

    setupLoginMusic();
    window.addEventListener("resize", handleLoginResize);
}
// --- END DYNAMIC LOGIN BACKGROUND & MUSIC ---

async function loadImages(imagePaths) {
    // ... (rest of loadImages function remains the same)
    console.log("main.js/loadImages function called with paths:", imagePaths);
    const imagePromises = imagePaths.map((path) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const filename = path.substring(path.lastIndexOf("/") + 1);
                gameState.loadedImages[filename] = img;
                resolve(img);
            };
            img.onerror = (err) => {
                console.error(`Failed to load image: ${path}`, err);
                reject(new Error(`Failed to load image: ${path}`));
            };
            img.src = path;
        });
    });

    try {
        await Promise.all(imagePromises);
        console.log(
            "main.js/loadImages: All images to be loaded have been processed.",
        );
    } catch (error) {
        console.error(
            "main.js/loadImages: Error during image loading process:",
            error,
        );
    }
}

async function handleLoginSubmit(username, password) {
    // ... (login submission logic)
    console.log(`main.js/handleLoginSubmit called for user: ${username}`);
    const loginErrorEl = document.getElementById("login-error");
    const loginMessageEl = document.getElementById("login-message");
    loginErrorEl.textContent = "";
    loginMessageEl.textContent = "";

    try {
        const response = await fetch("/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ username, password }),
        });
        const result = await response.json();
        console.log("main.js/handleLoginSubmit: Login API response:", result);

        if (response.ok && result.success) {
            loginMessageEl.textContent = result.message || "Success!";
            gameState.currentUser = { username: result.username };
            console.log(
                "main.js/handleLoginSubmit: Set gameState.currentUser to:",
                JSON.stringify(gameState.currentUser),
            );

            // Stop login music and visuals
            stopLoginScreenVisualsAndMusic();

            document.getElementById("login-screen").classList.add("hidden");
            document
                .getElementById("game-container")
                .classList.remove("hidden");
            console.log(
                "main.js/handleLoginSubmit: Login screen hidden, game container shown. Calling initNetwork.",
            );

            initNetwork(async () => {
                // ... (rest of initNetwork callback)
                console.log(
                    "main.js/onReadyCallback (from initNetwork): START. Current gameState.docked:",
                    gameState.docked,
                    "currentUser:",
                    JSON.stringify(gameState.currentUser),
                    "myId:",
                    gameState.myId,
                );
                if (
                    gameState.imagePathsToLoad &&
                    gameState.imagePathsToLoad.length > 0
                ) {
                    await loadImages(gameState.imagePathsToLoad);
                    console.log(
                        "main.js/onReadyCallback: Image loading process complete.",
                    );
                } else {
                    console.log(
                        "main.js/onReadyCallback: No images to load (or imagePathsToLoad not populated).",
                    );
                }

                console.log(
                    "main.js/onReadyCallback: Calling loadProgress(). Current gameState.docked:",
                    gameState.docked,
                );
                await loadProgress(); // This will now potentially emit "clientLoadedDockedState"
                console.log(
                    "main.js/onReadyCallback: AFTER loadProgress() call. gameState.docked:",
                    gameState.docked,
                    "myShip:",
                    JSON.stringify(gameState.myShip),
                );

                if (gameState.myId && !gameState.myShip) {
                    console.warn(
                        "main.js/onReadyCallback: myId exists but myShip is missing! Creating and applying defaults. gameState.docked:",
                        gameState.docked,
                    );
                    gameState.allShips[gameState.myId] =
                        gameState.allShips[gameState.myId] || {};
                    gameState.defaultShipProps(gameState.myShip);
                    console.log(
                        "main.js/onReadyCallback: Initialized myShip with defaults (was missing). gameState.docked:",
                        gameState.docked,
                        "myShip:",
                        JSON.stringify(gameState.myShip),
                    );
                } else if (
                    gameState.myId &&
                    gameState.myShip &&
                    (gameState.myShip.type === undefined ||
                        gameState.myShip.type === null)
                ) {
                    console.warn(
                        "main.js/onReadyCallback: myShip exists but seems uninitialized (e.g. type missing). Applying default props. gameState.docked:",
                        gameState.docked,
                    );
                    gameState.defaultShipProps(gameState.myShip);
                    console.log(
                        "main.js/onReadyCallback: Applied default props to existing myShip. gameState.docked:",
                        gameState.docked,
                        "myShip:",
                        JSON.stringify(gameState.myShip),
                    );
                }

                console.log(
                    "main.js/onReadyCallback: Starting game loop. Final gameState.docked before loop:",
                    gameState.docked,
                    "currentUser:",
                    !!gameState.currentUser,
                    "myId:",
                    gameState.myId,
                    "myShip:",
                    !!gameState.myShip,
                );
                const canvas = document.getElementById("gameCanvas");
                if (canvas) {
                    canvas.focus();
                    console.log(
                        "main.js/onReadyCallback: Attempted to focus canvas.",
                    );
                }
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            });
        } else {
            loginErrorEl.textContent =
                result.message || "Login/Registration failed.";
            console.warn(
                "main.js/handleLoginSubmit: Login/Registration failed. Server message:",
                result.message,
            );
        }
    } catch (error) {
        console.error(
            "main.js/handleLoginSubmit: Login request fetch failed:",
            error,
        );
        loginErrorEl.textContent = "Login request error. Check console.";
    }
}

async function loadProgress() {
    // ... (loadProgress function remains the same)
    console.log("main.js/loadProgress: Function called.");
    if (!gameState.currentUser || !gameState.currentUser.username) {
        console.log(
            "main.js/loadProgress: No current user or username, returning.",
        );
        return;
    }
    console.log(
        `main.js/loadProgress: Attempting to load progress for ${gameState.currentUser.username}. Current myId: ${gameState.myId}`,
    );
    try {
        const response = await fetch(
            `/load-progress?username=${gameState.currentUser.username}`,
        );
        if (response.ok) {
            const progress = await response.json();
            console.log(
                "main.js/loadProgress: Received progress from server:",
                JSON.stringify(progress),
            );

            if (progress && progress.shipData) {
                console.log(
                    "main.js/loadProgress: Progress and shipData found. Applying... Current myId:",
                    gameState.myId,
                );

                if (gameState.myId) {
                    if (!gameState.allShips[gameState.myId]) {
                        console.log(
                            "main.js/loadProgress: myShip object for myId didn't exist, creating it before applying progress.",
                        );
                        gameState.allShips[gameState.myId] = {};
                    }
                    gameState.updateShipData(gameState.myId, progress.shipData);
                    console.log(
                        "main.js/loadProgress: After updateShipData. myShip:",
                        JSON.stringify(gameState.myShip),
                    );

                    const syncData = {
                        credits: progress.shipData.credits,
                        cargo: progress.shipData.cargo,
                        weapons: progress.shipData.weapons,
                        activeWeapon: progress.shipData.activeWeapon,
                        health: progress.shipData.health,
                        type: progress.shipData.type,
                        activeMissions: progress.shipData.activeMissions || [],
                    };

                    if (progress.dockedAtDetails) {
                        gameState.docked = true;
                        gameState.dockedAtDetails = progress.dockedAtDetails;
                        syncData.dockedAtDetails = gameState.dockedAtDetails;
                        console.log(
                            "main.js/loadProgress: SETTING gameState.docked = true from progress.dockedAtDetails. Details:",
                            JSON.stringify(gameState.dockedAtDetails),
                        );
                    } else {
                        gameState.docked = false;
                        gameState.dockedAtDetails = null;
                        syncData.dockedAtDetails = null;
                        syncData.x = progress.shipData.x;
                        syncData.y = progress.shipData.y;
                        syncData.angle = progress.shipData.angle;
                        syncData.vx = progress.shipData.vx;
                        syncData.vy = progress.shipData.vy;
                        syncData.system = progress.shipData.system;
                        console.log(
                            "main.js/loadProgress: SETTING gameState.docked = false (no dockedAtDetails in loaded progress)",
                        );
                    }

                    if (gameState.socket) {
                        console.log(
                            "main.js/loadProgress: Emitting 'clientLoadedDockedState' to server with syncData:",
                            JSON.stringify(syncData),
                        );
                        gameState.socket.emit(
                            "clientLoadedDockedState",
                            syncData,
                        );
                    }

                    console.log(
                        "main.js/loadProgress: Applied loaded progress and sent sync to server. gameState.docked is now:",
                        gameState.docked,
                        "myShip:",
                        JSON.stringify(gameState.myShip),
                    );
                } else {
                    gameState.pendingProgressToApply = progress;
                    console.warn(
                        "main.js/loadProgress: My ID not set YET. Progress stored in pendingProgressToApply. gameState.docked NOT YET SET from this path.",
                    );
                }
            } else {
                console.log(
                    "main.js/loadProgress: No saved progress found (or progress was null/no shipData). Ensuring gameState.docked is false.",
                );
                if (gameState.myId && gameState.myShip) {
                    console.log(
                        "main.js/loadProgress: (No progress file) myShip exists. Its state after defaults (if any applied elsewhere):",
                        JSON.stringify(gameState.myShip),
                    );
                }
                gameState.docked = false;
                gameState.dockedAtDetails = null;
            }
        } else {
            console.error(
                "main.js/loadProgress: Fetch to /load-progress failed with status:",
                response.statusText,
            );
            gameState.docked = false;
            gameState.dockedAtDetails = null;
        }
    } catch (error) {
        console.error(
            "main.js/loadProgress: Error during fetch/processing in loadProgress:",
            error,
        );
        gameState.docked = false;
        gameState.dockedAtDetails = null;
    }
    console.log(
        "main.js/loadProgress: Function finished. Final gameState.docked:",
        gameState.docked,
    );
}

document.addEventListener("DOMContentLoaded", () => {
    console.log("main.js/DOMContentLoaded event fired");

    // Initialize login screen visuals as soon as DOM is ready
    // Only if login screen is initially visible
    const loginScreenElement = document.getElementById("login-screen");
    if (
        loginScreenElement &&
        !loginScreenElement.classList.contains("hidden")
    ) {
        initLoginScreenVisuals();
    }

    const canvas = document.getElementById("gameCanvas");
    const uiContainer = document.getElementById("ui");
    const gameContainer = document.getElementById("game-container");

    if (!canvas || !uiContainer || !gameContainer) {
        console.error(
            "main.js/DOMContentLoaded: Required HTML elements (canvas, ui, game-container) not found!",
        );
        return;
    }
    if (canvas) {
        if (!canvas.hasAttribute("tabindex")) {
            canvas.setAttribute("tabindex", "0");
            console.log(
                "main.js/DOMContentLoaded: Added tabindex=0 to canvas for focus.",
            );
        }
    }

    Renderer.init(canvas);
    UIManager.init(uiContainer);
    initInputListeners(canvas);

    const loginForm = document.getElementById("login-form");
    if (loginForm) {
        loginForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            console.log("main.js/DOMContentLoaded: Login form submitted.");
            const usernameInput = document.getElementById("username");
            const passwordInput = document.getElementById("password");
            if (usernameInput && passwordInput) {
                const username = usernameInput.value;
                const password = passwordInput.value;
                await handleLoginSubmit(username, password);
            } else {
                console.error(
                    "main.js/DOMContentLoaded: Username or password input field not found in login form.",
                );
            }
        });
    } else {
        console.error(
            "main.js/DOMContentLoaded: Login form #login-form not found!",
        );
    }
});

let gameLoopFrameCount = 0;
let lastTime = 0;

function gameLoop(timestamp) {
    gameLoopFrameCount++;
    // const deltaTime = timestamp - lastTime; // Not used directly in this high-level loop
    lastTime = timestamp;

    const canvas = document.getElementById("gameCanvas");

    if (gameState.currentUser && gameState.myId && gameState.myShip) {
        if (!gameState.docked) {
            processInputs(canvas);
        }
        Renderer.draw();
    } else {
        // Game not ready, or user not logged in.
        // The login screen animation is handled by its own `requestAnimationFrame` loop.
    }
    requestAnimationFrame(gameLoop);
}
/* ===== END: hypernova/client/js/main.js ===== */

/* ===== END: hypernova/client/js/main.js ===== */


/* ===== START: hypernova/client/js/network.js ===== */
// hypernova/client/js/network.js
import { gameState } from "./game_state.js";
import { UIManager } from "./ui_manager.js";
import { HYPERJUMP_DENIED_MESSAGE_DURATION_MS } from "./client_config.js";

// NEW: Function to save progress to the server
export async function saveProgress() {
    // Make it async
    if (!gameState.socket || !gameState.myShip || !gameState.currentUser) {
        console.warn(
            "saveProgress: Cannot save - No socket, ship, or user data.",
        );
        console.warn(
            `saveProgress details: socket: ${!!gameState.socket}, myShip: ${!!gameState.myShip}, currentUser: ${!!gameState.currentUser}`,
        );
        return;
    }

    // Add a specific log here
    console.log(
        `saveProgress: Preparing data. Current gameState.docked: ${gameState.docked}, dockedAtDetails being saved: ${JSON.stringify(gameState.docked ? gameState.dockedAtDetails : null)}`,
    );

    // Prepare the data to be saved
    const progressData = {
        username: gameState.currentUser.username,
        shipData: {
            x: gameState.myShip.x,
            y: gameState.myShip.y,
            angle: gameState.myShip.angle,
            vx: gameState.myShip.vx,
            vy: gameState.myShip.vy,
            type: gameState.myShip.type, // This is likely an index
            credits: gameState.myShip.credits,
            cargo: gameState.myShip.cargo, // Array of numbers
            maxCargo: gameState.myShip.maxCargo,
            health: gameState.myShip.health,
            maxHealth: gameState.myShip.maxHealth,
            weapons: gameState.myShip.weapons, // Array of weapon names/IDs
            activeWeapon: gameState.myShip.activeWeapon, // Name/ID of active weapon
            system: gameState.myShip.system, // Current system index
            activeMissions: gameState.myShip.activeMissions, // Array of mission objects/IDs
            // dockedAtPlanetIdentifier is handled by saving `dockedAtDetails` if docked
        },
        dockedAtDetails: gameState.docked ? gameState.dockedAtDetails : null,
    };

    try {
        const response = await fetch("/save-progress", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(progressData),
        });
        const result = await response.json();
        if (response.ok && result.success) {
            console.log("saveProgress: Progress saved successfully to server.");
        } else {
            console.error(
                "saveProgress: Failed to save progress to server:",
                result.message || "Server error",
            );
        }
    } catch (error) {
        console.error(
            "saveProgress: Error during fetch to save progress:",
            error,
        );
    }
}

export function initNetwork(onReadyCallback) {
    const socket = io();
    gameState.socket = socket;

    socket.on("init", (data) => {
        console.log(
            "network.js/init: Received init data:",
            JSON.stringify(data),
        ); // Log full init data
        if (!data || !data.id || !data.gameData) {
            console.error(
                "network.js/init: Incomplete init data received from server.",
            );
            return;
        }
        gameState.myId = data.id;
        console.log("network.js/init: Set gameState.myId to:", gameState.myId);

        // Populate clientGameData from server (user's existing logic)
        gameState.clientGameData.systems = data.gameData.systems || [];
        gameState.clientGameData.tradeGoods = data.gameData.tradeGoods || [];
        gameState.clientGameData.weapons = data.gameData.weapons || {};
        gameState.clientGameData.shipTypes = data.gameData.shipTypes || [];
        gameState.clientGameData.MISSION_TYPES =
            data.gameData.MISSION_TYPES || {};
        gameState.clientPlanetEconomies = data.gameData.economies || [];

        // Collect image paths to load (user's existing logic)
        const uniqueImageFiles = new Set();
        if (gameState.clientGameData.systems) {
            gameState.clientGameData.systems.forEach((system) => {
                if (system.planets) {
                    system.planets.forEach((planet) => {
                        if (planet.imageFile) {
                            uniqueImageFiles.add(
                                `assets/images/${planet.imageFile}`,
                            );
                        }
                    });
                }
            });
        }
        if (gameState.clientGameData.shipTypes) {
            gameState.clientGameData.shipTypes.forEach((shipType) => {
                if (shipType.imageFile) {
                    uniqueImageFiles.add(`assets/images/${shipType.imageFile}`);
                }
            });
        }
        gameState.imagePathsToLoad = Array.from(uniqueImageFiles);
        // console.log("network.js/init: Image paths to load:", gameState.imagePathsToLoad);

        if (data.ships) {
            for (const shipId in data.ships) {
                console.log(
                    "network.js/init: Processing ship from server init data for shipId:",
                    shipId,
                );
                gameState.updateShipData(shipId, data.ships[shipId]); // updateShipData calls defaultShipProps
            }
        }
        console.log(
            "network.js/init: After processing server ships. Current myShip:",
            JSON.stringify(gameState.myShip),
            "Current gameState.docked:",
            gameState.docked,
        );

        if (gameState.pendingProgressToApply && gameState.myId) {
            console.log(
                "network.js/init: Applying pendingProgressToApply. Current gameState.docked BEFORE apply:",
                gameState.docked,
                "Pending progress:",
                JSON.stringify(gameState.pendingProgressToApply),
            );
            const pendingProgress = gameState.pendingProgressToApply;

            gameState.updateShipData(
                // This will call defaultShipProps
                gameState.myId,
                pendingProgress.shipData,
            );
            console.log(
                "network.js/init (pending): After updateShipData. myShip:",
                JSON.stringify(gameState.myShip),
            );

            if (
                gameState.myShip && // Ensure myShip exists after updateShipData
                pendingProgress.shipData.system !== undefined
            ) {
                gameState.myShip.system = pendingProgress.shipData.system;
                console.log(
                    "network.js/init (pending): Set gameState.myShip.system to",
                    gameState.myShip.system,
                );
            }

            if (pendingProgress.dockedAtDetails) {
                gameState.docked = true;
                gameState.dockedAtDetails = pendingProgress.dockedAtDetails;
                console.log(
                    "network.js/init (pending): SETTING gameState.docked = true, details:",
                    JSON.stringify(gameState.dockedAtDetails),
                );
            } else {
                gameState.docked = false;
                gameState.dockedAtDetails = null;
                console.log(
                    "network.js/init (pending): SETTING gameState.docked = false (no dockedAtDetails in pending progress)",
                );
            }
            console.log(
                "network.js/init: Applied pendingProgressToApply. gameState.docked is now:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
            delete gameState.pendingProgressToApply;
        } else if (gameState.myShip) {
            // This branch means: myId is set, myShip exists (likely from server's data.ships), and there was NO pendingProgressToApply.
            // defaultShipProps would have been called via updateShipData when data.ships was processed.
            console.log(
                "network.js/init: (No pending progress, myShip exists). gameState.docked:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
        } else if (gameState.myId) {
            // This branch means: myId is set, but myShip was NOT in data.ships and NO pendingProgressToApply.
            // This implies a new ship situation or a ship not yet created on the server but client knows its ID.
            console.log(
                "network.js/init: (No pending progress, myShip DID NOT exist). Creating and applying defaults for myId:",
                gameState.myId,
                "Current gameState.docked:",
                gameState.docked,
            );
            gameState.allShips[gameState.myId] = {}; // Create the ship object.
            gameState.defaultShipProps(gameState.myShip); // Apply default properties.
            console.log(
                "network.js/init: (New ship scenario) Created and applied defaults. gameState.docked:",
                gameState.docked,
                "myShip:",
                JSON.stringify(gameState.myShip),
            );
        }

        console.log(
            "network.js/init: Client initialization sequence in 'init' handler complete. Final My ship:",
            JSON.stringify(gameState.myShip),
            "Final gameState.docked:",
            gameState.docked,
        );
        if (onReadyCallback) {
            console.log("network.js/init: Calling onReadyCallback.");
            onReadyCallback();
        }
    });

    socket.on("state", (updatedShipDataMap) => {
        // console.log("network.js/state: Received state update:", updatedShipDataMap);
        for (const id in updatedShipDataMap) {
            const update = updatedShipDataMap[id];
            // If this state update includes hyperjump state changes from server, reflect them
            if (id === gameState.myId) {
                if (
                    update.hyperjumpState === "idle" &&
                    gameState.isChargingHyperjump
                ) {
                    // Server says we are idle, but client thought it was charging (e.g. cancellation)
                    gameState.isChargingHyperjump = false;
                    gameState.hyperjumpChargeStartTime = null;
                }
                // Potentially other hyperjump state fields if server sends them in general state updates
            }
            gameState.updateShipData(id, update);
        }
        if (
            gameState.myShip &&
            gameState.myShip.dockedAtPlanetIdentifier === null &&
            gameState.docked
        ) {
            console.log(
                "network.js/state: Server state indicates ship is not docked, but client gameState.docked was true. Cleaning up UI.",
            );
            UIManager.undockCleanup();
        }
    });

    socket.on("playerJoined", (data) => {
        console.log("network.js/playerJoined:", data.id);
        gameState.updateShipData(data.id, data.ship);
    });

    socket.on("playerLeft", (id) => {
        console.log("network.js/playerLeft:", id);
        delete gameState.allShips[id];
    });

    socket.on("projectile", (data) => {
        data.time = Date.now();
        gameState.projectiles.push(data);
    });

    socket.on("dockConfirmed", (data) => {
        console.log(
            "network.js/dockConfirmed: Received data:",
            JSON.stringify(data),
        );
        gameState.docked = true;
        if (gameState.myShip) {
            gameState.myShip.dockedAtPlanetIdentifier = {
                systemIndex: data.systemIndex,
                planetIndex: data.planetIndex,
            };
            // Server is authoritative for position upon docking
            gameState.myShip.x = data.playerX;
            gameState.myShip.y = data.playerY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
        }
        gameState.dockedAtDetails = { ...data };
        console.log(
            "network.js/dockConfirmed: Set gameState.docked = true. dockedAtDetails:",
            JSON.stringify(gameState.dockedAtDetails),
            "myShip.dockedAtPlanetIdentifier:",
            gameState.myShip
                ? JSON.stringify(gameState.myShip.dockedAtPlanetIdentifier)
                : "N/A",
        );
        UIManager.openDockMenu();
        console.log("network.js/dockConfirmed: Calling saveProgress().");
        saveProgress();
    });

    socket.on("undockConfirmed", () => {
        console.log(
            "network.js/undockConfirmed: Received from server. Current gameState.docked BEFORE UIManager.undockCleanup:",
            gameState.docked,
        );
        UIManager.undockCleanup();
        console.log(
            "network.js/undockConfirmed: AFTER UIManager.undockCleanup. gameState.docked:",
            gameState.docked,
        );
    });

    socket.on("tradeError", ({ message }) => {
        console.error("network.js/tradeError:", message);
        alert(`Trade Error: ${message}`);
    });
    socket.on("actionFailed", ({ message }) => {
        console.warn("network.js/actionFailed:", message);
        alert(`Action Failed: ${message}`);
    });
    socket.on("actionSuccess", ({ message }) => {
        console.log("network.js/actionSuccess:", message);
    });

    socket.on("tradeSuccess", (data) => {
        // ... (existing tradeSuccess logic) ...
    });
    socket.on("updatePlanetEconomies", (updatedSystemsEconomies) => {
        // ... (existing updatePlanetEconomies logic) ...
    });
    socket.on("planetEconomyUpdate", (data) => {
        // ... (existing planetEconomyUpdate logic) ...
    });
    socket.on("availableMissionsList", (data) => {
        // ... (existing availableMissionsList logic) ...
    });
    socket.on("missionAccepted", (data) => {
        // ... (existing missionAccepted logic) ...
    });
    socket.on("missionUpdate", (data) => {
        // ... (existing missionUpdate logic) ...
    });

    // Hyperjump related handlers
    socket.on("hyperjumpChargeStarted", ({ chargeTime }) => {
        console.log("Network: Hyperjump charge started by server.");
        gameState.isChargingHyperjump = true;
        gameState.hyperjumpChargeStartTime = Date.now();
        // Client will use its own HYPERJUMP_CHARGE_TIME_MS for progress bar,
        // but server's chargeTime could be used if they differ.
    });

    socket.on("hyperjumpDenied", ({ message }) => {
        console.warn("Network: Hyperjump denied by server:", message);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        gameState.hyperjumpDeniedMessage = message;
        if (gameState.hyperjumpDeniedMessageTimeoutId) {
            clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
        }
        gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
            gameState.hyperjumpDeniedMessage = null;
            gameState.hyperjumpDeniedMessageTimeoutId = null;
        }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
    });

    socket.on("hyperjumpCancelled", ({ message }) => {
        console.log("Network: Hyperjump cancelled by server:", message);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;
        if (message) {
            gameState.hyperjumpDeniedMessage = message; // Re-use denied message display
            if (gameState.hyperjumpDeniedMessageTimeoutId) {
                clearTimeout(gameState.hyperjumpDeniedMessageTimeoutId);
            }
            gameState.hyperjumpDeniedMessageTimeoutId = setTimeout(() => {
                gameState.hyperjumpDeniedMessage = null;
                gameState.hyperjumpDeniedMessageTimeoutId = null;
            }, HYPERJUMP_DENIED_MESSAGE_DURATION_MS);
        }
    });

    socket.on("hyperjumpComplete", (data) => {
        console.log("Network: Hyperjump complete. New state:", data);
        gameState.isChargingHyperjump = false;
        gameState.hyperjumpChargeStartTime = null;

        if (gameState.myShip) {
            gameState.myShip.system = data.newSystem;
            gameState.myShip.x = data.newX;
            gameState.myShip.y = data.newY;
            gameState.myShip.vx = 0;
            gameState.myShip.vy = 0;
            gameState.myShip.angle =
                data.newAngle !== undefined ? data.newAngle : 0;
            gameState.myShip.dockedAtPlanetIdentifier = null;
        }
        gameState.docked = false;
        UIManager.undockCleanup();
        // Client is now in the new system, position set by server.
        // The regular 'state' update from server will also reflect this for other players.
    });
}

export function sendControls() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        (gameState.myShip && gameState.myShip.destroyed)
    ) {
        return;
    }
    // Data sent in 'control' reflects current client state, including drift during hyperjump charge.
    // Server will decide how to use this data if player is charging.
    gameState.socket.emit("control", {
        x: gameState.myShip.x,
        y: gameState.myShip.y,
        angle: gameState.myShip.angle,
        vx: gameState.myShip.vx,
        vy: gameState.myShip.vy,
        system: gameState.myShip.system, // Keep sending current system; server manages actual jump
    });
}

export function fireWeapon() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        !gameState.myShip.activeWeapon ||
        gameState.docked ||
        gameState.isChargingHyperjump // Prevent firing if charging
    ) {
        console.warn(
            "fireWeapon: Pre-condition failed (e.g., charging hyperjump).",
        );
        return;
    }
    console.log("fireWeapon: Emitting 'fire'.");
    gameState.socket.emit("fire");
}

export function equipWeapon(weaponName) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        // Prevent equipping if charging
        if (gameState.isChargingHyperjump)
            console.warn("equipWeapon: Cannot equip while charging hyperjump.");
        return;
    }
    console.log(`equipWeapon called with: ${weaponName}.`);
    gameState.socket.emit("equipWeapon", { weapon: weaponName });
}

export function requestDock(systemIndex, planetIndex) {
    if (!gameState.socket || gameState.isChargingHyperjump) {
        // Prevent docking if charging
        if (gameState.isChargingHyperjump)
            console.warn("requestDock: Cannot dock while charging hyperjump.");
        return;
    }
    console.log(
        `requestDock called for system ${systemIndex}, planet ${planetIndex}.`,
    );
    gameState.socket.emit("dock", { systemIndex, planetIndex });
}

export function undock() {
    // Undocking while charging hyperjump should not be possible as player should not be docked.
    // If somehow state is inconsistent, this is a regular undock request.
    if (!gameState.socket || !gameState.docked) {
        console.warn(
            `undock: Pre-condition failed. Socket: ${!!gameState.socket}, gameState.docked: ${gameState.docked}.`,
        );
        return;
    }
    console.log("undock: Emitting 'undock' to server.");
    gameState.socket.emit("undock");
    saveProgress();
}

export function buyGood(goodIndex) {
    // ... (existing buyGood, no direct hyperjump interaction needed as it requires docking) ...
}
export function sellGood(goodIndex) {
    // ... (existing sellGood) ...
}
export function buyShip(shipTypeIndex) {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.isChargingHyperjump
    ) {
        // Prevent buying ship if charging
        if (gameState.isChargingHyperjump)
            console.warn("buyShip: Cannot buy ship while charging hyperjump.");
        return;
    }
    // ... rest of buyShip logic ...
}

export function requestMissions(systemIndex, planetIndex) {
    // ... (existing requestMissions) ...
}
export function acceptMission(missionId, systemIndex, planetIndex) {
    // ... (existing acceptMission) ...
}

// New function for hyperjump request
export function requestHyperjump() {
    if (
        !gameState.socket ||
        !gameState.myShip ||
        gameState.myShip.destroyed ||
        gameState.docked ||
        gameState.isChargingHyperjump
    ) {
        let reason = "Pre-condition failed";
        if (gameState.docked) reason = "docked";
        if (gameState.isChargingHyperjump) reason = "already charging";
        if (gameState.myShip?.destroyed) reason = "ship destroyed";
        console.warn(`requestHyperjump: Cannot request. Reason: ${reason}`);
        return;
    }
    console.log("network.js: Emitting 'requestHyperjump'.");
    gameState.socket.emit("requestHyperjump");
}

// Optional: if client-side cancellation is desired
export function cancelHyperjumpRequest() {
    if (!gameState.socket || !gameState.isChargingHyperjump) return;
    console.log("network.js: Emitting 'cancelHyperjump'.");
    gameState.socket.emit("cancelHyperjump");
    // Client optimistically stops visual charging, server confirms actual cancellation.
    // gameState.isChargingHyperjump = false; // Let server message handle this state change fully
    // gameState.hyperjumpChargeStartTime = null;
}

/* ===== END: hypernova/client/js/network.js ===== */


/* ===== START: hypernova/client/js/renderer.js ===== */
// hypernova/client/js/renderer.js
import { gameState } from "./game_state.js";
import {
    PROJECTILE_LIFESPAN_MS,
    DOCKING_DISTANCE_SQUARED,
    HYPERJUMP_CHARGE_TIME_MS,
} from "./client_config.js";

let ctx = null;
let canvas = null;
const DEFAULT_PLANET_RADIUS = 20;
const DEFAULT_PLANET_IMAGE_SIZE = 64;

export const Renderer = {
    init(canvasElement) {
        canvas = canvasElement;
        ctx = canvas.getContext("2d");
        canvas.width = 800;
        canvas.height = 600;
    },

    draw() {
        if (!ctx) {
            // Removed !gameState.myShip from here, HUD handles destroyed state message
            return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "12px monospace";

        // Draw planets, projectiles, ships only if myShip exists and has a system
        if (gameState.myShip && gameState.myShip.system !== undefined) {
            const currentSystemData =
                gameState.clientGameData.systems[gameState.myShip.system];
            if (currentSystemData && currentSystemData.planets) {
                currentSystemData.planets.forEach((p) => this.drawPlanet(p));
            }

            const now = Date.now();
            gameState.projectiles = gameState.projectiles.filter(
                (p) => now - (p.time || 0) < PROJECTILE_LIFESPAN_MS,
            );
            gameState.projectiles.forEach((p) => this.drawProjectile(p));

            for (const id in gameState.allShips) {
                const ship = gameState.allShips[id];
                if (!ship || ship.system !== gameState.myShip.system) continue;
                this.drawShip(ship);

                if (
                    id !== gameState.myId &&
                    !ship.destroyed &&
                    ship.type !== undefined
                ) {
                    ctx.fillStyle = ship.color || "#0f0";
                    const shipDef =
                        gameState.clientGameData.shipTypes[ship.type];
                    const labelOffset =
                        shipDef && shipDef.imgHeight
                            ? shipDef.imgHeight / 2 + 5
                            : 15;
                    ctx.fillText(
                        id.substring(0, 6),
                        ship.x - 10,
                        ship.y - labelOffset,
                    );
                }
            }
        }
        this.drawHUD(); // HUD draws regardless of myShip existence for some messages
    },

    drawPlanet(planet) {
        const img = gameState.loadedImages[planet.imageFile];
        if (img) {
            const w = DEFAULT_PLANET_IMAGE_SIZE;
            const h = DEFAULT_PLANET_IMAGE_SIZE;
            ctx.drawImage(img, planet.x - w / 2, planet.y - h / 2, w, h);
        } else {
            ctx.fillStyle = "#080";
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, DEFAULT_PLANET_RADIUS, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.fillStyle = "#0f0";
        ctx.fillText(
            planet.name,
            planet.x + DEFAULT_PLANET_RADIUS + 5,
            planet.y + 4,
        );
    },

    drawShip(ship) {
        if (ship.destroyed || ship.type === undefined) return;
        const shipTypeDefinition =
            gameState.clientGameData.shipTypes[ship.type];
        if (!shipTypeDefinition) return;

        const img = gameState.loadedImages[shipTypeDefinition.imageFile];
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.rotate(ship.angle);
        if (img) {
            const w = shipTypeDefinition.imgWidth || img.width;
            const h = shipTypeDefinition.imgHeight || img.height;
            ctx.drawImage(img, -w / 2, -h / 2, w, h);
        } else {
            ctx.fillStyle = ship.color || "#0f0";
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, 8);
            ctx.lineTo(-10, -8);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    },

    drawProjectile(p) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(p.range / 4, 0);
        ctx.stroke();
        ctx.restore();
    },

    drawHUD() {
        // Handle hyperjump denied message even if ship is destroyed or doesn't exist yet
        if (
            gameState.hyperjumpDeniedMessage &&
            !gameState.isChargingHyperjump
        ) {
            // Don't show denied if actively charging
            ctx.fillStyle = "red";
            ctx.font = "14px monospace";
            const messageWidth = ctx.measureText(
                gameState.hyperjumpDeniedMessage,
            ).width;
            ctx.fillText(
                gameState.hyperjumpDeniedMessage,
                canvas.width / 2 - messageWidth / 2,
                canvas.height - 50,
            );
        }

        if (!gameState.myShip || gameState.myShip.destroyed) {
            // Potentially a "You are destroyed" message here
            return;
        }

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return;

        let cargoCount =
            myShip.cargo && myShip.cargo.length > 0
                ? myShip.cargo.reduce((sum, val) => sum + val, 0)
                : 0;

        ctx.fillStyle = "#0f0";
        ctx.fillText(`Credits $${myShip.credits}`, 10, 20);
        ctx.fillText(
            `Health ${myShip.health || 0}/${myShip.maxHealth || 0}`,
            10,
            36,
        );
        ctx.fillText(`Cargo ${cargoCount}/${currentShipDef.maxCargo}`, 10, 52);

        const systemName =
            gameState.clientGameData.systems[myShip.system]?.name ||
            "Unknown System";
        ctx.fillText(`System: ${systemName}`, 10, 68);

        if (myShip.activeWeapon) {
            const weaponDisplayName =
                gameState.clientGameData.weapons[myShip.activeWeapon]?.name ||
                myShip.activeWeapon;
            ctx.fillText(`Weapon: ${weaponDisplayName}`, 10, 84);
        }

        let hudNextY = 116; // Adjusted Y for mission text
        if (myShip.activeMissions && myShip.activeMissions.length > 0) {
            ctx.fillText("Active Missions:", 10, hudNextY);
            hudNextY += 16;
            myShip.activeMissions.slice(0, 3).forEach((mission) => {
                let missionText =
                    mission.title.length > 35
                        ? mission.title.substring(0, 32) + "..."
                        : mission.title;
                if (
                    mission.type ===
                    gameState.clientGameData.MISSION_TYPES.BOUNTY
                ) {
                    missionText += ` (${mission.targetsDestroyed || 0}/${mission.targetsRequired})`;
                }
                const timeRemainingMin = Math.max(
                    0,
                    Math.round((mission.timeLimit - Date.now()) / 60000),
                );
                missionText += ` (${timeRemainingMin}m)`;
                ctx.fillText(`- ${missionText}`, 15, hudNextY);
                hudNextY += 16;
            });
        }

        // Hyperjump Charging Status
        if (
            gameState.isChargingHyperjump &&
            gameState.hyperjumpChargeStartTime
        ) {
            const chargeProgress = Math.min(
                1,
                (Date.now() - gameState.hyperjumpChargeStartTime) /
                    HYPERJUMP_CHARGE_TIME_MS,
            );
            ctx.fillStyle = "#0af"; // Light blue for charging
            ctx.font = "16px monospace";
            const chargeText = `Hyperdrive Charging: ${Math.round(chargeProgress * 100)}%`;
            const textWidth = ctx.measureText(chargeText).width;
            ctx.fillText(
                chargeText,
                canvas.width / 2 - textWidth / 2,
                canvas.height - 70,
            );

            const barWidth = 200;
            const barHeight = 10;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = canvas.height - 55; // Adjusted bar Y
            ctx.strokeStyle = "#0af";
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.fillRect(barX, barY, barWidth * chargeProgress, barHeight);
            ctx.fillStyle = "#0f0"; // Reset fillStyle for other HUD elements
        }

        // Docking message (ensure it doesn't overlap with hyperjump messages)
        if (
            !gameState.docked &&
            !gameState.isChargingHyperjump &&
            !gameState.hyperjumpDeniedMessage
        ) {
            const planets =
                gameState.clientGameData.systems[myShip.system]?.planets;
            let canDock = false,
                dockPlanetName = "";
            if (planets) {
                planets.forEach((p) => {
                    if (
                        (myShip.x - p.x) ** 2 + (myShip.y - p.y) ** 2 <
                        DOCKING_DISTANCE_SQUARED
                    ) {
                        canDock = true;
                        dockPlanetName = p.name;
                    }
                });
            }
            if (canDock) {
                ctx.fillStyle = "#0f0";
                ctx.font = "12px monospace";
                ctx.fillText(
                    `Press 'D' to dock at ${dockPlanetName}`,
                    canvas.width / 2 - 100,
                    canvas.height - 20,
                );
            }
        }
    },
};

/* ===== END: hypernova/client/js/renderer.js ===== */


/* ===== START: hypernova/client/js/ui_manager.js ===== */
// client/js/ui_manager.js
import { gameState } from "./game_state.js";
import * as Network from "./network.js"; // To send actions like buy/sell/undock

let uiContainer = null;
let dockMenuElement = null;

export const UIManager = {
    init(containerElement) {
        uiContainer = containerElement;
    },

    isMenuOpen() {
        return gameState.isMenuOpen;
    },

    openDockMenu() {
        if (dockMenuElement) this.closeDockMenu(); // Should not happen, but safeguard

        gameState.isMenuOpen = true;
        gameState.activeSubMenu = null; // Start at main dock menu
        document.body.classList.add("no-scroll");

        dockMenuElement = document.createElement("div");
        dockMenuElement.className = "panel";
        dockMenuElement.style.top = "50%";
        dockMenuElement.style.left = "50%";
        dockMenuElement.style.transform = "translate(-50%,-50%)";

        this.renderMainMenu();
        uiContainer.appendChild(dockMenuElement);
    },

    closeDockMenu() {
        if (dockMenuElement && dockMenuElement.parentNode === uiContainer) {
            uiContainer.removeChild(dockMenuElement);
        }
        dockMenuElement = null;
        gameState.isMenuOpen = false;
        gameState.activeSubMenu = null;
        gameState.selectedTradeIndex = 0;
        gameState.selectedWeaponKey = null;
        gameState.selectedShipIndex = 0;
        gameState.selectedMissionIndex = 0;
        document.body.classList.remove("no-scroll");
    },

    // Called by network.js when server confirms undock or player jumps
    undockCleanup() {
        gameState.docked = false;
        gameState.dockedAtDetails = null;
        this.closeDockMenu();
        // myShip.dockedAtPlanetIdentifier is set by server state update
    },

    renderMainMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;

        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return; // Ship def not loaded

        const cargoCount = myShip.cargo.reduce((s, v) => s + v, 0);

        dockMenuElement.innerHTML = `
          <div class="menu-item"><b>Docked at ${gameState.dockedAtDetails.planetName} (${gameState.dockedAtDetails.systemName})</b></div>
          <div class="menu-item">Credits: $${myShip.credits}</div>
          <div class="menu-item">Cargo: ${cargoCount}/${currentShipDef.maxCargo}</div>
          <div class="menu-item">---</div>
          <div class="menu-item">T - Trade</div>
          <div class="menu-item">Y - Shipyard</div>
          <div class="menu-item">O - Outfitter</div>
          <div class="menu-item">M - Missions</div>
          <div class="menu-item">U - Undock</div>
          <div class="menu-item" style="margin-top: 10px; font-size: 0.9em;">(Use Arrow Keys, Enter/Specific Keys, Esc)</div>
        `;
    },

    renderTradeMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;
        const myShip = gameState.myShip;
        const currentShipDef =
            gameState.clientGameData.shipTypes[myShip.type || 0];
        if (!currentShipDef) return;

        const cargoCount = myShip.cargo.reduce((s, v) => s + v, 0);
        let html = `<div class="menu-item"><b>Trade at ${gameState.dockedAtDetails.planetName}</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits} Cargo: ${cargoCount}/${currentShipDef.maxCargo}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Good&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Qty&nbsp;&nbsp;&nbsp;Buy&nbsp;&nbsp;&nbsp;&nbsp;Sell&nbsp;&nbsp;&nbsp;Stock</u></div>`;

        // Use dockedAtDetails for prices/stock, as it's updated on tradeSuccess directly
        const planetEco = gameState.dockedAtDetails;

        if (
            !planetEco ||
            !planetEco.buyPrices ||
            !planetEco.sellPrices ||
            !planetEco.stock
        ) {
            html += "<div>Loading prices...</div>";
        } else {
            gameState.clientGameData.tradeGoods.forEach((g, i) => {
                const buyP =
                    planetEco.buyPrices[g.name] !== undefined
                        ? planetEco.buyPrices[g.name]
                        : "N/A";
                const sellP =
                    planetEco.sellPrices[g.name] !== undefined
                        ? planetEco.sellPrices[g.name]
                        : "N/A";
                const stockVal =
                    planetEco.stock[g.name] !== undefined
                        ? planetEco.stock[g.name]
                        : 0;
                const selectedClass =
                    i === gameState.selectedTradeIndex
                        ? "trade-item-selected"
                        : "";

                html +=
                    `<div class="menu-item ${selectedClass}">${g.name.padEnd(12, " ")} ${myShip.cargo[i].toString().padStart(3, " ")} ` +
                    `$${buyP.toString().padStart(4, " ")} $${sellP.toString().padStart(4, " ")} ${stockVal.toString().padStart(5, " ")}</div>`;
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy. S: Sell. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderOutfitterMenu() {
        if (
            !dockMenuElement ||
            !gameState.myShip ||
            !gameState.clientGameData.weapons
        )
            return;
        const myShip = gameState.myShip;
        let html = `<div class="menu-item"><b>Outfitter</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Weapon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price&nbsp;&nbsp;&nbsp;Dmg&nbsp;&nbsp;Owned</u></div>`;

        if (Object.keys(gameState.clientGameData.weapons).length === 0) {
            html +=
                "<div class='menu-item'>(No weapons available for purchase)</div>";
        } else {
            // Ensure selectedWeaponKey is valid
            const weaponKeys = Object.keys(gameState.clientGameData.weapons);
            if (
                !gameState.selectedWeaponKey ||
                !weaponKeys.includes(gameState.selectedWeaponKey)
            ) {
                gameState.selectedWeaponKey = weaponKeys[0] || null;
            }

            Object.entries(gameState.clientGameData.weapons).forEach(
                ([wKey, wDef]) => {
                    const owned =
                        myShip.weapons && myShip.weapons.includes(wKey)
                            ? "*"
                            : " ";
                    const selectedClass =
                        wKey === gameState.selectedWeaponKey
                            ? "trade-item-selected"
                            : "";
                    html += `<div class="menu-item ${selectedClass}">${wKey.padEnd(12, " ")} $${wDef.price.toString().padEnd(5, " ")} ${wDef.damage.toString().padEnd(3, " ")} ${owned}</div>`;
                },
            );
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy/Equip. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderShipyardMenu() {
        if (!dockMenuElement || !gameState.myShip) return;
        const myShip = gameState.myShip;
        let html = `<div class="menu-item"><b>Shipyard</b></div>`;
        html += `<div class="menu-item">Credits: $${myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Ship&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Price&nbsp;&nbsp;&nbsp;Cargo&nbsp;&nbsp;Current</u></div>`;

        if (gameState.clientGameData.shipTypes.length === 0) {
            html += "<div class='menu-item'>(No ships available)</div>";
        } else {
            gameState.clientGameData.shipTypes.forEach((s, i) => {
                const cur = myShip.type === i ? "*" : " ";
                const selectedClass =
                    i === gameState.selectedShipIndex
                        ? "trade-item-selected"
                        : "";
                html +=
                    `<div class="menu-item ${selectedClass}">${s.name.padEnd(12, " ")} $${s.price.toString().padEnd(5, " ")} ` +
                    `${s.maxCargo.toString().padEnd(3, " ")} ${cur}</div>`;
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. B: Buy. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },

    renderMissionsMenu() {
        if (!dockMenuElement || !gameState.dockedAtDetails || !gameState.myShip)
            return;
        let html = `<div class="menu-item"><b>Missions at ${gameState.dockedAtDetails.planetName}</b></div>`;
        html += `<div class="menu-item">Credits: $${gameState.myShip.credits}</div>`;
        html += `<div class="menu-item" style="border-bottom:1px solid #0f0;"><u>Title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reward</u></div>`;

        if (gameState.availableMissionsForCurrentPlanet.length === 0) {
            html +=
                "<div class='menu-item'>(No missions currently available)</div>";
        } else {
            // Ensure selectedMissionIndex is valid
            if (
                gameState.selectedMissionIndex >=
                gameState.availableMissionsForCurrentPlanet.length
            ) {
                gameState.selectedMissionIndex = Math.max(
                    0,
                    gameState.availableMissionsForCurrentPlanet.length - 1,
                );
            }

            gameState.availableMissionsForCurrentPlanet.forEach((m, i) => {
                const selectedClass =
                    i === gameState.selectedMissionIndex
                        ? "trade-item-selected"
                        : "";
                let titleDisplay =
                    m.title.length > 45
                        ? m.title.substring(0, 42) + "..."
                        : m.title;
                html += `<div class="menu-item ${selectedClass}">${titleDisplay.padEnd(45, " ")} $${m.rewardCredits.toString().padStart(6, " ")}</div>`;

                if (i === gameState.selectedMissionIndex) {
                    // Display details for selected mission
                    html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; ${m.description}</div>`;
                    const timeLeftMs = m.timeLimit - Date.now();
                    const timeLeftMin = Math.max(
                        0,
                        Math.round(timeLeftMs / 60000),
                    );
                    html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Time Limit: ${timeLeftMin} min. Penalty: $${m.penaltyCredits}</div>`;
                    if (
                        m.type ===
                        gameState.clientGameData.MISSION_TYPES.CARGO_DELIVERY
                    ) {
                        html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Deliver: ${m.cargoQuantity} ${m.cargoGoodName}</div>`;
                    } else if (
                        m.type === gameState.clientGameData.MISSION_TYPES.BOUNTY
                    ) {
                        const targetSysName =
                            gameState.clientGameData.systems[
                                m.targetSystemIndex
                            ]?.name || "Unknown System";
                        html += `<div class="menu-item" style="font-size:0.9em; color: #0c0; padding-left:10px;">&nbsp;&nbsp;&gt; Target: ${m.targetsRequired} ${m.targetShipName}(s) in ${targetSysName}</div>`;
                    }
                }
            });
        }
        html +=
            "<div class='menu-item' style='border-top:1px solid #0f0; margin-top:5px;'>ArrowUp/Down: Select. A: Accept. Esc: Back</div>";
        dockMenuElement.innerHTML = html;
    },
};

/* ===== END: hypernova/client/js/ui_manager.js ===== */


/* ===== START: hypernova/server/server.js ===== */
// hypernova/server/server.js
const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const path = require("path");
const fs = require("fs").promises; // Use promises for async file operations
const bodyParser = require("body-parser"); // To parse JSON request bodies

const gameConfig = require("./config/game_config");
const DataLoader = require("./utils/data_loader");

const PlayerManager = require("./modules/player_manager");
const WorldManager = require("./modules/world_manager");
const EconomyManager = require("./modules/economy_manager");
const MissionManager = require("./modules/mission_manager");
const CombatManager = require("./modules/combat_manager");

const app = express();
const serverHttp = http.createServer(app);
const io = new Server(serverHttp, {
    cors: {
        origin: "*", // Be more restrictive in production
        methods: ["GET", "POST"],
    },
});

app.use(bodyParser.json()); // Middleware to parse JSON request bodies
app.use(express.static(path.join(__dirname, "../client")));

app.get("/socket.io/socket.io.js", (req, res) => {
    res.sendFile(
        path.join(
            __dirname,
            "../../node_modules/socket.io/client-dist/socket.io.js",
        ),
    );
});

const USERS_DIR = path.join(__dirname, "data/users");

async function ensureUsersDir() {
    try {
        await fs.mkdir(USERS_DIR, { recursive: true });
        console.log("Users directory ensured:", USERS_DIR);
    } catch (error) {
        console.error("Failed to create users directory:", error);
    }
}
ensureUsersDir(); // Call this to ensure directory exists on server startup

// --- Authentication and User Data ---
async function findUser(username) {
    const filePath = path.join(USERS_DIR, `${username}.json`);
    try {
        const data = await fs.readFile(filePath, "utf-8");
        return JSON.parse(data);
    } catch (error) {
        if (error.code === "ENOENT") return null; // User file not found
        console.error(`Error reading user file for ${username}:`, error);
        throw error; // Re-throw other errors
    }
}

async function createUser(username, password) {
    // WARNING: Storing plain text passwords is a major security risk!
    // Use bcrypt.hashSync(password, saltRounds) in a real app.
    const userFilePath = path.join(USERS_DIR, `${username}.json`);
    const userData = {
        username,
        password /* In a real app, store HASHED password */,
    };
    try {
        await fs.writeFile(userFilePath, JSON.stringify(userData, null, 2));
        console.log(`User ${username} created.`);
        return userData;
    } catch (err) {
        console.error(`Error creating user ${username}:`, err);
        return null; // Indicate failure
    }
}

app.post("/login", async (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) {
        return res.status(400).json({
            success: false,
            message: "Username and password are required.",
        });
    }

    try {
        let user = await findUser(username);
        if (!user) {
            // Simplified: Auto-register if user not found
            console.log(`User ${username} not found. Registering...`);
            user = await createUser(username, password);
            if (!user) {
                return res.status(500).json({
                    success: false,
                    message: "Failed to register user.",
                });
            }
            // Security note: Do not send password back, even in registration success
            return res.json({
                success: true,
                username: user.username,
                message: "Registration successful. Logged in.",
            });
        }

        // WARNING: Plain text password comparison. Insecure!
        // In a real app: const match = await bcrypt.compare(password, user.hashedPassword);
        if (user.password !== password) {
            return res
                .status(401)
                .json({ success: false, message: "Invalid password." });
        }
        // Security note: Do not send password back
        res.json({
            success: true,
            username: user.username,
            message: "Login successful",
        });
    } catch (error) {
        console.error("Login error:", error);
        res.status(500).json({
            success: false,
            message: "Server error during login.",
        });
    }
});

// --- Progress Saving and Loading ---
app.post("/save-progress", async (req, res) => {
    // In a real app, authenticate user here (e.g., check session token from request headers)
    const { username, shipData, dockedAtDetails } = req.body;
    if (!username) {
        // This check is more for direct API calls; if called by logged-in client, username should be reliable
        // Or, better, get username from authenticated session/token on server-side
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }
    if (!shipData) {
        // Basic validation
        return res.status(400).json({
            success: false,
            message: "Ship data required for saving progress.",
        });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    const progress = {
        username,
        lastSaved: new Date().toISOString(),
        shipData,
        dockedAtDetails, // Can be null if not docked
    };

    try {
        await fs.writeFile(progressFilePath, JSON.stringify(progress, null, 2));
        res.json({ success: true, message: "Progress saved." });
    } catch (error) {
        console.error(`Error saving progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error saving progress.",
        });
    }
});

app.get("/load-progress", async (req, res) => {
    // In a real app, authenticate user here
    const { username } = req.query;
    if (!username) {
        return res
            .status(400)
            .json({ success: false, message: "Username required." });
    }

    const progressFilePath = path.join(USERS_DIR, `${username}_progress.json`);
    try {
        const data = await fs.readFile(progressFilePath, "utf-8");
        res.json(JSON.parse(data)); // Send the progress data back
    } catch (error) {
        if (error.code === "ENOENT") {
            // It's not an error if a user has no saved progress yet
            return res.status(200).json(null); // Send null or an empty object, client should handle this
        }
        console.error(`Error loading progress for ${username}:`, error);
        res.status(500).json({
            success: false,
            message: "Server error loading progress.",
        });
    }
});

async function startServer() {
    const staticData = await DataLoader.loadAllData();
    gameConfig.staticWeaponsData = staticData.weapons;

    // Instantiate WorldManager first as PlayerManager will need it
    const worldManager = new WorldManager(
        io,
        staticData.systemsBase,
        staticData.tradeGoods,
        gameConfig,
    );

    // Pass the worldManager instance to PlayerManager
    const playerManager = new PlayerManager(
        io,
        staticData.shipTypes,
        staticData.tradeGoods,
        gameConfig,
        worldManager, // <<< MODIFICATION HERE: Pass worldManager instance
    );

    // Other managers can now receive playerManager and worldManager as needed
    const economyManager = new EconomyManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const missionManager = new MissionManager(
        io,
        worldManager,
        playerManager,
        staticData.tradeGoods,
        gameConfig,
    );
    const combatManager = new CombatManager(
        io,
        playerManager,
        missionManager,
        staticData.weapons,
        gameConfig,
    );

    // Initialize worldManager AFTER all managers it might use internally during initialization are created
    // (though in this case, it mainly uses economyManager and missionManager passed to it)
    worldManager.initialize(economyManager, missionManager);

    setInterval(
        () => economyManager.updateAllPlanetEconomies(),
        gameConfig.ECONOMY_UPDATE_INTERVAL_MS,
    );
    setInterval(
        () => missionManager.populateAllPlanetMissions(), // This probably needs this.systems from worldManager
        gameConfig.MISSION_GENERATION_INTERVAL_MS,
    );
    setInterval(
        () => playerManager.checkAllPlayerMissionTimeouts(missionManager),
        gameConfig.PLAYER_MISSION_CHECK_INTERVAL_MS,
    );

    io.on("connection", (socket) => {
        const initialWorldData = {
            systems: worldManager.getSystemsForClient(),
            economies: worldManager.getEconomiesForClient(),
        };
        // PlayerManager's handleConnection now has access to worldManager via `this.worldManager`
        playerManager.handleConnection(socket, initialWorldData);

        economyManager.registerSocketHandlers(socket);
        missionManager.registerSocketHandlers(socket);
        combatManager.registerSocketHandlers(socket);
        // WorldManager registers its own handlers for 'dock' and 'undock' etc.
        worldManager.registerSocketHandlers(socket, playerManager);

        socket.on("disconnect", () => {
            playerManager.handleDisconnect(socket);
        });
    });

    serverHttp.listen(gameConfig.PORT, () =>
        console.log(
            `Server structured and listening on port ${gameConfig.PORT}`,
        ),
    );
}

startServer().catch((error) => {
    console.error("Failed to start server:", error);
    process.exit(1); // Exit if server fails to start
});

/* ===== END: hypernova/server/server.js ===== */


/* ===== START: hypernova/server/config/game_config.js ===== */
module.exports = {
    PORT: 3000,
    MISSION_TYPES: {
        CARGO_DELIVERY: "CARGO_DELIVERY",
        BOUNTY: "BOUNTY",
    },
    MAX_MISSIONS_PER_PLANET: 3,
    MISSION_GENERATION_INTERVAL_MS: 2 * 60 * 1000, // 2 minutes
    MISSION_TIME_LIMIT_BASE_MS: 5 * 60 * 1000, // 5 minutes
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS: 1 * 60 * 1000, // 1 minute

    ECONOMY_UPDATE_INTERVAL_MS: 1 * 60 * 1000, // 1 minute
    PLAYER_MISSION_CHECK_INTERVAL_MS: 30 * 1000, // 30 seconds

    INITIAL_STOCK_BASE: 1000,
    STOCK_PRODUCED_MULTIPLIER: 2.0,
    STOCK_CONSUMED_MULTIPLIER: 0.5,
    PRICE_SUPPLY_FACTOR_LOW: 0.7,
    PRICE_DEMAND_FACTOR_HIGH: 1.4,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER: 0.5,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER: 2.5,
    PLANET_PROFIT_MARGIN: 0.05,

    DEFAULT_PLAYER_CREDITS: 1000,
    DEFAULT_PLAYER_SHIP_TYPE_INDEX: 0, // Scout
    PLAYER_SPAWN_X: 400,
    PLAYER_SPAWN_Y: 300,

    // Hyperjump configuration
    MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED: 22500, // (150px)^2
    HYPERJUMP_CHARGE_TIME_MS: 3000, // 3 seconds
    // MAP_WIDTH: 800, // Example, if needed for arrival points
    // MAP_HEIGHT: 600, // Example
};

/* ===== END: hypernova/server/config/game_config.js ===== */


/* ===== START: hypernova/server/data/ship_types.json ===== */
[
    {
        "name": "Scout",
        "price": 0,
        "speedMult": 1.1,
        "rotMult": 1.5,
        "revMult": 2.5,
        "maxCargo": 10,
        "maxHealth": 100,
        "imageFile": "scout_ship.png",
        "imgWidth": 32,
        "imgHeight": 32
    },
    {
        "name": "Trader",
        "price": 2000,
        "speedMult": 1.0,
        "rotMult": 1.0,
        "revMult": 2.0,
        "maxCargo": 30,
        "maxHealth": 100
    },
    {
        "name": "Freighter",
        "price": 5000,
        "speedMult": 0.7,
        "rotMult": 0.7,
        "revMult": 1.5,
        "maxCargo": 60,
        "maxHealth": 100
    },
    {
        "name": "Interceptor",
        "price": 1500,
        "speedMult": 1.8,
        "rotMult": 1.8,
        "revMult": 2.2,
        "maxCargo": 5,
        "maxHealth": 120
    },
    {
        "name": "Heavy Freighter",
        "price": 10000,
        "speedMult": 0.5,
        "rotMult": 0.5,
        "revMult": 1.0,
        "maxCargo": 100,
        "maxHealth": 150
    }
]

/* ===== END: hypernova/server/data/ship_types.json ===== */


/* ===== START: hypernova/server/data/systems_init.json ===== */
[
    {
        "name": "Greek",
        "planets": [
            {
                "name": "Alpha",
                "x": 200,
                "y": 150,
                "produces": ["Food"],
                "consumes": ["Electronics"]
            },
            {
                "name": "Delta",
                "x": 500,
                "y": 320,
                "produces": ["Ore"],
                "consumes": ["Medicine"]
            }
        ]
    },
    {
        "name": "Roman",
        "planets": [
            {
                "name": "Sol",
                "x": 140,
                "y": 120,
                "produces": ["Medicine", "Electronics"],
                "consumes": ["Food", "Ore"]
            },
            {
                "name": "Mars",
                "x": 620,
                "y": 420,
                "produces": ["Ore"],
                "consumes": ["Food"]
            }
        ]
    },
    {
        "name": "Nordic",
        "planets": [
            {
                "name": "Beta",
                "x": 380,
                "y": 480,
                "produces": ["Food", "Ore"],
                "consumes": ["Electronics", "Medicine"]
            }
        ]
    },
    {
        "name": "Egyptian",
        "planets": [
            {
                "name": "Nile",
                "x": 100,
                "y": 500,
                "produces": ["Food"],
                "consumes": ["Medicine", "Ore"]
            },
            {
                "name": "Giza",
                "x": 400,
                "y": 550,
                "produces": ["Ore"],
                "consumes": ["Electronics", "Food"]
            }
        ]
    },
    {
        "name": "Celtic",
        "planets": [
            {
                "name": "Tara",
                "x": 700,
                "y": 100,
                "produces": ["Medicine", "Food"],
                "consumes": ["Ore"]
            },
            {
                "name": "Avalon",
                "x": 650,
                "y": 300,
                "produces": ["Electronics"],
                "consumes": ["Food", "Medicine"]
            }
        ]
    }
]

/* ===== END: hypernova/server/data/systems_init.json ===== */


/* ===== START: hypernova/server/data/trade_goods.json ===== */
[
    { "name": "Food", "basePrice": 10, "mass": 1 },
    { "name": "Ore", "basePrice": 50, "mass": 1 },
    { "name": "Medicine", "basePrice": 100, "mass": 1 },
    { "name": "Electronics", "basePrice": 200, "mass": 1 }
]

/* ===== END: hypernova/server/data/trade_goods.json ===== */


/* ===== START: hypernova/server/data/weapons.json ===== */
{
    "Laser": {
        "name": "Laser",
        "price": 500,
        "damage": 10,
        "range": 140,
        "rpm": 300,
        "color": "#f00",
        "beam": 0.3
    },
    "Plasma": {
        "name": "Plasma",
        "price": 1500,
        "damage": 25,
        "range": 200,
        "rpm": 180,
        "color": "#0ff",
        "beam": 0.3
    },
    "Railgun": {
        "name": "Railgun",
        "price": 3000,
        "damage": 40,
        "range": 280,
        "rpm": 120,
        "color": "#ff0",
        "beam": 0.2
    },
    "FusionGun": {
        "name": "FusionGun",
        "price": 8000,
        "damage": 70,
        "range": 350,
        "rpm": 60,
        "color": "#f0f",
        "beam": 0.15
    }
}


/* ===== END: hypernova/server/data/weapons.json ===== */


/* ===== START: hypernova/server/modules/combat_manager.js ===== */
// server/modules/combat_manager.js
class CombatManager {
    constructor(io, playerManager, missionManager, weaponsData, gameConfig) {
        this.io = io;
        this.playerManager = playerManager;
        this.missionManager = missionManager;
        this.weaponsData = weaponsData;
        this.gameConfig = gameConfig;
    }

    registerSocketHandlers(socket) {
        socket.on("fire", () => {
            const attacker = this.playerManager.getPlayer(socket.id);
            if (
                !attacker ||
                !attacker.activeWeapon ||
                attacker.destroyed ||
                attacker.dockedAtPlanetIdentifier ||
                attacker.hyperjumpState === "charging"
            ) {
                if (attacker && attacker.hyperjumpState === "charging") {
                    socket.emit("actionFailed", {
                        message:
                            "Cannot fire weapons while hyperdrive is charging.",
                    });
                }
                return;
            }

            const weaponStats = this.weaponsData[attacker.activeWeapon];
            if (!weaponStats) return;

            const fwdX = Math.cos(attacker.angle);
            const fwdY = Math.sin(attacker.angle);
            const cosHalfBeam = Math.cos(weaponStats.beam * 0.5);

            const allPlayers = this.playerManager.getAllPlayers();

            for (const targetId in allPlayers) {
                if (targetId === socket.id) continue;

                const target = allPlayers[targetId];
                if (
                    !target ||
                    target.system !== attacker.system ||
                    target.destroyed ||
                    target.dockedAtPlanetIdentifier
                )
                    continue;

                const dx = target.x - attacker.x;
                const dy = target.y - attacker.y;
                const dist = Math.hypot(dx, dy);

                if (dist === 0 || dist > weaponStats.range) continue;

                const dirToTargetX = dx / dist;
                const dirToTargetY = dy / dist;
                const dotProduct = fwdX * dirToTargetX + fwdY * dirToTargetY;

                if (dotProduct < cosHalfBeam) continue;

                target.health -= weaponStats.damage;
                let targetDestroyedThisShot = false;

                if (target.health > 0 && target.hyperjumpState === "charging") {
                    this.playerManager.handlePlayerHitDuringHyperjumpCharge(
                        target.id,
                    );
                }

                if (target.health <= 0) {
                    target.health = 0;
                    target.destroyed = true;
                    targetDestroyedThisShot = true;

                    if (
                        target.hyperjumpState === "charging" &&
                        target.hyperjumpChargeTimeoutId
                    ) {
                        clearTimeout(target.hyperjumpChargeTimeoutId);
                        target.hyperjumpChargeTimeoutId = null;
                        target.hyperjumpState = "idle";
                        console.log(
                            `Hyperjump charge for destroyed player ${target.id} cleared.`,
                        );
                    }
                    console.log(
                        `Player ${target.id} destroyed by ${attacker.id}`,
                    );
                }

                this.playerManager.updatePlayerState(target.id, {
                    // Changed to updatePlayerState for broader sync
                    health: target.health,
                    destroyed: target.destroyed,
                    hyperjumpState: target.hyperjumpState, // ensure hyperjump state is also synced if changed
                });

                if (targetDestroyedThisShot) {
                    this.missionManager.handleTargetDestroyed(attacker, target);
                }
                break;
            }

            // Emit projectile to all players in the attacker's system
            const systemPlayers = Object.values(allPlayers).filter(
                (p) => p.system === attacker.system,
            );
            systemPlayers.forEach((p) => {
                this.io.to(p.id).emit("projectile", {
                    x: attacker.x,
                    y: attacker.y,
                    angle: attacker.angle,
                    color: weaponStats.color,
                    range: weaponStats.range,
                    shooterId: attacker.id,
                });
            });
        });
    }
}

module.exports = CombatManager;

/* ===== END: hypernova/server/modules/combat_manager.js ===== */


/* ===== START: hypernova/server/modules/economy_manager.js ===== */
// server/modules/economy_manager.js
const {
    INITIAL_STOCK_BASE,
    STOCK_PRODUCED_MULTIPLIER,
    STOCK_CONSUMED_MULTIPLIER,
    PRICE_SUPPLY_FACTOR_LOW,
    PRICE_DEMAND_FACTOR_HIGH,
    PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
    PRICE_STOCK_MAX_EFFECT_MULTIPLIER,
    PLANET_PROFIT_MARGIN,
} = require("../config/game_config");

class EconomyManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager; // To get/update planet data
        this.playerManager = playerManager; // To update player credits/cargo
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
    }

    getTradeGoodByName(goodName) {
        return this.tradeGoods.find((g) => g.name === goodName);
    }

    calculatePricesForGoodOnPlanet(planet, goodName) {
        const good = this.getTradeGoodByName(goodName);
        if (!good) return;

        let baseValuation = good.basePrice;
        if (planet.produces.includes(goodName))
            baseValuation *= PRICE_SUPPLY_FACTOR_LOW;
        else if (planet.consumes.includes(goodName))
            baseValuation *= PRICE_DEMAND_FACTOR_HIGH;

        let targetStock = INITIAL_STOCK_BASE;
        if (planet.produces.includes(goodName))
            targetStock *= STOCK_PRODUCED_MULTIPLIER;
        if (planet.consumes.includes(goodName))
            targetStock *= STOCK_CONSUMED_MULTIPLIER;
        targetStock = Math.max(1, targetStock);

        let stockEffectMultiplier = 1.0;
        if (planet.stock[goodName] > 0) {
            stockEffectMultiplier = targetStock / planet.stock[goodName];
        } else {
            stockEffectMultiplier = PRICE_STOCK_MAX_EFFECT_MULTIPLIER * 2; // High price if no stock
        }
        stockEffectMultiplier = Math.max(
            PRICE_STOCK_MIN_EFFECT_MULTIPLIER,
            Math.min(PRICE_STOCK_MAX_EFFECT_MULTIPLIER, stockEffectMultiplier),
        );

        const planetInternalValue = Math.round(
            baseValuation * stockEffectMultiplier,
        );
        planet.buyPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 + PLANET_PROFIT_MARGIN)),
        );
        planet.sellPrices[goodName] = Math.max(
            1,
            Math.round(planetInternalValue * (1 - PLANET_PROFIT_MARGIN)),
        );

        if (planet.buyPrices[goodName] <= planet.sellPrices[goodName]) {
            planet.buyPrices[goodName] = planet.sellPrices[goodName] + 1;
        }
        if (planet.sellPrices[goodName] <= 0) planet.sellPrices[goodName] = 1;
    }

    initializeAllPlanetEconomies(systems) {
        // `systems` is the live array from WorldManager
        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let initialStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        initialStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        initialStock *= STOCK_CONSUMED_MULTIPLIER;
                    planet.stock[good.name] = Math.floor(
                        Math.max(10, initialStock),
                    );
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });
        console.log("Planet economies initialized by EconomyManager.");
    }

    updateAllPlanetEconomies() {
        // Called by interval in server.js
        const systems = this.worldManager.systems; // Get live systems data
        if (!systems || systems.length === 0) return;

        systems.forEach((system) => {
            system.planets.forEach((planet) => {
                this.tradeGoods.forEach((good) => {
                    let targetStock = INITIAL_STOCK_BASE;
                    if (planet.produces.includes(good.name))
                        targetStock *= STOCK_PRODUCED_MULTIPLIER;
                    if (planet.consumes.includes(good.name))
                        targetStock *= STOCK_CONSUMED_MULTIPLIER;
                    targetStock = Math.max(1, targetStock);

                    const currentStock = planet.stock[good.name] || 0;
                    const diff = targetStock - currentStock;
                    let change = Math.round(diff * 0.02); // Slow adjustment
                    if (change === 0 && diff !== 0) change = diff > 0 ? 1 : -1;

                    planet.stock[good.name] = currentStock + change;
                    planet.stock[good.name] = Math.max(
                        0,
                        Math.min(planet.stock[good.name], targetStock * 5),
                    ); // Cap stock
                    this.calculatePricesForGoodOnPlanet(planet, good.name);
                });
            });
        });

        this.io.emit(
            "updatePlanetEconomies",
            this.worldManager.getEconomiesForClient(),
        );
        // console.log("Planet economies updated and broadcasted.");
    }

    notifyPlanetEconomyUpdate(systemIndex, planetIndex) {
        const planet = this.worldManager.getPlanet(systemIndex, planetIndex);
        if (planet) {
            this.io.emit("planetEconomyUpdate", {
                systemIndex,
                planetIndex,
                name: planet.name, // Though client might not use name here
                buyPrices: planet.buyPrices,
                sellPrices: planet.sellPrices,
                stock: planet.stock,
            });
        }
    }

    registerSocketHandlers(socket) {
        socket.on(
            "buyGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.buyPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not sold here.",
                    });
                const totalCost = pricePerUnit * quantity;

                const currentCargoMass = player.cargo.reduce(
                    (sum, val, idx) => sum + this.tradeGoods[idx].mass * val,
                    0,
                );
                const newGoodMass = goodInfo.mass * quantity;

                if (player.credits < totalCost)
                    return socket.emit("tradeError", {
                        message: "Not enough credits.",
                    });
                if (currentCargoMass + newGoodMass > player.maxCargo)
                    return socket.emit("tradeError", {
                        message: "Not enough cargo space.",
                    });
                if (
                    !planet.stock[goodName] ||
                    planet.stock[goodName] < quantity
                )
                    return socket.emit("tradeError", {
                        message: "Planet out of stock.",
                    });

                player.credits -= totalCost;
                player.cargo[goodIdx] += quantity;
                planet.stock[goodName] -= quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        // For immediate UI update on client
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );

        socket.on(
            "sellGood",
            ({ goodName, quantity, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const goodInfo = this.getTradeGoodByName(goodName);
                const goodIdx = this.tradeGoods.findIndex(
                    (g) => g.name === goodName,
                );

                if (
                    !player ||
                    !goodInfo ||
                    goodIdx === -1 ||
                    !player.dockedAtPlanetIdentifier ||
                    player.dockedAtPlanetIdentifier.systemIndex !==
                        systemIndex ||
                    player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
                ) {
                    return socket.emit("tradeError", {
                        message: "Invalid trade conditions.",
                    });
                }
                if (player.cargo[goodIdx] < quantity)
                    return socket.emit("tradeError", {
                        message: "Not enough goods to sell.",
                    });

                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );
                if (!planet)
                    return socket.emit("tradeError", {
                        message: "Planet not found.",
                    });

                const pricePerUnit = planet.sellPrices[goodName];
                if (pricePerUnit === undefined)
                    return socket.emit("tradeError", {
                        message: "Good not bought here.",
                    });

                const totalGain = pricePerUnit * quantity;

                player.credits += totalGain;
                player.cargo[goodIdx] -= quantity;
                planet.stock[goodName] += quantity;
                this.calculatePricesForGoodOnPlanet(planet, goodName);

                socket.emit("tradeSuccess", {
                    credits: player.credits,
                    cargo: player.cargo,
                    updatedPlanetData: {
                        systemIndex,
                        planetIndex,
                        buyPrices: planet.buyPrices,
                        sellPrices: planet.sellPrices,
                        stock: planet.stock,
                    },
                });
                this.playerManager.updatePlayerState(socket.id, {
                    credits: player.credits,
                    cargo: player.cargo,
                });
                this.notifyPlanetEconomyUpdate(systemIndex, planetIndex);
            },
        );
    }
}

module.exports = EconomyManager;

/* ===== END: hypernova/server/modules/economy_manager.js ===== */


/* ===== START: hypernova/server/modules/mission_manager.js ===== */
// server/modules/mission_manager.js
const { generateMissionId, getSystemDistance } = require("../utils/helpers");
const {
    MISSION_TYPES,
    MAX_MISSIONS_PER_PLANET,
    MISSION_TIME_LIMIT_BASE_MS,
    MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS,
} = require("../config/game_config");

class MissionManager {
    constructor(io, worldManager, playerManager, tradeGoods, gameConfig) {
        this.io = io;
        this.worldManager = worldManager;
        this.playerManager = playerManager;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig; // For other mission params if any
    }

    generateCargoDeliveryMission(
        originSystemIndex,
        originPlanetIndex,
        systems,
    ) {
        const numSystems = systems.length;
        if (
            numSystems === 0 ||
            (numSystems === 1 && systems[0].planets.length < 2)
        )
            return null;

        let destSystemIndex, destPlanetIndex;
        let attempts = 0;
        const originSystem = systems[originSystemIndex];
        const originPlanet = originSystem.planets[originPlanetIndex];

        do {
            destSystemIndex = Math.floor(Math.random() * numSystems);
            const destSystem = systems[destSystemIndex];
            if (!destSystem || destSystem.planets.length === 0) {
                attempts++;
                continue;
            }
            destPlanetIndex = Math.floor(
                Math.random() * destSystem.planets.length,
            );
            attempts++;
        } while (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex &&
            numSystems > 1 &&
            systems[destSystemIndex].planets.length > 1 && // only try again if there are other options
            attempts < 20
        );

        // If still same after attempts (e.g. only one planet in one system, or two planets total)
        if (
            destSystemIndex === originSystemIndex &&
            destPlanetIndex === originPlanetIndex
        )
            return null;

        const goodIndex = Math.floor(Math.random() * this.tradeGoods.length);
        const goodToDeliver = this.tradeGoods[goodIndex];
        const quantity = Math.floor(Math.random() * 5) + 2; // 2 to 6 units

        const distance = getSystemDistance(
            originSystemIndex,
            destSystemIndex,
            numSystems,
        );
        const rewardCredits =
            goodToDeliver.basePrice * quantity * 1.5 + distance * 150 + 100;
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const destPlanet = systems[destSystemIndex].planets[destPlanetIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.CARGO_DELIVERY,
            title: `Deliver ${quantity} ${goodToDeliver.name} to ${destPlanet.name} (${systems[destSystemIndex].name})`,
            description: `Transport ${quantity} units of ${goodToDeliver.name} from ${originPlanet.name} (${originSystem.name}) to ${destPlanet.name} (${systems[destSystemIndex].name}).`,
            originSystemIndex,
            originPlanetIndex,
            destinationSystemIndex: destSystemIndex,
            destinationPlanetIndex: destPlanetIndex,
            cargoGoodName: goodToDeliver.name,
            cargoQuantity: quantity,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.3),
            timeLimit: timeLimit,
            status: "AVAILABLE", // Initial status
        };
    }

    generateBountyMission(originSystemIndex, originPlanetIndex, systems) {
        const numSystems = systems.length;
        if (numSystems === 0) return null;
        let targetSystemIndex;

        if (numSystems > 1) {
            do {
                targetSystemIndex = Math.floor(Math.random() * numSystems);
            } while (targetSystemIndex === originSystemIndex && numSystems > 1); // Ensure different system if possible
        } else {
            targetSystemIndex = originSystemIndex;
        }

        const numTargets = Math.floor(Math.random() * 2) + 1; // 1 to 2 pirates
        const distance = getSystemDistance(
            originSystemIndex,
            targetSystemIndex,
            numSystems,
        );
        const rewardCredits = numTargets * 500 + distance * 100; // Base reward + distance bonus
        const timeLimit =
            Date.now() +
            MISSION_TIME_LIMIT_BASE_MS +
            distance * MISSION_TIME_LIMIT_PER_SYSTEM_JUMP_MS;
        const originPlanet =
            systems[originSystemIndex].planets[originPlanetIndex];
        const originSystem = systems[originSystemIndex];

        return {
            id: generateMissionId(),
            type: MISSION_TYPES.BOUNTY,
            title: `Bounty: ${numTargets} Pirate${numTargets > 1 ? "s" : ""} in ${systems[targetSystemIndex].name}`,
            description: `Hostile elements reported in ${systems[targetSystemIndex].name} system. Originated near ${originPlanet.name} (${originSystem.name}). Eliminate ${numTargets} of them.`,
            originSystemIndex,
            originPlanetIndex,
            targetSystemIndex: targetSystemIndex,
            targetShipName: "Pirate", // Generic for now
            targetsRequired: numTargets,
            targetsDestroyed: 0,
            rewardCredits: Math.round(rewardCredits),
            penaltyCredits: Math.round(rewardCredits * 0.2),
            timeLimit: timeLimit,
            status: "AVAILABLE",
        };
    }

    populateAllPlanetMissions() {
        // Called by interval
        const systems = this.worldManager.systems;
        if (!systems) return;

        systems.forEach((system, sysIdx) => {
            system.planets.forEach((planet, pIdx) => {
                // Filter out expired or already taken missions (though 'taken' is handled on accept)
                planet.availableMissions = planet.availableMissions.filter(
                    (m) => m.status === "AVAILABLE" && m.timeLimit > Date.now(),
                );

                while (
                    planet.availableMissions.length < MAX_MISSIONS_PER_PLANET
                ) {
                    let newMission = null;
                    const missionTypeRoll = Math.random();
                    if (missionTypeRoll < 0.7) {
                        // 70% chance for cargo
                        newMission = this.generateCargoDeliveryMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    } else {
                        newMission = this.generateBountyMission(
                            sysIdx,
                            pIdx,
                            systems,
                        );
                    }
                    if (newMission) {
                        planet.availableMissions.push(newMission);
                    } else {
                        break; // Stop if no mission could be generated (e.g., single planet system for cargo)
                    }
                }
            });
        });
        // console.log("Planet missions populated.");
    }

    checkPlayerMissionTimeouts(player) {
        // player object directly modified
        let missionsChanged = false;
        const completedOrFailed = [];

        player.activeMissions.forEach((mission) => {
            if (
                mission.status === "ACCEPTED" &&
                Date.now() > mission.timeLimit
            ) {
                mission.status = "FAILED_TIME";
                player.credits -= mission.penaltyCredits;
                player.credits = Math.max(0, player.credits);
                missionsChanged = true;
                completedOrFailed.push({
                    missionId: mission.id,
                    status: mission.status,
                    reason: "Time expired.",
                    penalty: mission.penaltyCredits,
                });
            }
        });

        if (missionsChanged) {
            player.activeMissions = player.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
        }
        return { changed: missionsChanged, completedOrFailed };
    }

    checkCargoMissionCompletionOnDock(player, systemIndex, planetIndex) {
        let cargoChanged = false;
        let creditsChanged = false;
        let missionsChanged = false;

        if (player.activeMissions) {
            const remainingMissions = [];
            player.activeMissions.forEach((mission) => {
                if (
                    mission.type === MISSION_TYPES.CARGO_DELIVERY &&
                    mission.status === "ACCEPTED" &&
                    mission.destinationSystemIndex === systemIndex &&
                    mission.destinationPlanetIndex === planetIndex
                ) {
                    const goodIdx = this.tradeGoods.findIndex(
                        (g) => g.name === mission.cargoGoodName,
                    );
                    if (
                        goodIdx !== -1 &&
                        player.cargo[goodIdx] >= mission.cargoQuantity
                    ) {
                        player.cargo[goodIdx] -= mission.cargoQuantity;
                        player.credits += mission.rewardCredits;
                        mission.status = "COMPLETED"; // Mark for removal / notification
                        cargoChanged = true;
                        creditsChanged = true;
                        missionsChanged = true;

                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "COMPLETED",
                            reward: mission.rewardCredits,
                            message: `Delivered ${mission.cargoQuantity} ${mission.cargoGoodName}.`,
                        });
                    } else {
                        this.io.to(player.id).emit("missionUpdate", {
                            missionId: mission.id,
                            status: "INFO",
                            message: `Need ${mission.cargoQuantity} ${mission.cargoGoodName} to complete. You have ${player.cargo[goodIdx] || 0}.`,
                        });
                        remainingMissions.push(mission); // Keep mission
                    }
                } else {
                    remainingMissions.push(mission); // Keep other missions
                }
            });
            if (missionsChanged) player.activeMissions = remainingMissions;
        }
        return { cargoChanged, creditsChanged, missionsChanged };
    }

    // Called by CombatManager when a target is destroyed
    handleTargetDestroyed(attackerPlayer, destroyedTargetPlayer) {
        let missionsUpdated = false;
        const completedBountiesForNotification = [];
        const attacker = this.playerManager.getPlayer(attackerPlayer.id); // Get live player object
        if (!attacker || !attacker.activeMissions) return;

        attacker.activeMissions.forEach((mission) => {
            if (
                mission.type === MISSION_TYPES.BOUNTY &&
                mission.status === "ACCEPTED" &&
                mission.targetSystemIndex === attacker.system
            ) {
                // Check if in correct system

                // For now, any player kill in the target system counts for "Pirate" bounty
                // Later, you might check `destroyedTargetPlayer.type` or if it's an NPC
                mission.targetsDestroyed = (mission.targetsDestroyed || 0) + 1;
                missionsUpdated = true;

                if (mission.targetsDestroyed >= mission.targetsRequired) {
                    mission.status = "COMPLETED";
                    attacker.credits += mission.rewardCredits;
                    completedBountiesForNotification.push({
                        missionId: mission.id,
                        status: "COMPLETED",
                        reward: mission.rewardCredits,
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                        message: "Bounty completed!",
                    });
                } else {
                    // Send progress update
                    this.io.to(attacker.id).emit("missionUpdate", {
                        missionId: mission.id,
                        status: "ACCEPTED", // Still accepted, just progress
                        progress: `${mission.targetsDestroyed}/${mission.targetsRequired}`,
                    });
                }
            }
        });

        if (missionsUpdated) {
            completedBountiesForNotification.forEach((update) =>
                this.io.to(attacker.id).emit("missionUpdate", update),
            );

            const oldMissionCount = attacker.activeMissions.length;
            attacker.activeMissions = attacker.activeMissions.filter(
                (m) => m.status === "ACCEPTED",
            );
            const newMissionCount = attacker.activeMissions.length;

            const playerUpdates = { credits: attacker.credits };
            if (oldMissionCount !== newMissionCount) {
                playerUpdates.activeMissions = attacker.activeMissions;
            }
            this.playerManager.updatePlayerState(attacker.id, playerUpdates);
        }
    }

    registerSocketHandlers(socket) {
        socket.on("requestMissions", ({ systemIndex, planetIndex }) => {
            const player = this.playerManager.getPlayer(socket.id);
            const planet = this.worldManager.getPlanet(
                systemIndex,
                planetIndex,
            );

            if (!player || !planet) {
                return socket.emit("actionFailed", {
                    message: "Invalid location for missions.",
                });
            }

            const availableMissions = planet.availableMissions.filter(
                (m) =>
                    m.timeLimit > Date.now() && // Not expired
                    (!player.activeMissions ||
                        !player.activeMissions.find((pm) => pm.id === m.id)), // Not already active for player
            );
            socket.emit("availableMissionsList", {
                systemIndex,
                planetIndex,
                missions: availableMissions,
            });
        });

        socket.on(
            "acceptMission",
            ({ missionId, systemIndex, planetIndex }) => {
                const player = this.playerManager.getPlayer(socket.id);
                const planet = this.worldManager.getPlanet(
                    systemIndex,
                    planetIndex,
                );

                if (!player || !planet) {
                    return socket.emit("actionFailed", {
                        message: "Cannot accept mission from this location.",
                    });
                }

                const missionIndex = planet.availableMissions.findIndex(
                    (m) => m.id === missionId,
                );
                if (missionIndex === -1) {
                    return socket.emit("actionFailed", {
                        message: "Mission not available or already taken.",
                    });
                }

                const missionToAccept = planet.availableMissions[missionIndex];

                if (missionToAccept.timeLimit < Date.now()) {
                    planet.availableMissions.splice(missionIndex, 1); // Remove expired
                    return socket.emit("actionFailed", {
                        message: "Mission has expired.",
                    });
                }
                if (player.activeMissions.length >= 5) {
                    // Max active missions limit
                    return socket.emit("actionFailed", {
                        message: "Too many active missions.",
                    });
                }

                missionToAccept.status = "ACCEPTED";
                if (
                    !missionToAccept.targetsDestroyed &&
                    missionToAccept.type === MISSION_TYPES.BOUNTY
                ) {
                    missionToAccept.targetsDestroyed = 0; // Ensure bounty missions start with 0 destroyed
                }
                player.activeMissions.push({ ...missionToAccept }); // Add a copy to player
                planet.availableMissions.splice(missionIndex, 1); // Remove from planet's available list

                socket.emit("missionAccepted", { mission: missionToAccept });
                this.playerManager.updatePlayerState(socket.id, {
                    activeMissions: player.activeMissions,
                });
            },
        );
    }
}

module.exports = MissionManager;

/* ===== END: hypernova/server/modules/mission_manager.js ===== */


/* ===== START: hypernova/server/modules/player_manager.js ===== */
// hypernova/server/modules/player_manager.js
const { MISSION_TYPES } = require("../config/game_config");
// const gameConfig = require("../config/game_config"); // No, gameConfig is passed in constructor

class PlayerManager {
    constructor(
        io,
        shipTypes,
        tradeGoods,
        gameConfigInstance,
        worldManagerInstance,
    ) {
        this.io = io;
        this.shipTypes = shipTypes;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfigInstance;
        this.players = {};
        this.worldManager = worldManagerInstance;
    }

    handleConnection(socket, initialWorldData = {}) {
        const defaultShipType =
            this.shipTypes[this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX] ||
            this.shipTypes[0];
        this.players[socket.id] = {
            id: socket.id,
            x: this.gameConfig.PLAYER_SPAWN_X || 400,
            y: this.gameConfig.PLAYER_SPAWN_Y || 300,
            angle: 0,
            vx: 0,
            vy: 0,
            type: this.gameConfig.DEFAULT_PLAYER_SHIP_TYPE_INDEX,
            credits: this.gameConfig.DEFAULT_PLAYER_CREDITS,
            cargo: new Array(this.tradeGoods.length).fill(0),
            maxCargo: defaultShipType.maxCargo,
            health: defaultShipType.maxHealth || 100,
            maxHealth: defaultShipType.maxHealth || 100,
            weapons: [],
            activeMissions: [],
            activeWeapon: null,
            lastShot: 0,
            system: 0,
            dockedAtPlanetIdentifier: null,
            destroyed: false,
            color:
                "#" +
                Math.floor(Math.random() * 0xffffff)
                    .toString(16)
                    .padStart(6, "0"),
            hyperjumpState: "idle",
            hyperjumpChargeTimeoutId: null,
        };

        console.log(
            `Player ${socket.id} connected. Initial ship: ${defaultShipType.name}. Initial credits: ${this.players[socket.id].credits}`,
        );

        socket.emit("init", {
            id: socket.id,
            ships: this.players,
            gameData: {
                ...initialWorldData,
                tradeGoods: this.tradeGoods,
                weapons: this.gameConfig.staticWeaponsData,
                shipTypes: this.shipTypes,
                MISSION_TYPES: this.gameConfig.MISSION_TYPES,
            },
        });

        socket.broadcast.emit("playerJoined", {
            id: socket.id,
            ship: this.players[socket.id],
        });

        this.registerSocketHandlers(socket);

        socket.on("clientLoadedDockedState", (receivedSyncData) => {
            console.log(
                `PlayerManager: Received 'clientLoadedDockedState' from ${socket.id} with data:`,
                JSON.stringify(receivedSyncData),
            );
            const player = this.players[socket.id];

            if (player && receivedSyncData) {
                if (receivedSyncData.credits !== undefined)
                    player.credits = receivedSyncData.credits;
                if (receivedSyncData.cargo !== undefined)
                    player.cargo = receivedSyncData.cargo;
                if (receivedSyncData.weapons !== undefined)
                    player.weapons = receivedSyncData.weapons;
                if (receivedSyncData.activeWeapon !== undefined)
                    player.activeWeapon = receivedSyncData.activeWeapon;
                if (receivedSyncData.health !== undefined)
                    player.health = receivedSyncData.health;
                if (receivedSyncData.activeMissions !== undefined)
                    player.activeMissions = receivedSyncData.activeMissions;

                if (receivedSyncData.type !== undefined) {
                    player.type = receivedSyncData.type;
                    const shipTypeDef = this.shipTypes[player.type];
                    if (shipTypeDef) {
                        player.maxCargo = shipTypeDef.maxCargo;
                        player.maxHealth = shipTypeDef.maxHealth;
                        if (player.health > player.maxHealth) {
                            player.health = player.maxHealth;
                        }
                    } else {
                        console.warn(
                            `PlayerManager: Unknown ship type ${receivedSyncData.type} for player ${socket.id}.`,
                        );
                    }
                }

                player.hyperjumpState = "idle"; // Ensure idle on load
                if (player.hyperjumpChargeTimeoutId) {
                    clearTimeout(player.hyperjumpChargeTimeoutId);
                    player.hyperjumpChargeTimeoutId = null;
                }

                if (
                    receivedSyncData.dockedAtDetails &&
                    receivedSyncData.dockedAtDetails.systemIndex !==
                        undefined &&
                    receivedSyncData.dockedAtDetails.planetIndex !== undefined
                ) {
                    player.dockedAtPlanetIdentifier = {
                        systemIndex:
                            receivedSyncData.dockedAtDetails.systemIndex,
                        planetIndex:
                            receivedSyncData.dockedAtDetails.planetIndex,
                    };
                    player.system =
                        receivedSyncData.dockedAtDetails.systemIndex;

                    if (
                        this.worldManager &&
                        typeof this.worldManager.getPlanet === "function"
                    ) {
                        const planet = this.worldManager.getPlanet(
                            player.dockedAtPlanetIdentifier.systemIndex,
                            player.dockedAtPlanetIdentifier.planetIndex,
                        );
                        if (planet) {
                            player.x = planet.x;
                            player.y = planet.y;
                        }
                    }
                    player.vx = 0;
                    player.vy = 0;

                    if (
                        this.worldManager &&
                        typeof this.worldManager.playerDockedAtPlanet ===
                            "function"
                    ) {
                        this.worldManager.playerDockedAtPlanet(
                            player,
                            player.dockedAtPlanetIdentifier.systemIndex,
                            player.dockedAtPlanetIdentifier.planetIndex,
                        );
                    }
                    console.log(
                        `PlayerManager: Synced server state for ${socket.id} to be DOCKED at system ${player.system}, planet ${player.dockedAtPlanetIdentifier.planetIndex}.`,
                    );
                } else {
                    player.dockedAtPlanetIdentifier = null;
                    if (receivedSyncData.x !== undefined)
                        player.x = receivedSyncData.x;
                    if (receivedSyncData.y !== undefined)
                        player.y = receivedSyncData.y;
                    if (receivedSyncData.angle !== undefined)
                        player.angle = receivedSyncData.angle;
                    if (receivedSyncData.vx !== undefined)
                        player.vx = receivedSyncData.vx;
                    if (receivedSyncData.vy !== undefined)
                        player.vy = receivedSyncData.vy;
                    if (receivedSyncData.system !== undefined)
                        player.system = receivedSyncData.system;
                    console.log(
                        `PlayerManager: Synced server state for ${socket.id} to be UNDOCKED in system ${player.system}.`,
                    );
                }

                const comprehensiveUpdate = {
                    x: player.x,
                    y: player.y,
                    vx: player.vx,
                    vy: player.vy,
                    angle: player.angle,
                    system: player.system,
                    dockedAtPlanetIdentifier: player.dockedAtPlanetIdentifier,
                    credits: player.credits,
                    cargo: player.cargo,
                    weapons: player.weapons,
                    activeWeapon: player.activeWeapon,
                    health: player.health,
                    maxHealth: player.maxHealth,
                    type: player.type,
                    maxCargo: player.maxCargo,
                    activeMissions: player.activeMissions,
                    hyperjumpState: player.hyperjumpState, // ensure client knows it's idle
                };
                this.updatePlayerState(socket.id, comprehensiveUpdate);
                console.log(
                    `PlayerManager: Server state for ${socket.id} fully updated and broadcasted after client load.`,
                );
            } else {
                console.warn(
                    `PlayerManager: Invalid data for 'clientLoadedDockedState' from ${socket.id}.`,
                );
            }
        });
    }

    handleDisconnect(socket) {
        const player = this.getPlayer(socket.id);
        if (player) {
            if (
                player.dockedAtPlanetIdentifier &&
                this.worldManager &&
                typeof this.worldManager.playerUndockedFromPlanet === "function"
            ) {
                this.worldManager.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
            if (player.hyperjumpChargeTimeoutId) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
                player.hyperjumpState = "idle";
                console.log(
                    `Player ${socket.id} disconnected, hyperjump charge cancelled.`,
                );
            }
        }
        console.log(`Player ${socket.id} disconnected.`);
        delete this.players[socket.id];
        this.io.emit("playerLeft", socket.id);
    }

    getPlayer(playerId) {
        return this.players[playerId];
    }

    updatePlayerState(playerId, updates) {
        if (this.players[playerId]) {
            Object.assign(this.players[playerId], updates);
            this.io.emit("state", { [playerId]: this.players[playerId] });
        }
    }

    broadcastPlayerState(playerId, specificUpdates) {
        if (this.players[playerId]) {
            const updateToSend = {};
            // Only copy known properties from specificUpdates to prevent unintended large objects
            const allowedKeys = [
                "x",
                "y",
                "vx",
                "vy",
                "angle",
                "system",
                "dockedAtPlanetIdentifier",
                "credits",
                "cargo",
                "health",
                "maxHealth",
                "type",
                "maxCargo",
                "weapons",
                "activeWeapon",
                "activeMissions",
                "destroyed",
                "hyperjumpState",
            ];
            for (const key of allowedKeys) {
                if (specificUpdates.hasOwnProperty(key)) {
                    updateToSend[key] = specificUpdates[key];
                }
            }
            if (Object.keys(updateToSend).length > 0) {
                this.io.emit("state", { [playerId]: updateToSend });
            } else if (!specificUpdates) {
                // if specificUpdates is null/undefined, send whole player object
                this.io.emit("state", { [playerId]: this.players[playerId] });
            }
        }
    }

    registerSocketHandlers(socket) {
        socket.on("control", (data) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.dockedAtPlanetIdentifier) return;

            // Client-side logic prevents new thrust/rotation if charging.
            // Server updates position based on client's drift.
            player.x = data.x;
            player.y = data.y;
            player.vx = data.vx;
            player.vy = data.vy;
            if (player.hyperjumpState !== "charging") {
                // Only update angle if not charging
                player.angle = data.angle;
            }
            // System changes are handled by hyperjump logic only
            // if (data.system !== undefined && player.system !== data.system) { player.system = data.system; }

            const minimalUpdate = {
                x: player.x,
                y: player.y,
                vx: player.vx,
                vy: player.vy,
                angle: player.angle,
                // system: player.system, // System is not sent in minimal update unless changed by hyperjump
            };
            socket.broadcast.emit("state", { [socket.id]: minimalUpdate });
        });

        socket.on("requestHyperjump", () => {
            const player = this.getPlayer(socket.id);
            if (!player || player.destroyed) return;

            if (player.dockedAtPlanetIdentifier) {
                return socket.emit("hyperjumpDenied", {
                    message: "Cannot engage hyperdrive while docked.",
                });
            }
            if (player.hyperjumpState !== "idle") {
                return socket.emit("hyperjumpDenied", {
                    message: "Hyperdrive already engaged or cooling down.",
                });
            }

            const currentSystemData = this.worldManager.getSystem(
                player.system,
            );
            if (currentSystemData && currentSystemData.planets) {
                for (const planet of currentSystemData.planets) {
                    const distSq =
                        (player.x - planet.x) ** 2 + (player.y - planet.y) ** 2;
                    if (
                        distSq <
                        this.gameConfig
                            .MIN_HYPERJUMP_DISTANCE_FROM_PLANET_SQUARED
                    ) {
                        return socket.emit("hyperjumpDenied", {
                            message: "Too close to a celestial body.",
                        });
                    }
                }
            }

            player.hyperjumpState = "charging";
            // Also update player state for other clients to know this player is charging
            this.updatePlayerState(socket.id, { hyperjumpState: "charging" });
            socket.emit("hyperjumpChargeStarted", {
                chargeTime: this.gameConfig.HYPERJUMP_CHARGE_TIME_MS,
            });
            console.log(`Player ${socket.id} starting hyperjump charge.`);

            player.hyperjumpChargeTimeoutId = setTimeout(() => {
                if (player.hyperjumpState !== "charging" || player.destroyed) {
                    // Check destroyed status too
                    player.hyperjumpChargeTimeoutId = null;
                    if (
                        player.hyperjumpState === "charging" &&
                        !player.destroyed
                    )
                        player.hyperjumpState = "idle"; // Reset if not destroyed but cancelled
                    this.updatePlayerState(socket.id, {
                        hyperjumpState: player.hyperjumpState,
                    });
                    return;
                }

                player.hyperjumpState = "idle";
                player.hyperjumpChargeTimeoutId = null;

                const oldSystem = player.system;
                player.system =
                    (player.system + 1) % this.worldManager.systems.length;

                let newX,
                    newY,
                    newAngle = 0;
                const targetSystemData = this.worldManager.getSystem(
                    player.system,
                );
                if (targetSystemData && targetSystemData.planets.length > 0) {
                    const arrivalPlanet = targetSystemData.planets[0];
                    newX = arrivalPlanet.x - 250;
                    newY = arrivalPlanet.y;
                    newAngle = 0;
                } else {
                    newX = 100;
                    newY = this.gameConfig.PLAYER_SPAWN_Y || 300;
                    newAngle = 0;
                }

                player.x = newX;
                player.y = newY;
                player.vx = 0;
                player.vy = 0;
                player.angle = newAngle;
                player.dockedAtPlanetIdentifier = null;

                console.log(
                    `Player ${socket.id} hyperjump complete. Old system: ${oldSystem}, New system: ${player.system}.`,
                );

                socket.emit("hyperjumpComplete", {
                    newSystem: player.system,
                    newX: player.x,
                    newY: player.y,
                    newAngle: player.angle,
                });

                this.updatePlayerState(socket.id, {
                    system: player.system,
                    x: player.x,
                    y: player.y,
                    vx: player.vx,
                    vy: player.vy,
                    angle: player.angle,
                    dockedAtPlanetIdentifier: null,
                    hyperjumpState: "idle",
                });
            }, this.gameConfig.HYPERJUMP_CHARGE_TIME_MS);
        });

        socket.on("cancelHyperjump", () => {
            const player = this.getPlayer(socket.id);
            if (
                player &&
                player.hyperjumpState === "charging" &&
                player.hyperjumpChargeTimeoutId
            ) {
                clearTimeout(player.hyperjumpChargeTimeoutId);
                player.hyperjumpChargeTimeoutId = null;
                player.hyperjumpState = "idle";
                this.updatePlayerState(socket.id, { hyperjumpState: "idle" });
                socket.emit("hyperjumpCancelled", {
                    message: "Hyperjump cancelled by player.",
                });
                console.log(`Player ${socket.id} cancelled hyperjump charge.`);
            }
        });

        socket.on("equipWeapon", ({ weapon: weaponName }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message:
                        "Cannot modify equipment while hyperdrive is active.",
                });
            }
            const weaponData = this.gameConfig.staticWeaponsData[weaponName];
            if (!weaponData)
                return socket.emit("actionFailed", {
                    message: "Invalid weapon.",
                });

            if (!player.weapons.includes(weaponName)) {
                if (player.credits >= weaponData.price) {
                    player.credits -= weaponData.price;
                    player.weapons.push(weaponName);
                    player.activeWeapon = weaponName;
                    this.updatePlayerState(socket.id, {
                        credits: player.credits,
                        weapons: player.weapons,
                        activeWeapon: player.activeWeapon,
                    });
                    socket.emit("actionSuccess", {
                        message: `Purchased and equipped ${weaponName}.`,
                    });
                } else {
                    return socket.emit("actionFailed", {
                        message: "Not enough credits.",
                    });
                }
            } else {
                player.activeWeapon = weaponName;
                this.updatePlayerState(socket.id, {
                    activeWeapon: player.activeWeapon,
                });
                socket.emit("actionSuccess", {
                    message: `Equipped ${weaponName}.`,
                });
            }
        });

        socket.on("buyShip", ({ shipTypeIndex }) => {
            const player = this.getPlayer(socket.id);
            if (!player || player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot buy ship while hyperdrive is active.",
                });
            }
            if (shipTypeIndex < 0 || shipTypeIndex >= this.shipTypes.length) {
                return socket.emit("actionFailed", {
                    message: "Invalid ship type.",
                });
            }
            const newShipType = this.shipTypes[shipTypeIndex];
            if (player.credits < newShipType.price) {
                return socket.emit("actionFailed", {
                    message: "Not enough credits.",
                });
            }
            player.credits -= newShipType.price;
            player.type = shipTypeIndex;
            player.maxCargo = newShipType.maxCargo;
            player.cargo = new Array(this.tradeGoods.length).fill(0);
            player.maxHealth = newShipType.maxHealth || 100;
            player.health = player.maxHealth;
            this.updatePlayerState(socket.id, {
                credits: player.credits,
                type: player.type,
                maxCargo: player.maxCargo,
                cargo: player.cargo,
                maxHealth: player.maxHealth,
                health: player.health,
            });
            socket.emit("actionSuccess", {
                message: `Successfully purchased ${newShipType.name}.`,
            });
        });
    }

    checkAllPlayerMissionTimeouts(missionManager) {
        Object.values(this.players).forEach((player) => {
            if (
                player &&
                !player.destroyed &&
                player.activeMissions.length > 0
            ) {
                const { changed, completedOrFailed } =
                    missionManager.checkPlayerMissionTimeouts(player);
                if (changed) {
                    completedOrFailed.forEach((update) =>
                        this.io.to(player.id).emit("missionUpdate", update),
                    );
                    this.updatePlayerState(player.id, {
                        credits: player.credits,
                        activeMissions: player.activeMissions,
                    });
                }
            }
        });
    }

    getAllPlayers() {
        return this.players;
    }

    handlePlayerHitDuringHyperjumpCharge(playerId) {
        const player = this.getPlayer(playerId);
        if (
            player &&
            player.hyperjumpState === "charging" &&
            player.hyperjumpChargeTimeoutId
        ) {
            clearTimeout(player.hyperjumpChargeTimeoutId);
            player.hyperjumpChargeTimeoutId = null;
            player.hyperjumpState = "idle";
            this.updatePlayerState(playerId, { hyperjumpState: "idle" }); // Inform all clients
            this.io
                .to(playerId)
                .emit("hyperjumpCancelled", {
                    message: "Hyperjump disrupted by enemy fire!",
                });
            console.log(
                `Player ${playerId} hyperjump charge disrupted by damage.`,
            );
        }
    }
}

module.exports = PlayerManager;

/* ===== END: hypernova/server/modules/player_manager.js ===== */


/* ===== START: hypernova/server/modules/world_manager.js ===== */
// server/modules/world_manager.js
class WorldManager {
    constructor(io, systemsBase, tradeGoods, gameConfig) {
        this.io = io;
        this.systemsBase = systemsBase;
        this.tradeGoods = tradeGoods;
        this.gameConfig = gameConfig;
        this.systems = [];
        this.economyManager = null;
        this.missionManager = null;
    }

    initialize(economyManager, missionManager) {
        this.economyManager = economyManager;
        this.missionManager = missionManager;
        this.systems = JSON.parse(JSON.stringify(this.systemsBase));

        this.systems.forEach((system) => {
            system.planets.forEach((planet) => {
                planet.stock = {};
                planet.buyPrices = {};
                planet.sellPrices = {};
                planet.availableMissions = [];
                planet.dockedShipId = null;
            });
        });

        this.economyManager.initializeAllPlanetEconomies(this.systems);
        this.missionManager.populateAllPlanetMissions(this.systems); // Pass systems here if needed by populate

        console.log("WorldManager initialized, systems processed.");
    }

    getSystem(systemIndex) {
        return this.systems[systemIndex];
    }

    getPlanet(systemIndex, planetIndex) {
        const system = this.getSystem(systemIndex);
        return system ? system.planets[planetIndex] : null;
    }

    getPlanetDetailsForDocking(systemIndex, planetIndex) {
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (planet) {
            return { x: planet.x, y: planet.y, name: planet.name };
        }
        return null;
    }

    playerDockedAtPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            console.error(
                "WorldManager.playerDockedAtPlanet: Player object is null/undefined.",
            );
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            console.error(
                `WorldManager.playerDockedAtPlanet: Planet ${planetIndex} in system ${systemIndex} not found.`,
            );
            return false;
        }

        if (planet.dockedShipId && planet.dockedShipId !== player.id) {
            console.warn(
                `WorldManager.playerDockedAtPlanet: Planet ${planet.name} is already occupied by ${planet.dockedShipId}. Player ${player.id} cannot dock.`,
            );
            return false;
        }

        if (player.dockedAtPlanetIdentifier) {
            if (
                player.dockedAtPlanetIdentifier.systemIndex !== systemIndex ||
                player.dockedAtPlanetIdentifier.planetIndex !== planetIndex
            ) {
                this.playerUndockedFromPlanet(
                    player,
                    player.dockedAtPlanetIdentifier.systemIndex,
                    player.dockedAtPlanetIdentifier.planetIndex,
                );
            }
        }

        planet.dockedShipId = player.id;
        console.log(
            `WorldManager: Player ${player.id} server-side DOCKED at ${planet.name} (System: ${this.systems[systemIndex].name}).`,
        );
        return true;
    }

    playerUndockedFromPlanet(player, systemIndex, planetIndex) {
        if (!player) {
            return false;
        }
        const planet = this.getPlanet(systemIndex, planetIndex);
        if (!planet) {
            return false;
        }

        if (planet.dockedShipId === player.id) {
            planet.dockedShipId = null;
            console.log(
                `WorldManager: Player ${player.id} server-side UNDOCKED from ${planet.name}.`,
            );
            return true;
        }
        return false;
    }

    getSystemsForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            planets: s.planets.map((p) => ({
                name: p.name,
                x: p.x,
                y: p.y,
                imageFile: p.imageFile, // Make sure imageFile is passed for client
            })),
        }));
    }

    getEconomiesForClient() {
        return this.systems.map((s) => ({
            name: s.name,
            planets: s.planets.map((p) => ({
                name: p.name,
                stock: p.stock,
                buyPrices: p.buyPrices,
                sellPrices: p.sellPrices,
            })),
        }));
    }

    registerSocketHandlers(socket, playerManager) {
        socket.on("dock", ({ systemIndex, planetIndex }) => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });

            if (player.hyperjumpState === "charging") {
                return socket.emit("actionFailed", {
                    message: "Cannot dock while hyperdrive is charging.",
                });
            }

            if (player.system !== systemIndex) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Wrong system.",
                });
            }
            const planet = this.getPlanet(systemIndex, planetIndex);
            if (!planet) {
                return socket.emit("actionFailed", {
                    message: "Cannot dock: Planet not found.",
                });
            }

            if (this.playerDockedAtPlanet(player, systemIndex, planetIndex)) {
                player.dockedAtPlanetIdentifier = { systemIndex, planetIndex };
                player.vx = 0;
                player.vy = 0;
                player.x = planet.x;
                player.y = planet.y;

                const missionCompletionResult =
                    this.missionManager.checkCargoMissionCompletionOnDock(
                        player,
                        systemIndex,
                        planetIndex,
                    );

                socket.emit("dockConfirmed", {
                    systemIndex,
                    planetIndex,
                    planetName: planet.name,
                    systemName: this.systems[systemIndex].name,
                    buyPrices: planet.buyPrices,
                    sellPrices: planet.sellPrices,
                    stock: planet.stock,
                    playerX: player.x,
                    playerY: player.y,
                });

                const updatesForPlayer = {
                    dockedAtPlanetIdentifier: player.dockedAtPlanetIdentifier,
                    vx: 0,
                    vy: 0,
                    x: player.x,
                    y: player.y,
                };
                if (missionCompletionResult.creditsChanged)
                    updatesForPlayer.credits = player.credits;
                if (missionCompletionResult.cargoChanged)
                    updatesForPlayer.cargo = player.cargo;
                if (missionCompletionResult.missionsChanged)
                    updatesForPlayer.activeMissions = player.activeMissions;

                playerManager.updatePlayerState(socket.id, updatesForPlayer);
            } else {
                socket.emit("actionFailed", {
                    message: "Docking failed. Planet may be occupied.",
                });
            }
        });

        socket.on("undock", () => {
            const player = playerManager.getPlayer(socket.id);
            if (!player)
                return socket.emit("actionFailed", {
                    message: "Player not found.",
                });
            if (!player.dockedAtPlanetIdentifier) {
                return socket.emit("actionFailed", {
                    message: "Not docked (according to server).",
                });
            }
            const { systemIndex, planetIndex } =
                player.dockedAtPlanetIdentifier;
            if (
                this.playerUndockedFromPlanet(player, systemIndex, planetIndex)
            ) {
                player.dockedAtPlanetIdentifier = null;
                socket.emit("undockConfirmed");
                playerManager.updatePlayerState(socket.id, {
                    dockedAtPlanetIdentifier: null,
                });
            } else {
                socket.emit("actionFailed", {
                    message: "Server undocking failed.",
                });
            }
        });
    }
}

module.exports = WorldManager;

/* ===== END: hypernova/server/modules/world_manager.js ===== */


/* ===== START: hypernova/server/utils/data_loader.js ===== */
const fs = require("fs").promises;
const path = require("path");

const dataDir = path.join(__dirname, "../data");

async function loadJson(filename) {
    const filePath = path.join(dataDir, filename);
    try {
        const fileContent = await fs.readFile(filePath, "utf-8");
        return JSON.parse(fileContent);
    } catch (error) {
        console.error(`Error loading data file ${filename}:`, error);
        throw error; // Or return null/empty object depending on desired error handling
    }
}

async function loadAllData() {
    try {
        const [tradeGoods, weapons, systemsBase, shipTypes] = await Promise.all(
            [
                loadJson("trade_goods.json"),
                loadJson("weapons.json"),
                loadJson("systems_init.json"),
                loadJson("ship_types.json"),
            ],
        );
        return { tradeGoods, weapons, systemsBase, shipTypes };
    } catch (error) {
        console.error("Failed to load critical game data. Exiting.", error);
        process.exit(1);
    }
}

module.exports = {
    loadAllData,
};

/* ===== END: hypernova/server/utils/data_loader.js ===== */


/* ===== START: hypernova/server/utils/helpers.js ===== */
function generateMissionId() {
    return `mission_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

// Note: systemsData is the live systems array from WorldManager
function getSystemDistance(systemIndex1, systemIndex2, numSystems) {
    if (numSystems === 0) return 0;
    const diff = Math.abs(systemIndex1 - systemIndex2);
    return Math.min(diff, numSystems - diff);
}

module.exports = {
    generateMissionId,
    getSystemDistance,
};

/* ===== END: hypernova/server/utils/helpers.js ===== */
